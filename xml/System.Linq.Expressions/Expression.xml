<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="60e59-101">Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span></span> <span data-ttu-id="60e59-102">También contiene métodos de generador <see langword="static" /> (<see langword="Shared" /> en Visual Basic) para crear los diversos tipos de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span></span> <span data-ttu-id="60e59-103">Esta es una clase <see langword="abstract" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-103">This is an <see langword="abstract" /> class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-104">En el ejemplo de código siguiente se muestra cómo crear una expresión de bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="60e59-105">La expresión de bloque se compone de dos <xref:System.Linq.Expressions.MethodCallExpression> objetos y uno <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-106">Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-107">Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType"><span data-ttu-id="60e59-108"><see cref="T:System.Linq.Expressions.ExpressionType" /> que se va a establecer como tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-109"><see cref="P:System.Linq.Expressions.Expression.Type" /> de este <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="60e59-110">Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-111">Se llama a este constructor desde los constructores en las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="60e59-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="60e59-112">Visitante con el que se va a visitar este nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-112">The visitor to visit this node with.</span></span></param>
        <summary><span data-ttu-id="60e59-113">Envía la expresión al método de visita específico de este tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-113">Dispatches to the specific visit method for this node type.</span></span> <span data-ttu-id="60e59-114">Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-115">Resultado de visitar este nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-115">The result of visiting this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-116">Esta implementación predeterminada para <xref:System.Linq.Expressions.ExpressionType.Extension> llamadas nodos <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="60e59-117">Invalide este método para llamar a un método más específico en una clase de visitante derivado de la <xref:System.Linq.Expressions.ExpressionVisitor> clase.</span><span class="sxs-lookup"><span data-stu-id="60e59-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="60e59-118">Sin embargo, todavía debería admitir a los visitantes desconocidos mediante una llamada a <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-119">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-120">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-121">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-122">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-123"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-124">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-125">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-126">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-127">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-128">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-129">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-130">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-130">Implementing Method</span></span>  
 <span data-ttu-id="60e59-131">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-132">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de suma, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-133">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-134">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-135">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-136">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-137">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-138">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-139">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-140">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-141">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-142">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-143">El tipo del nodo es el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="60e59-144">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-145">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-146">En el ejemplo de código siguiente se muestra cómo crear una expresión que agrega dos enteros.</span><span class="sxs-lookup"><span data-stu-id="60e59-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-147">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-147"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-148">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-149">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-150">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-151">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-152">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span> <span data-ttu-id="60e59-153">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-153">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-154"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-155">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-156">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-157">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-158">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-159">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-160">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-161">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-161">Implementing Method</span></span>  
 <span data-ttu-id="60e59-162">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-163">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-164">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de suma, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-165">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-166">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-167">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-168">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-169">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-170">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-171">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-172">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-173">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-174">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-175">El tipo del nodo es el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="60e59-176">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-177">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-178">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-178"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-179"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-179"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-180"><paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-180"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-181">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-182">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-183">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-184">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-185"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-186">En el ejemplo de código siguiente se muestra cómo crear una expresión que agrega un valor a una variable de entero y, a continuación, asigna el resultado de la operación a la variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-187">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-188">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-189">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-190">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-191"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-192">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-193">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-194">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-195">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-196">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-197"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-198">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-199">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-200">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-201">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-202"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-203">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-204">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-205">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-206">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-207"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-208">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-209">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-210">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-211">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-212">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-213"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-214">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-215">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-216">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-217">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-218"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-219">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-220">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-221">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-222">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-223">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-224">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-225">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-225">Implementing Method</span></span>  
 <span data-ttu-id="60e59-226">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-227">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de suma, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-228">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-229">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-230">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-231">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-232">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-233">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-234">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-235">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-236">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-237">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-238">El tipo del nodo es el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="60e59-239">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-240">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-241">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-241"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-242">No hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-243">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-244">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-245">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-246">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span> <span data-ttu-id="60e59-247">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-247">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-248"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-249">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-250">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-251">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-252">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-253">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-254">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-255">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-255">Implementing Method</span></span>  
 <span data-ttu-id="60e59-256">El método de implementación para la operación se elige según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="60e59-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="60e59-257">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-258">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de suma, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-259">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-260">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-261">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-262">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-263">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-264">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-265">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-266">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-267">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-268">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-269">El tipo del nodo es el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="60e59-270">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-271">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de suma predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-272">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-272"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-273"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-273"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-274"><paramref name="method" /> es <see langword="null" /> y el operador de adición no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-274"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-275">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-276"><see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-277">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-278">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-279"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-280">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-281">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-282">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-283">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-284">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-285">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-286">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-286">Implementing Method</span></span>  
 <span data-ttu-id="60e59-287">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-288">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `AND` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-289">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-290">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-291">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-292">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-293">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-294">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-295">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-296">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-297">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-298">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-299">El tipo del nodo es el tipo de resultado de predefinido bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="60e59-300">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-301">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-302">En el ejemplo de código siguiente se muestra cómo crear una expresión que represente una operación AND lógica en dos valores booleanos.</span><span class="sxs-lookup"><span data-stu-id="60e59-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-303">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-303"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-304">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-305">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-306">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-307">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-308">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span> <span data-ttu-id="60e59-309">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-309">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-310"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-311">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-312">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-313">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-314">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-315">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-316">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-317">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-317">Implementing Method</span></span>  
 <span data-ttu-id="60e59-318">El método de implementación para la operación se elige según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="60e59-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="60e59-319">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-320">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `AND` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-321">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-322">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-323">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-324">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-325">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-326">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-327">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-328">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-329">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-330">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-331">El tipo del nodo es el tipo de resultado de predefinido bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="60e59-332">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-333">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-334">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-334"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-335"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-335"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-336"><paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-336"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-337">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-338">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-339">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-340">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-341"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-342">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-343">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-344">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-345">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-346">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-347">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-348">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-348">Implementing Method</span></span>  
 <span data-ttu-id="60e59-349">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-350">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `AND` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="60e59-351">El atributo conditional `AND` no se pueden sobrecargar el operador en C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="60e59-352">Sin embargo, el atributo conditional `AND` operador se evalúa utilizando bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="60e59-353">Por lo tanto, una sobrecarga definida por el usuario del bit a bit `AND` puede ser el método de implementación para este tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="60e59-354">De lo contrario, si `left`. Tipo y `right`. Type son tipos booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-355">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-356">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-357">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-358">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-359">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-360">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL, y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-361">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-362">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-363">`left`. Tipo y `right`. Tipo son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="60e59-364">If `left`. Tipo y `right`. Tipo que no acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-365">El tipo del nodo es el tipo de resultado de la instrucción condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="60e59-366">If `left`. Tipo y `right`. Tipo que acepta valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-367">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de la instrucción condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-368">En el ejemplo de código siguiente se muestra cómo crear una expresión que realiza una operación lógica y operación en Sí si solo dos operandos el primer operando se evalúa como `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-369">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-369"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-370">No hay ningún operador <see langword="AND" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-371">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-371">-or-</span></span>  
  
 <span data-ttu-id="60e59-372"><paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-372"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-373">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-374">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-375">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-376">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="AND" /> condicional que evalúa el segundo operando solo si el primer operando se resuelve como true.</span><span class="sxs-lookup"><span data-stu-id="60e59-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span></span> <span data-ttu-id="60e59-377">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-377">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-378"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-379">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-380">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-381">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-382">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-383">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-384">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-385">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-385">Implementing Method</span></span>  
 <span data-ttu-id="60e59-386">El método de implementación para la operación se elige según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="60e59-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="60e59-387">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-388">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `AND` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="60e59-389">El atributo conditional `AND` no se pueden sobrecargar el operador en C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="60e59-390">Sin embargo, el atributo conditional `AND` operador se evalúa utilizando bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="60e59-391">Por lo tanto, una sobrecarga definida por el usuario del bit a bit `AND` puede ser el método de implementación para este tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="60e59-392">De lo contrario, si `left`. Tipo y `right`. Type son tipos booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-393">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-394">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-395">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-396">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-397">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-398">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL, y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-399">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-400">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-401">`left`. Tipo y `right`. Tipo son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="60e59-402">If `left`. Tipo y `right`. Tipo que no acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-403">El tipo del nodo es el tipo de resultado de la instrucción condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="60e59-404">If `left`. Tipo y `right`. Tipo que acepta valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-405">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de la instrucción condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-406">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-406"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-407"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-407"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-408"><paramref name="method" /> es <see langword="null" /> y el operador <see langword="AND" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-408"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-409">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-409">-or-</span></span>  
  
 <span data-ttu-id="60e59-410"><paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-410"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-411">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-412">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-413">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-414">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-415"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-416">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-417">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-418">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-419">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-420"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-421">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-422">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-423">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-424">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-425">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-426"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-427">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-428">Expresión que representa la matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-428">An expression that represents the multidimensional array.</span></span></param>
        <param name="indexes"><span data-ttu-id="60e59-429"><see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="60e59-430">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="60e59-431">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-432">La expresión que representa la matriz puede obtenerse mediante la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, o a través <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-433">En el ejemplo de código siguiente se muestra cómo cambiar el valor de un elemento de una matriz multidimensional utilizando el `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="60e59-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-434">Expresión que representa la matriz para indizar.</span><span class="sxs-lookup"><span data-stu-id="60e59-434">An expression representing the array to index.</span></span></param>
        <param name="indexes"><span data-ttu-id="60e59-435">Matriz que contiene expresiones usadas para indizar la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-435">An array that contains expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="60e59-436">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
        <returns><span data-ttu-id="60e59-437">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-438">La expresión que representa la matriz puede obtenerse mediante la <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, o a través <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="60e59-439">Para las matrices multidimensionales, utilice el <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60e59-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-440">En el ejemplo de código siguiente se muestra cómo cambiar un valor de un elemento de matriz utilizando el `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="60e59-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-441">Crea un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la aplicación de un operador de índice de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-442">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span></span></param>
        <param name="indexes"><span data-ttu-id="60e59-443">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-444">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</span><span class="sxs-lookup"><span data-stu-id="60e59-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span></span></summary>
        <returns><span data-ttu-id="60e59-445"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-446">Cada elemento de `indexes` debe tener <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60e59-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="60e59-447">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `array` debe representar un tipo de matriz cuyo rango coincide con el número de elementos de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="60e59-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="60e59-448">Si el rango de `array`. El tipo es 1, este método devuelve un <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="60e59-449">El <xref:System.Linq.Expressions.BinaryExpression.Left%2A> propiedad está establecida en `array` y <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propiedad se establece en el único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="60e59-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="60e59-450">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de la <xref:System.Linq.Expressions.BinaryExpression> representa el tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="60e59-451">Si el rango de `array`. Tipo es más de uno, este método devuelve un <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="60e59-452">El <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> propiedad está establecida en el <xref:System.Reflection.MethodInfo> que describe el método de instancia público `Get` en el tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `array`.</span><span class="sxs-lookup"><span data-stu-id="60e59-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-453">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.MethodCallExpression> que representa la indización en una matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-454">El valor de <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-454"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-455"><paramref name="array" />.Type no representa un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-455"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
 <span data-ttu-id="60e59-456">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-456">-or-</span></span>  
  
 <span data-ttu-id="60e59-457">El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
 <span data-ttu-id="60e59-458">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-458">-or-</span></span>  
  
 <span data-ttu-id="60e59-459">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-460">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="index"><span data-ttu-id="60e59-461">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-462">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</span><span class="sxs-lookup"><span data-stu-id="60e59-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span></span></summary>
        <returns><span data-ttu-id="60e59-463"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-464">`index` debe representar un índice de tipo <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60e59-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="60e59-465">El <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.BinaryExpression> es `null`y ambos <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> se establecen en `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="60e59-466">El <xref:System.Linq.Expressions.Expression.Type%2A> es igual al tipo de elemento de propiedad `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="60e59-467">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-468">El valor de <paramref name="array" /> o <paramref name="index" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-468"><paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-469"><paramref name="array" />.Type no representa un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-469"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
 <span data-ttu-id="60e59-470">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-470">-or-</span></span>  
  
 <span data-ttu-id="60e59-471"><paramref name="array" />.Type representa un tipo de matriz cuyo rango no es 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-471"><paramref name="array" />.Type represents an array type whose rank is not 1.</span></span>  
  
 <span data-ttu-id="60e59-472">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-472">-or-</span></span>  
  
 <span data-ttu-id="60e59-473"><paramref name="index" />.Type no representa el tipo <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-473"><paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-474">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span></span></param>
        <param name="indexes"><span data-ttu-id="60e59-475">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-476">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="60e59-477"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-478">Cada elemento de `indexes` debe tener <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60e59-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="60e59-479">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `array` debe representar un tipo de matriz cuyo rango coincide con el número de elementos de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="60e59-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="60e59-480">Si el rango de `array`. El tipo es 1, este método devuelve un <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="60e59-481">El <xref:System.Linq.Expressions.BinaryExpression.Left%2A> propiedad está establecida en `array` y <xref:System.Linq.Expressions.BinaryExpression.Right%2A> propiedad se establece en el único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="60e59-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="60e59-482">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de la <xref:System.Linq.Expressions.BinaryExpression> representa el tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="60e59-483">Si el rango de `array`. Tipo es más de uno, este método devuelve un <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="60e59-484">El <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> propiedad está establecida en el <xref:System.Reflection.MethodInfo> que describe el método de instancia público `Get` en el tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `array`.</span><span class="sxs-lookup"><span data-stu-id="60e59-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-485">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.MethodCallExpression> que representa la indización en una matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-486">El valor de <paramref name="array" /> o <paramref name="indexes" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-486"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-487"><paramref name="array" />.Type no representa un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-487"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
 <span data-ttu-id="60e59-488">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-488">-or-</span></span>  
  
 <span data-ttu-id="60e59-489">El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
 <span data-ttu-id="60e59-490">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-490">-or-</span></span>  
  
 <span data-ttu-id="60e59-491">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="60e59-492">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-493">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="60e59-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="60e59-494"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-495">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `array` debe representar un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="60e59-496">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> es igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60e59-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="60e59-497">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad es `null`y ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> se establecen en `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-498"><paramref name="array" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-498"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-499"><paramref name="array" />.Type no representa un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-499"><paramref name="array" />.Type does not represent an array type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-500">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-501">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-502">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</span><span class="sxs-lookup"><span data-stu-id="60e59-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-503"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-504">El `Assign` expresión copia un valor para los tipos de valor y copia una referencia para los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-505">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa una operación de asignación.</span><span class="sxs-lookup"><span data-stu-id="60e59-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-506">Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro.</span><span class="sxs-lookup"><span data-stu-id="60e59-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="60e59-507">
          <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="expression"><span data-ttu-id="60e59-508">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-509">Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span></span></summary>
        <returns><span data-ttu-id="60e59-510"><see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-511">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `expression` debe ser asignable al tipo representado por la <xref:System.Reflection.FieldInfo.FieldType%2A> o <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad de `member`.</span><span class="sxs-lookup"><span data-stu-id="60e59-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-512">El valor de <paramref name="member" /> o <paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-512"><paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-513"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-513"><paramref name="member" /> does not represent a field or property.</span></span>  
  
 <span data-ttu-id="60e59-514">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-514">-or-</span></span>  
  
 <span data-ttu-id="60e59-515">La propiedad representada por <paramref name="member" /> no tiene un descriptor de acceso <see langword="set" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span></span>  
  
 <span data-ttu-id="60e59-516">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-516">-or-</span></span>  
  
 <span data-ttu-id="60e59-517"><paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-517"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="60e59-518">
          <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="expression"><span data-ttu-id="60e59-519">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-520">Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-521"><see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-522">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `expression` debe ser asignable al tipo representado por la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad de la propiedad al que obtuvo acceso `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-523">El valor de <paramref name="propertyAccessor" /> o <paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-523"><paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-524"><paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-524"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
 <span data-ttu-id="60e59-525">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-525">-or-</span></span>  
  
 <span data-ttu-id="60e59-526">La propiedad a la que accede <paramref name="propertyAccessor" /> no tiene un descriptor de acceso <see langword="set" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span></span>  
  
 <span data-ttu-id="60e59-527">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-527">-or-</span></span>  
  
 <span data-ttu-id="60e59-528"><paramref name="expression" />.Type no se puede asignar al tipo del campo o propiedad que representa <paramref name="member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-528"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-529">Crea una interfaz <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="60e59-530">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-530">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-531">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-532">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-533">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="60e59-534">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-534">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-535">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-536">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-537">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-538">En el ejemplo de código siguiente se muestra cómo crear una expresión de bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="60e59-539">La expresión de bloque se compone de dos <xref:System.Linq.Expressions.MethodCallExpression> objetos y uno <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="60e59-540">Variables del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-540">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-541">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-541">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-542">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</span><span class="sxs-lookup"><span data-stu-id="60e59-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-543">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-544">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-545">En el ejemplo de código siguiente se muestra cómo pasar un parámetro a una expresión de bloque y procesar este parámetro dentro de un bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="60e59-546">Variables del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-546">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-547">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-547">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-548">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</span><span class="sxs-lookup"><span data-stu-id="60e59-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-549">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-550">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="60e59-551">Primera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-551">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-552">Segunda expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-552">The second expression in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-553">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-554">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-555">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-556">Tipo de resultado del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-556">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-557">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-557">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-558">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</span><span class="sxs-lookup"><span data-stu-id="60e59-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="60e59-559">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-560">Tipo de resultado del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-560">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-561">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-561">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-562">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</span><span class="sxs-lookup"><span data-stu-id="60e59-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="60e59-563">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="60e59-564">Primera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-564">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-565">Segunda expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-565">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-566">Tercera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-566">The third expression in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-567">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-568">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-569">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-570">Tipo de resultado del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-570">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="60e59-571">Variables del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-571">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-572">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-572">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-573">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</span><span class="sxs-lookup"><span data-stu-id="60e59-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-574">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-575">Tipo de resultado del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-575">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="60e59-576">Variables del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-576">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="60e59-577">Expresiones del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-577">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-578">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</span><span class="sxs-lookup"><span data-stu-id="60e59-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-579">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="60e59-580">Primera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-580">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-581">Segunda expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-581">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-582">Tercera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-582">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-583">Cuarta expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-583">The fourth expression in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-584">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-585">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-586">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="60e59-587">Primera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-587">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-588">Segunda expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-588">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-589">Tercera expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-589">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-590">Cuarta expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-590">The fourth expression in the block.</span></span></param>
        <param name="arg4"><span data-ttu-id="60e59-591">Quinta expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-591">The fifth expression in the block.</span></span></param>
        <summary><span data-ttu-id="60e59-592">Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</span><span class="sxs-lookup"><span data-stu-id="60e59-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="60e59-593">Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-594">Cuando la expresión de bloque se ejecuta, devuelve el valor de la última expresión del bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-595">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</span><span class="sxs-lookup"><span data-stu-id="60e59-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-596">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="60e59-597">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</span><span class="sxs-lookup"><span data-stu-id="60e59-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-598"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-599">En el ejemplo siguiente se muestra cómo crear una expresión que contiene un <xref:System.Linq.Expressions.LoopExpression> objeto que usa el <xref:System.Linq.Expressions.Expression.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60e59-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-600">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-601">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-601">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="60e59-602">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</span><span class="sxs-lookup"><span data-stu-id="60e59-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span> <span data-ttu-id="60e59-603">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-603">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-604"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-605">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-606">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-607">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-608"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-609">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-610">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-610">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-611">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-612">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span> <span data-ttu-id="60e59-613">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-613">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-614"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-615">Crea una interfaz <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-616">
          <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-617">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-618">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-619"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-620">Para representar una llamada a un `static` (`Shared` en Visual Basic) método, pase `null` para el `instance` parámetro cuando se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="60e59-621">Si `method` representa un método de instancia, el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `instance` debe ser asignable al tipo declarativo del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="60e59-622">El <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> está vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="60e59-623">El <xref:System.Linq.Expressions.Expression.Type%2A> es igual que el tipo de valor devuelto del método representado por la propiedad `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-624">En el ejemplo de código siguiente se muestra cómo crear una expresión que llama a un método sin argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-625"><paramref name="method" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-625"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-626">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-626">-or-</span></span>  
  
 <span data-ttu-id="60e59-627"><paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-627"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-628"><paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-628"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-629"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</span><span class="sxs-lookup"><span data-stu-id="60e59-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-630">Colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de llamada.</span><span class="sxs-lookup"><span data-stu-id="60e59-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span></span></param>
        <summary><span data-ttu-id="60e59-631">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span></span></summary>
        <returns><span data-ttu-id="60e59-632"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-633">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-634"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <summary><span data-ttu-id="60e59-635">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) que toma un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span></span></summary>
        <returns><span data-ttu-id="60e59-636"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-637">En el ejemplo siguiente se muestra cómo crear una expresión que requiere un `static` (`Shared` en Visual Basic) método que toma un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-638"><paramref name="method" /> es null.</span><span class="sxs-lookup"><span data-stu-id="60e59-638"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-639"><see cref="T:System.Reflection.MethodInfo" /> que representa un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-640">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-641">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) que tiene argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-642"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-643">Si `arguments` no `null`, debe tener el mismo número de elementos que el número de parámetros para el método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="60e59-644">Cada elemento de `arguments` no debe ser `null` y se debe poder asignar al parámetro correspondiente de `method`, posiblemente después *entrecomillar*.</span><span class="sxs-lookup"><span data-stu-id="60e59-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-645">Un elemento se entrecomillará sólo si el parámetro correspondiente del método es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-646">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-647">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="60e59-648">El <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> está vacío si `arguments` es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="60e59-649">De lo contrario, contiene los mismos elementos que `arguments`, algunos de los cuales pueden ir entre comillas.</span><span class="sxs-lookup"><span data-stu-id="60e59-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="60e59-650">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> es igual que el tipo de valor devuelto del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="60e59-651">La propiedad <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-652"><paramref name="method" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-652"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-653">El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-654">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-654">-or-</span></span>  
  
 <span data-ttu-id="60e59-655">Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-656">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-657">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-658">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-659">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-660"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-661">Para representar una llamada a un `static` (`Shared` en Visual Basic) método, pase `null` para el `instance` parámetro cuando se llama a este método, o llamar a <xref:System.Linq.Expressions.Expression.Call%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60e59-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="60e59-662">Si `method` representa un método de instancia, el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `instance` debe ser asignable al tipo declarativo del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="60e59-663">Si `arguments` no `null`, debe tener el mismo número de elementos que el número de parámetros para el método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="60e59-664">Cada elemento de `arguments` no debe ser `null` y se debe poder asignar al parámetro correspondiente de `method`, posiblemente después *entrecomillar*.</span><span class="sxs-lookup"><span data-stu-id="60e59-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-665">Un elemento se entrecomillará sólo si el parámetro correspondiente del método es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-666">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-667">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="60e59-668">El <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> está vacío si `arguments` es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="60e59-669">De lo contrario, contiene los mismos elementos que `arguments`, algunos de los cuales pueden ir entre comillas.</span><span class="sxs-lookup"><span data-stu-id="60e59-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="60e59-670">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> es igual que el tipo de valor devuelto del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-671"><paramref name="method" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-671"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-672">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-672">-or-</span></span>  
  
 <span data-ttu-id="60e59-673"><paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-673"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-674"><paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-674"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-675">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-675">-or-</span></span>  
  
 <span data-ttu-id="60e59-676">El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-677">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-677">-or-</span></span>  
  
 <span data-ttu-id="60e59-678">Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-679">
          <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa <see langword="null" /> para un método <see langword="static" />, <see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-680">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-681">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-682">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-683"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-684">Para representar una llamada a un `static` (`Shared` en Visual Basic) método, pase `null` para el `instance` parámetro cuando se llama a este método, o llamar a <xref:System.Linq.Expressions.Expression.Call%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60e59-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="60e59-685">Si `method` representa un método de instancia, el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `instance` debe ser asignable al tipo declarativo del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="60e59-686">Si `arguments` no `null`, debe tener el mismo número de elementos que el número de parámetros para el método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="60e59-687">Cada elemento de `arguments` no debe ser `null` y se debe poder asignar al parámetro correspondiente de `method`, posiblemente después *entrecomillar*.</span><span class="sxs-lookup"><span data-stu-id="60e59-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-688">Un elemento se entrecomillará sólo si el parámetro correspondiente del método es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-689">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-690">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="60e59-691">El <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> está vacío si `arguments` es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="60e59-692">De lo contrario, contiene los mismos elementos que `arguments`, algunos de los cuales pueden ir entre comillas.</span><span class="sxs-lookup"><span data-stu-id="60e59-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="60e59-693">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> es igual que el tipo de valor devuelto del método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="60e59-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-694"><paramref name="method" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-694"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-695">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-695">-or-</span></span>  
  
 <span data-ttu-id="60e59-696"><paramref name="instance" /> es <see langword="null" /> y <paramref name="method" /> representa un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-696"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span>  
  
 <span data-ttu-id="60e59-697">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-697">-or-</span></span>  
  
 <span data-ttu-id="60e59-698"><paramref name="arguments" /> no es <see langword="null" /> y uno o varios de sus elementos son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-698"><paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-699"><paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-699"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-700">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-700">-or-</span></span>  
  
 <span data-ttu-id="60e59-701">El número de elementos de <paramref name="arguments" /> no es igual al número de parámetros del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-702">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-702">-or-</span></span>  
  
 <span data-ttu-id="60e59-703">Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-704">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-705"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-706"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="60e59-707">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-708"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-709"><paramref name="method" /> es null.</span><span class="sxs-lookup"><span data-stu-id="60e59-709"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-710"><see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="60e59-711">(Pasa null para un método estático, que en Visual Basic es compartido).</span><span class="sxs-lookup"><span data-stu-id="60e59-711">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-712"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</span><span class="sxs-lookup"><span data-stu-id="60e59-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-713"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-714"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="60e59-715">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-716"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-717">En el ejemplo de código siguiente se muestra cómo crear una expresión que llama a un método de instancia que tiene dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-718"><see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</span><span class="sxs-lookup"><span data-stu-id="60e59-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span></span></param>
        <param name="methodName"><span data-ttu-id="60e59-719">Nombre del método.</span><span class="sxs-lookup"><span data-stu-id="60e59-719">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="60e59-720">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.</span><span class="sxs-lookup"><span data-stu-id="60e59-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="60e59-721">Este argumento debería ser null cuando methodName especifica un método no genérico.</span><span class="sxs-lookup"><span data-stu-id="60e59-721">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-722">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</span><span class="sxs-lookup"><span data-stu-id="60e59-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="60e59-723">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-724"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado, y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-725">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> es igual que el tipo de valor devuelto del método denotado por `methodName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-726">El valor de <paramref name="instance" /> o <paramref name="methodName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-726"><paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-727">No se encuentra en <paramref name="instance" />.Type o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span>  
  
 <span data-ttu-id="60e59-728">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-728">-or-</span></span>  
  
 <span data-ttu-id="60e59-729">Se han encontrado en <paramref name="instance" />.Type o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-730">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-731"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-732"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-733"><see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="60e59-734">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-735"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-736"><paramref name="method" /> es null.</span><span class="sxs-lookup"><span data-stu-id="60e59-736"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-737"><see cref="T:System.Type" /> que especifica el tipo que contiene el método <see langword="static" /> adecuado (<see langword="Shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span></span></param>
        <param name="methodName"><span data-ttu-id="60e59-738">Nombre del método.</span><span class="sxs-lookup"><span data-stu-id="60e59-738">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="60e59-739">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.</span><span class="sxs-lookup"><span data-stu-id="60e59-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="60e59-740">Este argumento debería ser null cuando methodName especifica un método no genérico.</span><span class="sxs-lookup"><span data-stu-id="60e59-740">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-741">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</span><span class="sxs-lookup"><span data-stu-id="60e59-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="60e59-742">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-743"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método <see langword="static" /> (<see langword="Shared" /> en Visual Basic) especificado, y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-744">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MethodCallExpression> es igual que el tipo de valor devuelto del método denotado por `methodName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="60e59-745">La propiedad <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-746">El valor de <paramref name="type" /> o <paramref name="methodName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-746"><paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-747">No se encuentra en <paramref name="type" /> o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span>  
  
 <span data-ttu-id="60e59-748">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-748">-or-</span></span>  
  
 <span data-ttu-id="60e59-749">Se han encontrado en <paramref name="type" /> o sus tipos base varios métodos cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-750"><see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="60e59-751">(Pasa null para un método estático, que en Visual Basic es compartido).</span><span class="sxs-lookup"><span data-stu-id="60e59-751">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-752"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</span><span class="sxs-lookup"><span data-stu-id="60e59-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-753"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-754"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-755"><see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="60e59-756">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-757"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-758">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-759"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-760"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-761"><see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-762"><see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <summary><span data-ttu-id="60e59-763">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-764"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-765"><paramref name="method" /> es null.</span><span class="sxs-lookup"><span data-stu-id="60e59-765"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="60e59-766">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-767"><see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-768"><see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-769"><see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-770"><see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <param name="arg4"><span data-ttu-id="60e59-771"><see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span></span></param>
        <summary><span data-ttu-id="60e59-772">Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-773"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-774"><paramref name="method" /> es null.</span><span class="sxs-lookup"><span data-stu-id="60e59-774"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60e59-775">Indica que el nodo se puede reducir a uno más simple.</span><span class="sxs-lookup"><span data-stu-id="60e59-775">Indicates that the node can be reduced to a simpler node.</span></span> <span data-ttu-id="60e59-776">Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</span><span class="sxs-lookup"><span data-stu-id="60e59-776">If this returns true, Reduce() can be called to produce the reduced form.</span></span></summary>
        <value><span data-ttu-id="60e59-777">Es true si se puede reducir el nodo; de lo contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-777">True if the node can be reduced, otherwise false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-778">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="60e59-779"><see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</span><span class="sxs-lookup"><span data-stu-id="60e59-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-780">Cuerpo de la instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-780">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="60e59-781">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</span><span class="sxs-lookup"><span data-stu-id="60e59-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span></span></summary>
        <returns><span data-ttu-id="60e59-782">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-783">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</span><span class="sxs-lookup"><span data-stu-id="60e59-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-784">Cuerpo de la instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-784">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="60e59-785">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-786">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-787">El <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> capturar puede especificarse pero ninguna referencia a la <xref:System.Exception> objeto estará disponible para su uso en el <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="60e59-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="60e59-788"><see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</span><span class="sxs-lookup"><span data-stu-id="60e59-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-789">Cuerpo de la instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-789">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="60e59-790">Cuerpo del filtro <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-790">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="60e59-791">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</span><span class="sxs-lookup"><span data-stu-id="60e59-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="60e59-792">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-793">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</span><span class="sxs-lookup"><span data-stu-id="60e59-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-794">Cuerpo de la instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-794">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="60e59-795">Cuerpo del filtro <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-795">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="60e59-796">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</span><span class="sxs-lookup"><span data-stu-id="60e59-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="60e59-797">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="60e59-798"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="60e59-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <summary><span data-ttu-id="60e59-799">Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></summary>
        <returns><span data-ttu-id="60e59-800">Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-801">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado.</span><span class="sxs-lookup"><span data-stu-id="60e59-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-802">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-803">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-804">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado.</span><span class="sxs-lookup"><span data-stu-id="60e59-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-805"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-806">El <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.BinaryExpression> es `null` y <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> se establecen en `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="60e59-807">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad es igual al tipo de resultado de la operación de fusión.</span><span class="sxs-lookup"><span data-stu-id="60e59-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="60e59-808">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="60e59-809">Tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="60e59-809">Result Type</span></span>  
 <span data-ttu-id="60e59-810">Las siguientes reglas determinan el tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="60e59-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="60e59-811">If `left`. Tipo representa un tipo que acepta valores NULL y `right`. El tipo es implícitamente convertible al tipo correspondiente no acepta valores NULL, el tipo de resultado es el equivalente que no acepta valores NULL de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="60e59-812">De lo contrario, si `right`. El tipo es implícitamente convertible a `left`. Tipo: el tipo de resultado es `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="60e59-813">De lo contrario, si el equivalente que no acepta valores NULL de `left`. El tipo es implícitamente convertible a `right`. Tipo: el tipo de resultado es `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-814">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-814"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-815">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.</span><span class="sxs-lookup"><span data-stu-id="60e59-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-816"><paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.</span><span class="sxs-lookup"><span data-stu-id="60e59-816"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-817">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-817">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-818">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-818">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-819">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-819">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-820">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</span><span class="sxs-lookup"><span data-stu-id="60e59-820">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span></span></summary>
        <returns><span data-ttu-id="60e59-821"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-821">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-822">El <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.BinaryExpression> es `null` y <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> se establecen en `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-822">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="60e59-823">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.BinaryExpression> es igual al tipo de resultado de la operación de fusión.</span><span class="sxs-lookup"><span data-stu-id="60e59-823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="60e59-824">Las siguientes reglas determinan el tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="60e59-824">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="60e59-825">If `left`. Tipo representa un tipo que acepta valores NULL y `right`. El tipo es implícitamente convertible al tipo correspondiente no acepta valores NULL, el tipo de resultado es el equivalente que no acepta valores NULL de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-825">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="60e59-826">De lo contrario, si `right`. El tipo es implícitamente convertible a `left`. Tipo: el tipo de resultado es `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-826">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="60e59-827">De lo contrario, si el equivalente que no acepta valores NULL de `left`. El tipo es implícitamente convertible a `right`. Tipo: el tipo de resultado es `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-827">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-828">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-828"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-829"><paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.</span><span class="sxs-lookup"><span data-stu-id="60e59-829"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span>  
  
 <span data-ttu-id="60e59-830">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-830">-or-</span></span>  
  
 <span data-ttu-id="60e59-831"><paramref name="conversion" /> no es <see langword="null" /> y <paramref name="conversion" />.Type es un tipo de delegado que no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-831"><paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-832">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores null.</span><span class="sxs-lookup"><span data-stu-id="60e59-832">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-833">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-833">-or-</span></span>  
  
 <span data-ttu-id="60e59-834">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo de delegado <paramref name="conversion" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-835">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-835">-or-</span></span>  
  
 <span data-ttu-id="60e59-836">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo de delegado <paramref name="conversion" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-837">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-837">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="60e59-838">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-838">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="60e59-839">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-839">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="60e59-840">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-841">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-841">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-842"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-842">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-843">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ConditionalExpression> es igual a la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="60e59-843">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-844">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa una instrucción condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-844">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="60e59-845">Si el primer argumento se evalúa como `true`, el segundo argumento es ejecutar; de lo contrario, se ejecuta el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-845">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-846"><paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-846"><paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-847"><paramref name="test" />.Type no es <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-847"><paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="60e59-848">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-848">-or-</span></span>  
  
 <span data-ttu-id="60e59-849"><paramref name="ifTrue" />.Type no es igual que <paramref name="ifFalse" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-849"><paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span></span></exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="60e59-850">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="60e59-851">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-851">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="60e59-852">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-853">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-853">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-854">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-854">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-855"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-855">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-856">Este método permite unificar explícitamente el tipo de resultado de la expresión condicional en casos donde los tipos de `ifTrue` y `ifFalse` expresiones no son iguales.</span><span class="sxs-lookup"><span data-stu-id="60e59-856">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="60e59-857">Tipos de ambos `ifTrue` y `ifFalse` debe ser implícitamente referencia asignable al tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="60e59-857">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="60e59-858">El `type` puede ser <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="60e59-858">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-859">Crea una interfaz <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-859">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60e59-860">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-860">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-861">Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></summary>
        <returns><span data-ttu-id="60e59-862"><see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-862">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-863">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ConstantExpression> es igual que el tipo de `value`.</span><span class="sxs-lookup"><span data-stu-id="60e59-863">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="60e59-864">Si `value` es `null`, <xref:System.Linq.Expressions.Expression.Type%2A> es igual a <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="60e59-864">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="60e59-865">Para representar `null`, también puede usar el <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> método, con el que puede especificar explícitamente el tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-865">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-866">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa un valor constante.</span><span class="sxs-lookup"><span data-stu-id="60e59-866">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60e59-867">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-867">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-868">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-868">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-869">Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-869">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></summary>
        <returns><span data-ttu-id="60e59-870"><see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-870">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-871">Este método puede ser útil para representar valores de tipos que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-871">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-872">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa una constante del tipo que acepta valores NULL y establezca su valor en `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-872">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-873"><paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-873"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-874"><paramref name="value" /> no es <see langword="null" /> y <paramref name="type" /> no se puede asignar a partir del tipo dinámico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-874"><paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-875">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</span><span class="sxs-lookup"><span data-stu-id="60e59-875">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-876">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-876">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="60e59-877">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</span><span class="sxs-lookup"><span data-stu-id="60e59-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-878"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-878">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-879">En el ejemplo siguiente se muestra cómo crear una expresión de bucle que usa el <xref:System.Linq.Expressions.Expression.Continue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60e59-879">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-880">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-880">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-881">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-881">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-882">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-882">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-883"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-883">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-884">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="60e59-884">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-885">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-885">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-886">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-886">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-887">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="60e59-887">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-888"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-888">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-889">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-889">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-890">La propiedad <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-890">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="60e59-891">Si se eleva el nodo, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-891">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="60e59-892">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-892">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-893">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-893">Implementing Method</span></span>  
 <span data-ttu-id="60e59-894">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-894">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-895">Si el valor `expression`. Tipo o `type` es un tipo definido por el usuario que se define un operador de conversión implícita o explícita, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-895">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-896">De lo contrario:</span><span class="sxs-lookup"><span data-stu-id="60e59-896">Otherwise:</span></span>  
  
    -   <span data-ttu-id="60e59-897">Si ambos `expression`. Tipo y `type` representan tipos numéricos o booleanos, o tipos de enumeración que aceptan valores NULL o que no aceptan valores NULL, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-897">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="60e59-898">Si el valor `expression`. Tipo o `type` es un tipo de referencia y una conversión boxing explícita, unboxing o no existe una conversión de referencia de `expression`. Escriba a `type`, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-898">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="60e59-899">Elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-899">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-900">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-900">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-901">If `expression`. El tipo es asignable al tipo de argumento del método de implementación y el tipo de valor devuelto del método de implementación se puede asignar a `type`, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-901">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-902">Si uno o ambos de `expression`. Tipo o `type` es un tipo de valor que aceptan valores NULL y los correspondientes tipos de valor que no aceptan valores NULL son iguales que el tipo de argumento y el tipo de valor devuelto del método de implementación respectivamente, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-902">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="60e59-903">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-903">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-904">Si ambos `expression`. Tipo y `type` son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-904">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-905">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-905">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-906">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa una operación de conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="60e59-906">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-907">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-907"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-908">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-908">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-909">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-909">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-910">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-910">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-911">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-911">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-912">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión para la que se especifica el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-912">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-913"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-913">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-914">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-914">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-915">La propiedad <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-915">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="60e59-916">Si se eleva el nodo, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-916">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="60e59-917">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-917">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-918">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-918">Implementing Method</span></span>  
 <span data-ttu-id="60e59-919">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-919">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-920">Si el método no es `null`, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-920">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="60e59-921">Debe representar un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-921">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="60e59-922">En caso contrario, si el valor `expression`. Tipo o `type` es un tipo definido por el usuario que se define un operador de conversión implícita o explícita, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-922">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-923">De lo contrario:</span><span class="sxs-lookup"><span data-stu-id="60e59-923">Otherwise:</span></span>  
  
    -   <span data-ttu-id="60e59-924">Si ambos `expression`. Tipo y `type` representan tipos numéricos o booleanos, o tipos de enumeración que aceptan valores NULL o que no aceptan valores NULL, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-924">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="60e59-925">Si el valor `expression`. Tipo o `type` es un tipo de referencia y una conversión boxing explícita, unboxing o no existe una conversión de referencia de `expression`. Escriba a `type`, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-925">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="60e59-926">Elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-926">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-927">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-927">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-928">If `expression`. El tipo es asignable al tipo de argumento del método de implementación y el tipo de valor devuelto del método de implementación se puede asignar a `type`, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-928">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-929">Si uno o ambos de `expression`. Tipo o `type` son un tipo de valor que aceptan valores NULL y los correspondientes tipos de valor que no aceptan valores NULL son iguales que el tipo de argumento y el tipo de valor devuelto del método de implementación respectivamente, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-929">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="60e59-930">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-930">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-931">Si ambos `expression`. Tipo y `type` son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-931">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-932">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-932">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-933">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-933"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-934"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-934"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-935">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-935">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
 <span data-ttu-id="60e59-936">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-936">-or-</span></span>  
  
 <span data-ttu-id="60e59-937"><paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-937"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-938">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-938">-or-</span></span>  
  
 <span data-ttu-id="60e59-939">El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-939">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
 <span data-ttu-id="60e59-940">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-940">-or-</span></span>  
  
 <span data-ttu-id="60e59-941"><paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-941"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60e59-942">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-942">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-943">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="60e59-943">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-944">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-945">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-945">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-946">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="60e59-946">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
        <returns><span data-ttu-id="60e59-947"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-947">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-948">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-948">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-949">La propiedad <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-949">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="60e59-950">Si se eleva el nodo, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-950">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="60e59-951">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-951">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-952">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-952">Implementing Method</span></span>  
 <span data-ttu-id="60e59-953">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-953">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-954">Si el valor `expression`. Tipo o `type` es un tipo definido por el usuario que se define un operador de conversión implícita o explícita, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-954">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-955">De lo contrario:</span><span class="sxs-lookup"><span data-stu-id="60e59-955">Otherwise:</span></span>  
  
    -   <span data-ttu-id="60e59-956">Si ambos `expression`. Tipo y `type` representan tipos numéricos o booleanos, o tipos de enumeración que aceptan valores NULL o que no aceptan valores NULL, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-956">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="60e59-957">Si el valor `expression`. Tipo o `type` es un tipo de referencia y una conversión boxing explícita, unboxing o no existe una conversión de referencia de `expression`. Escriba a `type`, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-957">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="60e59-958">Elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-958">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-959">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-960">If `expression`. El tipo es asignable al tipo de argumento del método de implementación y el tipo de valor devuelto del método de implementación se puede asignar a `type`, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-960">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-961">Si uno o ambos de `expression`. Tipo o `type` son un tipo de valor que aceptan valores NULL y los correspondientes tipos de valor que no aceptan valores NULL son iguales que el tipo de argumento y el tipo de valor devuelto del método de implementación respectivamente, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-961">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="60e59-962">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-962">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-963">Si ambos `expression`. Tipo y `type` son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-963">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-964">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-964">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-965">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-965"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-966">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-966">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-967">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-967">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-968">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-968">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-969">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-969">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-970">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado y para la que se especifica el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-970">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-971"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-971">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-972">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-972">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-973">La propiedad <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-973">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="60e59-974">Si se eleva el nodo, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-974">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="60e59-975">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-975">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-976">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-976">Implementing Method</span></span>  
 <span data-ttu-id="60e59-977">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-977">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-978">Si el método no es `null`, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-978">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="60e59-979">Debe representar un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-979">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="60e59-980">En caso contrario, si el valor `expression`. Tipo o `type` es un tipo definido por el usuario que se define un operador de conversión implícita o explícita, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-980">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-981">De lo contrario:</span><span class="sxs-lookup"><span data-stu-id="60e59-981">Otherwise:</span></span>  
  
    -   <span data-ttu-id="60e59-982">Si ambos `expression`. Tipo y `type` representan tipos numéricos o booleanos, o tipos de enumeración que aceptan valores NULL o que no aceptan valores NULL, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-982">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="60e59-983">Si el valor `expression`. Tipo o `type` es un tipo de referencia y una conversión boxing explícita, unboxing o no existe una conversión de referencia de `expression`. Escriba a `type`, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-983">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="60e59-984">Elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-984">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-985">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-985">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-986">If `expression`. El tipo es asignable al tipo de argumento del método de implementación y el tipo de valor devuelto del método de implementación se puede asignar a `type`, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-986">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-987">Si uno o ambos de `expression`. Tipo o `type` son un tipo de valor que aceptan valores NULL y los correspondientes tipos de valor que no aceptan valores NULL son iguales que el tipo de argumento y el tipo de valor devuelto del método de implementación respectivamente, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-987">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="60e59-988">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-988">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-989">Si ambos `expression`. Tipo y `type` son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-989">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="60e59-990">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-990">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-991">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-991"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-992"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-992"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-993">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-993">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
 <span data-ttu-id="60e59-994">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-994">-or-</span></span>  
  
 <span data-ttu-id="60e59-995"><paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-995"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
 <span data-ttu-id="60e59-996">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-996">-or-</span></span>  
  
 <span data-ttu-id="60e59-997">El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-997">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
 <span data-ttu-id="60e59-998">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-998">-or-</span></span>  
  
 <span data-ttu-id="60e59-999"><paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores null y el correspondiente tipo de valor que no acepta valores null no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-999"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60e59-1000">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1000">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="60e59-1001"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="60e59-1001">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <param name="startLine"><span data-ttu-id="60e59-1002">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1002">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="60e59-1003">Debe ser mayor que 0.</span><span class="sxs-lookup"><span data-stu-id="60e59-1003">Must be greater than 0.</span></span></param>
        <param name="startColumn"><span data-ttu-id="60e59-1004">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1004">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="60e59-1005">Debe ser mayor que 0.</span><span class="sxs-lookup"><span data-stu-id="60e59-1005">Must be greater than 0.</span></span></param>
        <param name="endLine"><span data-ttu-id="60e59-1006">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1006">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="60e59-1007">Debe ser mayor o igual que la línea de inicio.</span><span class="sxs-lookup"><span data-stu-id="60e59-1007">Must be greater or equal than the start line.</span></span></param>
        <param name="endColumn"><span data-ttu-id="60e59-1008">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1008">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="60e59-1009">Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.</span><span class="sxs-lookup"><span data-stu-id="60e59-1009">If the end line is the same as the start line, it must be greater or equal than the start column.</span></span> <span data-ttu-id="60e59-1010">En cualquier caso, debe ser mayor que 0.</span><span class="sxs-lookup"><span data-stu-id="60e59-1010">In any case, must be greater than 0.</span></span></param>
        <summary><span data-ttu-id="60e59-1011">Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1011">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span></span></summary>
        <returns><span data-ttu-id="60e59-1012">Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1012">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1013">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1013">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1014"><see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</span><span class="sxs-lookup"><span data-stu-id="60e59-1014">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <summary><span data-ttu-id="60e59-1015">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="60e59-1016"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</span><span class="sxs-lookup"><span data-stu-id="60e59-1016">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1017">Esta expresión es funcional y no cambia el valor del objeto pasado a él.</span><span class="sxs-lookup"><span data-stu-id="60e59-1017">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1018">En el ejemplo de código siguiente se muestra cómo crear una expresión que substracts 1 de un valor determinado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1018">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1019"><see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</span><span class="sxs-lookup"><span data-stu-id="60e59-1019">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1020"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1020">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-1021">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1021">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="60e59-1022"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</span><span class="sxs-lookup"><span data-stu-id="60e59-1022">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1023">Esta expresión es funcional y no cambia el valor del objeto pasado a él.</span><span class="sxs-lookup"><span data-stu-id="60e59-1023">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-1024">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1024">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1025">Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1025">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1026"><see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1026">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1027">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa un valor predeterminado para un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1027">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1028">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-1028">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1029">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1029">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1030">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1030">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span></span></param>
        <summary><span data-ttu-id="60e59-1031">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-1031">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1032"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1032">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1033">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1033">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1034">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1034">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1035">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1035">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1036">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1036">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1037">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1037">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1038">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1038">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1039">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1039">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1040">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1040">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1041">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de división, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1041">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1042">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1042">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1043">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1043">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1044">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1044">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1045">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1045">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1046">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1046">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1047">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1047">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1048">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1048">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1049">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1049">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1050">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1050">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1051">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1051">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1052">El tipo del nodo es el tipo de resultado del operador de división predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1052">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="60e59-1053">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1053">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1054">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de división predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1054">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1055">En el ejemplo de código siguiente se muestra cómo crear una expresión que divide su primer argumento por su segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1055">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1056">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1056"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1057">No hay ningún operador de división definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1057">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1058">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1058">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1059">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1059">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1060">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1060">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1061">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-1061">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span> <span data-ttu-id="60e59-1062">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1062">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1063"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1063">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1064">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1064">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1065">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1065">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1066">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1066">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1067">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1067">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1068">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1068">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1069">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1069">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1070">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1070">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1071">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1071">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1072">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1072">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-1073">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de división, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1073">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1074">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1074">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1075">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1075">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1076">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1076">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1077">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1077">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1078">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1078">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1079">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1079">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1080">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1080">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1081">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1081">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1082">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1082">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1083">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1083">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1084">El tipo del nodo es el tipo de resultado del operador de división predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1084">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="60e59-1085">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1085">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1086">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de división predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1086">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1087">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1087"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1088"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1088"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1089"><paramref name="method" /> es <see langword="null" /> y el operador de división no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1089"><paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1090">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1090">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1091">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1091">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1092">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1092">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1093">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1093">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-1094"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1094">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1095">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1095">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1096">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1096">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1097">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1097">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1098">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1098">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-1099"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1099">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1100">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1100">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1101">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1101">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1102">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1102">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-1103">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1103">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1104">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1104">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-1105"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1105">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1106">Crea una clase <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1106">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1107">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1107">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1108">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1108">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1109">Argumentos de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1109">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1110">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1110">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1111"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1111">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1112">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1112">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1113">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1113">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1114">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1114">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-1115">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1115">The first argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1116">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1116">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1117"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1117">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1118">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1118">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1119">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1119">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1120">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1120">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1121">Argumentos de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1121">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1122">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1122">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1123"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1123">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1124">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1124">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1125">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1125">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1126">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1126">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-1127">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1127">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-1128">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1128">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1129">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1129">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1130"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1130">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1131">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1131">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1132">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1132">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1133">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1133">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-1134">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1134">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-1135">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1135">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-1136">Tercer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1136">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1137">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1137">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1138"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1138">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1139">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1139">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="60e59-1140">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1140">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="60e59-1141">Tipo de resultado de la expresión dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1141">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-1142">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1142">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-1143">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1143">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-1144">Tercer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1144">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-1145">Cuarto argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1145">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-1146">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1146">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-1147"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1147">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1148">El <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propiedad del resultado se deducirán de los tipos de los argumentos y el tipo devuelto especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1148">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1149">Crea una interfaz <see cref="T:System.Linq.Expressions.ElementInit" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1149">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="60e59-1150">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1150">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1151"><see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1151">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1152">Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1152">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span></span></summary>
        <returns><span data-ttu-id="60e59-1153"><see cref="T:System.Linq.Expressions.ElementInit" /> cuyas propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1153">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1154">El `addMethod` parámetro debe representar un método de instancia llamado "Add" (con distinción entre mayúsculas y minúsculas).</span><span class="sxs-lookup"><span data-stu-id="60e59-1154">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="60e59-1155">El método add debe tener el mismo número de parámetros que el número de elementos de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1155">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="60e59-1156">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `arguments` debe ser asignable al tipo del parámetro correspondiente del método add, posiblemente después *entrecomillar*.</span><span class="sxs-lookup"><span data-stu-id="60e59-1156">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-1157">Un elemento se entrecomillará sólo si el parámetro correspondiente del método es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1157">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-1158">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1158">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-1159">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1159">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1160">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.ElementInit> que representa la llamada la <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar un elemento de una colección de diccionarios.</span><span class="sxs-lookup"><span data-stu-id="60e59-1160">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1161">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1161"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-1162">El método que <paramref name="addMethod" /> representa no se denomina "Add" (no distingue mayúsculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="60e59-1162">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span></span>  
  
 <span data-ttu-id="60e59-1163">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1163">-or-</span></span>  
  
 <span data-ttu-id="60e59-1164">El método que <paramref name="addMethod" /> representa no es un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-1164">The method that <paramref name="addMethod" /> represents is not an instance method.</span></span>  
  
 <span data-ttu-id="60e59-1165">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1165">-or-</span></span>  
  
 <span data-ttu-id="60e59-1166"><paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-1166"><paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-1167">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1167">-or-</span></span>  
  
 <span data-ttu-id="60e59-1168">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-1168">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="60e59-1169">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1169">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1170">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1170">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1171">Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1171">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span></span></summary>
        <returns><span data-ttu-id="60e59-1172"><see cref="T:System.Linq.Expressions.ElementInit" /> cuyas propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1172">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1173">El `addMethod` parámetro debe representar un método de instancia llamado "Add" (con distinción entre mayúsculas y minúsculas).</span><span class="sxs-lookup"><span data-stu-id="60e59-1173">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="60e59-1174">El método add debe tener el mismo número de parámetros que el número de elementos de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1174">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="60e59-1175">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `arguments` debe ser asignable al tipo del parámetro correspondiente del método add, posiblemente después *entrecomillar*.</span><span class="sxs-lookup"><span data-stu-id="60e59-1175">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-1176">Un elemento se entrecomillará sólo si el parámetro correspondiente del método es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1176">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-1177">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1177">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-1178">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1178">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1179">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.ElementInit> que representa la llamada la <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar un elemento de una colección de diccionarios.</span><span class="sxs-lookup"><span data-stu-id="60e59-1179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1180">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1180"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-1181">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).</span><span class="sxs-lookup"><span data-stu-id="60e59-1181">The method that addMethod represents is not named "Add" (case insensitive).</span></span>  
  
 <span data-ttu-id="60e59-1182">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1182">-or-</span></span>  
  
 <span data-ttu-id="60e59-1183">El método que addMethod representa no es un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="60e59-1183">The method that addMethod represents is not an instance method.</span></span>  
  
 <span data-ttu-id="60e59-1184">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1184">-or-</span></span>  
  
 <span data-ttu-id="60e59-1185">El parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-1185">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span></span>  
  
 <span data-ttu-id="60e59-1186">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1186">-or-</span></span>  
  
 <span data-ttu-id="60e59-1187">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-1187">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-1188">Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1188">Creates an empty expression that has <see cref="T:System.Void" /> type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1189"><see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1189">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1190">Puede usarse una expresión vacía donde se espera una expresión pero no se desea ninguna acción.</span><span class="sxs-lookup"><span data-stu-id="60e59-1190">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="60e59-1191">Por ejemplo, puede utilizar una expresión vacía como la última expresión en una expresión de bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-1191">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="60e59-1192">En este caso, el valor devuelto de la expresión de bloque es void.</span><span class="sxs-lookup"><span data-stu-id="60e59-1192">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1193">En el ejemplo de código siguiente se muestra cómo crear una expresión vacía y agregarla a una expresión de bloque.</span><span class="sxs-lookup"><span data-stu-id="60e59-1193">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1194">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-1194">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1195">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1195">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1196">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1196">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1197">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-1197">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1198"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1198">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1199">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1199">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1200">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1200">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1201">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1201">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-1202">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1202">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-1203">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1203">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-1204">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1204">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1205">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1205">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1206">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1206">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1207">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de igualdad, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1207">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1208">De lo contrario, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1208">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1209">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1209">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1210">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1210">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1211">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1211">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1212">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1212">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1213">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-1213">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-1214">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1214">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1215">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1215">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1216">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1216">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1217">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1217">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1218">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1218">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1219">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1219">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1220">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1221">En el ejemplo de código siguiente se muestra cómo crear una expresión que comprueba si los valores de sus dos argumentos son iguales.</span><span class="sxs-lookup"><span data-stu-id="60e59-1221">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1222">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1222"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1223">No hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1223">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1224">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1224">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1225">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1225">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-1226">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1226"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1227">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1227">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1228">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-1228">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span> <span data-ttu-id="60e59-1229">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1229">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1230"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1230">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1231">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1231">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1232">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1232">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1233">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1233">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-1234">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1234">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-1235">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1235">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1236">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1236">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1237">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1237">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1238">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1238">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1239">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de igualdad, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1239">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1240">De lo contrario, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1240">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1241">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1241">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1242">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1242">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1243">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1243">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1244">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1244">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1245">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1245">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-1246">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1246">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1247">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1247">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1248">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1248">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1249">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1249">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1250">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1250">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1251">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1251">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1252">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1252">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1253">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1253"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1254"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1254"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1255"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1255"><paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1256">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1256">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1257">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1257">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1258">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1258">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1259">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="60e59-1259">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="60e59-1260"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1260">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1261">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1261">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1262">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1262">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1263">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1263">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1264">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1264">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1265">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1265">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1266">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1266">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1267">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1267">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1268">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1268">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1269">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el `XOR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1269">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1270">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1270">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1271">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1271">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1272">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1272">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1273">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1273">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1274">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1274">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1275">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1275">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1276">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1276">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1277">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1277">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1278">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1278">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1279">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1279">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1280">El tipo del nodo es el tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-1280">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-1281">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1281">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1282">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-1282">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1283">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa la operación XOR lógica.</span><span class="sxs-lookup"><span data-stu-id="60e59-1283">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1284">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1284"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1285">No hay ningún operador <see langword="XOR" /> definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1285">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1286">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1286">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1287">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1287">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1288">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1288">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1289">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="60e59-1289">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span> <span data-ttu-id="60e59-1290">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1290">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1291"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1291">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1292">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1292">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1293">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1293">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1294">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1294">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1295">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1295">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1296">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1296">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1297">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1297">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1298">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1298">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1299">Las siguientes reglas determinan el método para la operación de implementación elegido:</span><span class="sxs-lookup"><span data-stu-id="60e59-1299">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1300">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1300">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1301">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el `XOR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1301">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1302">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1302">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1303">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1303">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1304">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1304">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1305">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1305">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1306">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1306">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1307">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1307">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1308">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1308">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1309">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1309">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1310">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1310">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1311">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1311">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1312">El tipo del nodo es el tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-1312">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-1313">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1313">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1314">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-1314">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1315">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1315"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1316"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1316"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1317"><paramref name="method" /> es <see langword="null" /> y el operador <see langword="XOR" /> no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1317"><paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1318">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1318">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1319">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1319">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1320">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1320">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1321">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="60e59-1321">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="60e59-1322"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1322">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1323">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1323">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1324">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1324">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1325">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1325">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1326">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="60e59-1326">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="60e59-1327"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1327">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1328">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1329">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1330">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1330">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-1331">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1331">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1332">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando <c>op_ExclusiveOr</c> para los tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="60e59-1332">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="60e59-1333"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1333">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1334">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1334">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1335">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1335">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="60e59-1336">Para <see langword="static" /> (<see langword="Shared" /> en Visual Basic), el parámetro <c>expression</c> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1336">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <c>expression</c> must be <see langword="null" />.</span></span></param>
        <param name="field"><span data-ttu-id="60e59-1337">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1337">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1338">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1338">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="60e59-1339"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1339">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1340">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.FieldInfo.FieldType%2A> propiedad de `field`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1340">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1341"><paramref name="field" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1341"><paramref name="field" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1342">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1342">-or-</span></span>  
  
 <span data-ttu-id="60e59-1343">El campo representado por <paramref name="field" /> no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y <paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1343">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1344"><paramref name="expression" />.Type no se puede asignar al tipo declarativo del campo representado por <paramref name="field" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1344"><paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1345"><see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <c>fieldName</c>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1345">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <c>fieldName</c>.</span></span> <span data-ttu-id="60e59-1346">Este puede ser null para los campos estáticos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1346">This can be null for static fields.</span></span></param>
        <param name="fieldName"><span data-ttu-id="60e59-1347">Nombre de un campo al que se va a obtener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-1347">The name of a field to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-1348">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo dado el nombre del campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1348">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span></span></summary>
        <returns><span data-ttu-id="60e59-1349"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1349">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1350">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.FieldInfo.FieldType%2A> propiedad de la <xref:System.Reflection.FieldInfo> que representa el campo denotado por `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1350">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="60e59-1351">Este método busca `expression`. Tipo y sus tipos base para un campo que tiene el nombre `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1351">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="60e59-1352">Campos públicos tienen preferencia sobre los campos no públicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1352">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="60e59-1353">Si se encuentra un campo coincidente, este método pasa `expression` y <xref:System.Reflection.FieldInfo> que representa que el campo <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1353">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1354">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa el acceso a un campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1354">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1355">El valor de <paramref name="expression" /> o <paramref name="fieldName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1355"><paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-1356">No se ha definido ningún campo denominado <paramref name="fieldName" /> en <paramref name="expression" />.Type o sus tipos base.</span><span class="sxs-lookup"><span data-stu-id="60e59-1356">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1357">Objeto contenedor del campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1357">The containing object of the field.</span></span> <span data-ttu-id="60e59-1358">Este puede ser null para los campos estáticos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1358">This can be null for static fields.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-1359"><see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1359">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span></span></param>
        <param name="fieldName"><span data-ttu-id="60e59-1360">Campo al que se va a obtener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-1360">The field to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-1361">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1361">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="60e59-1362">Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1362">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="60e59-1363">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Action" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1363">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="60e59-1364">Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado <c>System.Action</c> genérico que tiene argumentos de tipo específicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1364">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-1365">Tipo de un delegado <c>System.Action</c> que tiene los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1365">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1366">Por ejemplo, si los elementos de `typeArgs` representan los tipos de `T1…Tn`, resultante <xref:System.Type> objeto representa el tipo de delegado construido `System.Action<T1,…,Tn>` en C# o `System.Action(Of T1,…,Tn)` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-1366">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1367"><paramref name="typeArgs" /> contiene más de dieciséis elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1367"><paramref name="typeArgs" /> contains more than sixteen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1368"><paramref name="typeArgs" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1368"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="60e59-1369">Argumentos de tipo del delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1369">The type arguments of the delegate.</span></span></param>
        <summary><span data-ttu-id="60e59-1370">Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> o <c>System.Action</c> genérico que tiene argumentos de tipo específicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1370">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-1371">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1371">The delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1372">El último argumento de tipo determina el tipo de valor devuelto del delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1372">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="60e59-1373">Si ninguna función o acción es lo suficientemente grande, generará un tipo de delegado personalizado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1373">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="60e59-1374">Al igual que con Func, el último argumento es el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1374">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="60e59-1375">Se puede establecer en System.Void para generar una acción.</span><span class="sxs-lookup"><span data-stu-id="60e59-1375">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="60e59-1376">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado <see langword="System.Func" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1376">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="60e59-1377">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado <c>System.Func</c> genérico que tiene argumentos de tipo específicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1377">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span></span> <span data-ttu-id="60e59-1378">El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1378">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="60e59-1379">Tipo de un delegado <c>System.Func</c> que tiene los argumentos de tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1379">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1380">`typeArgs` debe contener al menos uno y diecisiete a lo sumo elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1380">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="60e59-1381">Por ejemplo, si los elementos de `typeArgs` representan los tipos de `T1…Tn`, resultante <xref:System.Type> objeto representa el tipo de delegado construido `System.Func<T1,…,Tn>` en C# o `System.Func(Of T1,…,Tn)` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-1381">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1382"><paramref name="typeArgs" /> contiene menos de un elemento o más de diecisiete elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1382"><paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1383"><paramref name="typeArgs" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1383"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1384">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</span><span class="sxs-lookup"><span data-stu-id="60e59-1384">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1385">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1385">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="60e59-1386">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</span><span class="sxs-lookup"><span data-stu-id="60e59-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-1387"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1387">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1388">En el ejemplo siguiente se muestra cómo crear una expresión que contiene un <xref:System.Linq.Expressions.GotoExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1388">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1389">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1389">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-1390">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1390">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="60e59-1391">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</span><span class="sxs-lookup"><span data-stu-id="60e59-1391">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span> <span data-ttu-id="60e59-1392">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1392">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1393"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1393">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1394">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1394">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-1395">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1395">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1396">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1396">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1397"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1397">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1398">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1398">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-1399">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1399">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-1400">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1400">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1401">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1401">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span> <span data-ttu-id="60e59-1402">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1402">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1403"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1403">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1404">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1404">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1405">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1405">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1406">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1406">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1407">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1407">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1408"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1408">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1409">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1409">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1410">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1410">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1411">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1411">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-1412">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1412">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-1413">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1413">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-1414">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1414">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1415">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1415">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1416">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1416">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1417">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1417">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1418">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "mayor que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1418">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1419">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1419">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1420">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1420">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1421">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1421">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1422">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1422">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1423">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1423">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1424">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-1424">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-1425">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1425">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1426">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1426">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1427">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1427">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1428">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1428">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1429">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1429">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1430">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1430">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1431">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1432">En el ejemplo de código siguiente se muestra cómo crear una expresión que compara dos enteros.</span><span class="sxs-lookup"><span data-stu-id="60e59-1432">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1433">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1433"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1434">No hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1434">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1435">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1435">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1436">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-1437">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1437"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1438">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1438">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1439">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1439">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span> <span data-ttu-id="60e59-1440">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1440">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-1441"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1442">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1443">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1444">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-1445">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1445">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-1446">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1447">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1448">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1448">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1449">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1449">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="60e59-1450">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1450">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1451">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "mayor que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1451">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1452">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1452">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1453">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1453">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1454">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1454">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1455">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1455">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1456">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1456">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1457">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1457">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-1458">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1458">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1459">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1459">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1460">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1460">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1461">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1461">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1462">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1462">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1463">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1463">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1464">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1464">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1465">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1465"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1466"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1466"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1467"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1467"><paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1468">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1469">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1469">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1470">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1470">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1471">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1471">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1472"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1472">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1473">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1473">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1474">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1474">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1475">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1475">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-1476">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1476">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-1477">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1477">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-1478">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1478">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1479">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1479">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1480">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1480">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1481">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1481">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1482">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "mayor o igual que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1482">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1483">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1483">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1484">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1484">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1485">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1485">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1486">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1486">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1487">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1487">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1488">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-1488">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-1489">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1489">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1490">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1490">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1491">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1491">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1492">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1492">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1493">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1493">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1494">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1494">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1495">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1496">En el ejemplo de código siguiente se muestra cómo crear una expresión que compara dos enteros.</span><span class="sxs-lookup"><span data-stu-id="60e59-1496">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1497">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1497"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1498">No hay ningún operador "mayor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1498">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1499">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1500">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-1501">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1501"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1502">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1502">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1503">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1504"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1504">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1505">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1505">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1506">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1506">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1507">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1507">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-1508">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1508">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-1509">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1509">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1510">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1510">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1511">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1511">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1512">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1512">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1513">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1513">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1514">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "mayor o igual que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1514">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1515">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1515">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1516">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1516">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1517">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1517">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1518">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1518">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1519">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1519">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1520">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1520">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-1521">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1521">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1522">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1522">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1523">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1523">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1524">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1524">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1525">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1525">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1526">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1526">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1527">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1527">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1528">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1528"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1529"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1529"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1530"><paramref name="method" /> es <see langword="null" /> y el operador "mayor o igual que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1530"><paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="60e59-1531">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="60e59-1532">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1533">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción <see langword="if" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1533">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-1534"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1534">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span></span> <span data-ttu-id="60e59-1535">La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1535">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1536">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa un bloque condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-1536">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="60e59-1537">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1537">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="60e59-1538">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1538">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="60e59-1539">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1540">Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones <see langword="if" /> y <see langword="else" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1540">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span></span></summary>
        <returns><span data-ttu-id="60e59-1541"><see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1541">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span> <span data-ttu-id="60e59-1542">El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1542">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1543">En el ejemplo de código siguiente se muestra cómo crear una expresión que representa un bloque condicional.</span><span class="sxs-lookup"><span data-stu-id="60e59-1543">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1544">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1544">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1545"><see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1545">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <summary><span data-ttu-id="60e59-1546">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
        <returns><span data-ttu-id="60e59-1547"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1547">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1548">Esta expresión es funcional y no cambia el valor del objeto que se pasa a él.</span><span class="sxs-lookup"><span data-stu-id="60e59-1548">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1549">En el ejemplo de código siguiente se muestra cómo crear una expresión que represente una operación de incremento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1549">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1550"><see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1550">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1551"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1551">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-1552">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento de la expresión en 1.</span><span class="sxs-lookup"><span data-stu-id="60e59-1552">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="60e59-1553"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1553">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1554">Esta expresión es funcional y no cambia el valor del objeto que se pasa a él.</span><span class="sxs-lookup"><span data-stu-id="60e59-1554">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1555">Crea una interfaz <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1555">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1556"><see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</span><span class="sxs-lookup"><span data-stu-id="60e59-1556">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1557"><see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1557">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="60e59-1558">Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1558">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-1559"><see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1559">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1560">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.InvocationExpression> representa el tipo de valor devuelto del delegado que se representa mediante `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1560">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="60e59-1561">El <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.InvocationExpression> está vacío si `arguments` es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1561">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="60e59-1562">De lo contrario, contiene los mismos elementos que `arguments` excepto algunas de estas <xref:System.Linq.Expressions.Expression> objetos pueden ser *entre comillas*.</span><span class="sxs-lookup"><span data-stu-id="60e59-1562">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-1563">Un elemento se entrecomillará sólo si el parámetro correspondiente del delegado representado por `expression` es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1563">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-1564">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1564">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-1565">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1565">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1566">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.InvocationExpression> que representa la invocación de una expresión lambda con argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1566">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1567"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1567"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1568"><paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1568"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
 <span data-ttu-id="60e59-1569">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1569">-or-</span></span>  
  
 <span data-ttu-id="60e59-1570">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1570">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1571"><paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1571"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1572"><see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda que se aplicará.</span><span class="sxs-lookup"><span data-stu-id="60e59-1572">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-1573">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1573">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="60e59-1574">Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-1574">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="60e59-1575"><see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1575">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1576">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.InvocationExpression> representa el tipo de valor devuelto del delegado que se representa mediante `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1576">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="60e59-1577">El <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.InvocationExpression> está vacío si `arguments` es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1577">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="60e59-1578">De lo contrario, contiene los mismos elementos que `arguments` excepto algunas de estas <xref:System.Linq.Expressions.Expression> objetos pueden ser *entre comillas*.</span><span class="sxs-lookup"><span data-stu-id="60e59-1578">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-1579">Un elemento se entrecomillará sólo si el parámetro correspondiente del delegado representado por `expression` es de tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1579">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-1580">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1580">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-1581">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1581">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1582">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para crear un <xref:System.Linq.Expressions.InvocationExpression> que representa la invocación de una expresión lambda con argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1582">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1583"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1583"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1584"><paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1584"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
 <span data-ttu-id="60e59-1585">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1585">-or-</span></span>  
  
 <span data-ttu-id="60e59-1586">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1586">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1587"><paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1587"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1588">Devuelve si la expresión se evalúa en false.</span><span class="sxs-lookup"><span data-stu-id="60e59-1588">Returns whether the expression evaluates to false.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1589"><see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1589">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="60e59-1590">Devuelve si la expresión se evalúa en false.</span><span class="sxs-lookup"><span data-stu-id="60e59-1590">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="60e59-1591">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1591">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1592"><see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1592">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1593"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1593">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-1594">Devuelve si la expresión se evalúa en false.</span><span class="sxs-lookup"><span data-stu-id="60e59-1594">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="60e59-1595">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1595">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1596">Devuelve si la expresión se evalúa en true.</span><span class="sxs-lookup"><span data-stu-id="60e59-1596">Returns whether the expression evaluates to true.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1597"><see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1597">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="60e59-1598">Devuelve si la expresión se evalúa en true.</span><span class="sxs-lookup"><span data-stu-id="60e59-1598">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="60e59-1599">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1599">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-1600"><see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</span><span class="sxs-lookup"><span data-stu-id="60e59-1600">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1601"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1601">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-1602">Devuelve si la expresión se evalúa en true.</span><span class="sxs-lookup"><span data-stu-id="60e59-1602">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="60e59-1603">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1603">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1604">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta.</span><span class="sxs-lookup"><span data-stu-id="60e59-1604">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-1605">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y sin nombre.</span><span class="sxs-lookup"><span data-stu-id="60e59-1605">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span></span></summary>
        <returns><span data-ttu-id="60e59-1606">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1606">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1607">En el ejemplo siguiente se muestra cómo crear una expresión que contiene un <xref:System.Linq.Expressions.LabelTarget> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-1607">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1608"><see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1608">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <summary><span data-ttu-id="60e59-1609">Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1609">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span></span></summary>
        <returns><span data-ttu-id="60e59-1610"><see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1610">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60e59-1611">Nombre de la etiqueta.</span><span class="sxs-lookup"><span data-stu-id="60e59-1611">The name of the label.</span></span></param>
        <summary><span data-ttu-id="60e59-1612">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1612">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span></span></summary>
        <returns><span data-ttu-id="60e59-1613">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1613">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-1614">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</span><span class="sxs-lookup"><span data-stu-id="60e59-1614">The type of value that is passed when jumping to the label.</span></span></param>
        <summary><span data-ttu-id="60e59-1615">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1615">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1616">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1616">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-1617">En el ejemplo siguiente se muestra cómo utilizar un <xref:System.Linq.Expressions.LabelTarget> objeto en una expresión de bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-1617">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-1618"><see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1618">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="60e59-1619">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</span><span class="sxs-lookup"><span data-stu-id="60e59-1619">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span></span></param>
        <summary><span data-ttu-id="60e59-1620">Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1620">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span></span></summary>
        <returns><span data-ttu-id="60e59-1621"><see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1621">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-1622">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</span><span class="sxs-lookup"><span data-stu-id="60e59-1622">The type of value that is passed when jumping to the label.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1623">Nombre de la etiqueta.</span><span class="sxs-lookup"><span data-stu-id="60e59-1623">The name of the label.</span></span></param>
        <summary><span data-ttu-id="60e59-1624">Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1624">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span></span></summary>
        <returns><span data-ttu-id="60e59-1625">Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1625">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1626">Crea un árbol de expresión que representa una expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1626">Creates an expression tree that represents a lambda expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1627">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1627">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1628">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1628">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1629">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1629">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1630"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1630">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1631">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1631">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1632">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1632">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1633">Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1633">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1634"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1634">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1635">El `parameters` parámetro no debe tener más de dieciséis elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1635">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="60e59-1636">Los elementos de `parameters` debe ser igual que las expresiones de parámetro de la referencia `body`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1636">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="60e59-1637">Este método crea un tipo de delegado adecuado desde uno de los `System.Func` los delegados genéricos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1637">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="60e59-1638">A continuación, pasa el tipo de delegado a uno de los <xref:System.Linq.Expressions.ExpressionType.Lambda> métodos de generador para crear un <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1638">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1639"><paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1639"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1640">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1640">-or-</span></span>  
  
 <span data-ttu-id="60e59-1641">Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1641">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1642"><paramref name="parameters" /> contiene más de dieciséis elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1642"><paramref name="parameters" /> contains more than sixteen elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1643">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1643">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1644"><see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1644">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1645">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1645">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1646">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1646">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1647"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1647">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1648">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1648">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1649"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1649">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1650">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1650">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1651">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1651">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1652"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1652">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1653">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1653">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1654">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1654">The name for the lambda.</span></span> <span data-ttu-id="60e59-1655">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1655">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1656">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1656">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1657">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1657">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1658"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1658">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1659"><see cref="T:System.Type" /> que representa una firma de delegado para lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1659">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1660">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1660">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1661">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1661">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1662">Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1662">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="60e59-1663">Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1663">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1664">Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1664">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1665">El objeto devuelto por esta función es de tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1665">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="60e59-1666">El <xref:System.Linq.Expressions.LambdaExpression> tipo se utiliza para representar el objeto devuelto porque el tipo concreto de la expresión lambda no se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1666">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="60e59-1667">El número de parámetros para el tipo de delegado representado por`delegateType` debe ser igual a la longitud de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1667">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="60e59-1668">Los elementos de `parameters` debe ser igual que las expresiones de parámetro de la referencia `body`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1668">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="60e59-1669">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del objeto resultante es igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1669">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="60e59-1670">Si `parameters` es `null`, el <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propiedad del objeto resultante es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-1670">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1671">En el ejemplo siguiente se muestra cómo crear una expresión que representa una expresión lambda que agrega 1 al argumento pasado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1671">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1672">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1672"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1673">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1673">-or-</span></span>  
  
 <span data-ttu-id="60e59-1674">Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1674">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1675"><paramref name="delegateType" /> no representa un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1675"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
 <span data-ttu-id="60e59-1676">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1676">-or-</span></span>  
  
 <span data-ttu-id="60e59-1677"><paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1677"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
 <span data-ttu-id="60e59-1678">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1678">-or-</span></span>  
  
 <span data-ttu-id="60e59-1679"><paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1679"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
 <span data-ttu-id="60e59-1680">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1680">-or-</span></span>  
  
 <span data-ttu-id="60e59-1681">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1681">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1682"><see cref="T:System.Type" /> que representa una firma de delegado para lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1682">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1683">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1683">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1684">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1684">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1685">Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1685">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="60e59-1686">Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1686">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1687">Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1687">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1688">El objeto devuelto por esta función es de tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1688">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="60e59-1689">El <xref:System.Linq.Expressions.LambdaExpression> tipo se utiliza para representar el objeto devuelto porque el tipo concreto de la expresión lambda no se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1689">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="60e59-1690">El número de parámetros para el tipo de delegado representado por `delegateType` debe ser igual a la longitud de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1690">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="60e59-1691">Los elementos de `parameters` debe ser igual que las expresiones de parámetro de la referencia `body`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1691">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="60e59-1692">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del objeto resultante es igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1692">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="60e59-1693">Si `parameters` es `null`, el <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propiedad del objeto resultante es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-1693">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1694">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1694"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1695">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1695">-or-</span></span>  
  
 <span data-ttu-id="60e59-1696">Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1696">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1697"><paramref name="delegateType" /> no representa un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1697"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
 <span data-ttu-id="60e59-1698">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1698">-or-</span></span>  
  
 <span data-ttu-id="60e59-1699"><paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1699"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
 <span data-ttu-id="60e59-1700">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1700">-or-</span></span>  
  
 <span data-ttu-id="60e59-1701"><paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1701"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
 <span data-ttu-id="60e59-1702">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1702">-or-</span></span>  
  
 <span data-ttu-id="60e59-1703">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1703">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-1704">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1704">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1705">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1705">The name for the lambda.</span></span> <span data-ttu-id="60e59-1706">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1706">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1707"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1707">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1708">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1708">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1709">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1709">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1710"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1710">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1711"><see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1711">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1712">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1712">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1713"><see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1713">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1714">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1715">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1715">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1716"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1716">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1717"><see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1717">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1718">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1718">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1719"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1719">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1720">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1720">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1721">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1721">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1722"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1722">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1723"><see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1723">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1724">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1724">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1725">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1725">The name for the lambda.</span></span> <span data-ttu-id="60e59-1726">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1726">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1727">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1727">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1728">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1728">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1729"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1729">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-1730"><see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-1731">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1731">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1732">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1732">The name for the lambda.</span></span> <span data-ttu-id="60e59-1733">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1733">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1734"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1734">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1735">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1735">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1736">Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1736">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="60e59-1737"><see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1737">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1738">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1738">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1739">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1739">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1740">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1741">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1741">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1742"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1742">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1743">El número de parámetros para el tipo de delegado `TDelegate` debe ser igual al número de elementos de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1743">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="60e59-1744">Los elementos de `parameters` debe ser igual que las expresiones de parámetro de la referencia `body`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1744">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="60e59-1745">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del objeto resultante representa el tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1745">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="60e59-1746">Si `parameters` es `null`, el <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propiedad del objeto resultante es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-1746">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1747"><paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1747"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1748">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1748">-or-</span></span>  
  
 <span data-ttu-id="60e59-1749">Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1749">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1750"><paramref name="TDelegate" /> no es un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1750"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
 <span data-ttu-id="60e59-1751">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1751">-or-</span></span>  
  
 <span data-ttu-id="60e59-1752"><paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1752"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
 <span data-ttu-id="60e59-1753">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1753">-or-</span></span>  
  
 <span data-ttu-id="60e59-1754"><paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1754"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
 <span data-ttu-id="60e59-1755">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1755">-or-</span></span>  
  
 <span data-ttu-id="60e59-1756">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1756">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1757">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1757">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1758">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1759">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1759">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1760">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1760">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1761"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1761">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1762">El número de parámetros para el tipo de delegado `TDelegate` debe ser igual al número de elementos de `parameters`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1762">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="60e59-1763">Los elementos de `parameters` debe ser igual que las expresiones de parámetro de la referencia`body`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1763">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="60e59-1764">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del objeto resultante representa el tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1764">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="60e59-1765">Si `parameters` es `null`, el <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propiedad del objeto resultante es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-1765">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1766"><paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1766"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-1767">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1767">-or-</span></span>  
  
 <span data-ttu-id="60e59-1768">Uno o más elementos de <paramref name="parameters" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1768">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1769"><paramref name="TDelegate" /> no es un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1769"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
 <span data-ttu-id="60e59-1770">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1770">-or-</span></span>  
  
 <span data-ttu-id="60e59-1771"><paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1771"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
 <span data-ttu-id="60e59-1772">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1772">-or-</span></span>  
  
 <span data-ttu-id="60e59-1773"><paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1773"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
 <span data-ttu-id="60e59-1774">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-1774">-or-</span></span>  
  
 <span data-ttu-id="60e59-1775">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1775">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1776">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1776">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1777">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1777">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1778"><see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1778">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1779">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1779">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1780">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1780">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1781"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1781">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1782">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1782">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1783">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1783">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1784"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1784">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1785">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1785">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1786">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1786">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1787"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1787">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1788">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1788">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1789">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1789">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1790">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1790">The name of the lambda.</span></span> <span data-ttu-id="60e59-1791">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1791">Used for generating debugging information.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1792">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1792">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1793">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1793">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1794"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1794">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="60e59-1795">Tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="60e59-1795">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="60e59-1796">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1796">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-1797">Nombre de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="60e59-1797">The name of the lambda.</span></span> <span data-ttu-id="60e59-1798">Se usa para emitir información de depuración.</span><span class="sxs-lookup"><span data-stu-id="60e59-1798">Used for generating debugging info.</span></span></param>
        <param name="tailCall"><span data-ttu-id="60e59-1799"><see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</span><span class="sxs-lookup"><span data-stu-id="60e59-1799">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="60e59-1800">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1800">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-1801">Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1801">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="60e59-1802"><see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1802">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1803">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1803">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1804">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1804">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1805">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1805">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1806">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1806">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1807"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1807">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1808">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1808">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1809">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1809">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1810">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1810">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1811">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1811">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1812">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1812">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1813">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1813">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1814">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1814">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1815">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1815">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1816">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desplazamiento a la izquierda, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1816">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1817">De lo contrario, si `left`. El tipo es un tipo integral (uno de <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, o los correspondientes tipos que aceptan valores NULL) y `right`. El tipo es <xref:System.Int32>, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1817">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1818">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1818">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1819">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1819">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1820">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1820">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1821">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1821">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1822">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1822">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1823">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1823">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1824">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1824">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1825">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1825">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1826">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1826">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1827">El tipo del nodo es el tipo de resultado del operador de desplazamiento a la izquierda predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1827">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="60e59-1828">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1828">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1829">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de desplazamiento a la izquierda predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1829">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1830">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1830"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1831">No hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1831">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1832">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1832">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1833">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1833">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1834">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1834">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1835">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1835">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1836"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1836">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1837">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1837">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1838">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1838">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1839">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1839">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-1840">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1840">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-1841">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1841">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1842">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1842">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1843">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1843">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1844">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1844">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1845">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1845">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-1846">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desplazamiento a la izquierda, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1846">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1847">De lo contrario, si `left`. El tipo es un tipo integral (uno de <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, o los correspondientes tipos que aceptan valores NULL) y `right`. El tipo es <xref:System.Int32>, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1847">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1848">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1848">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1849">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1849">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1850">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1850">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1851">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1851">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1852">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1852">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-1853">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1853">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1854">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-1854">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-1855">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1855">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1856">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1856">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1857">El tipo del nodo es el tipo de resultado del operador de desplazamiento a la izquierda predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1857">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="60e59-1858">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1858">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1859">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de desplazamiento a la izquierda predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-1859">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1860">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1860"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1861"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1861"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1862"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1862"><paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1863">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1863">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1864">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1864">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1865">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1865">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1866">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1866">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1867"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1867">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1868">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1868">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1869">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1869">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1870">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1870">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1871">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1871">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1872"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1872">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1873">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1873">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1874">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1875">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-1876">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1876">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1877">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-1877">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-1878"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1878">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1879">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1880">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1880">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1881">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1881">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1882">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1882">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1883"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1883">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1884">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1884">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1885">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1885">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1886">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1886">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-1887">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1887">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-1888">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1888">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-1889">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1889">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1890">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1890">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1891">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1891">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1892">El método de implementación para la operación se elige según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="60e59-1892">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="60e59-1893">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "menor que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1893">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1894">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1894">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1895">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1895">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1896">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1896">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1897">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1897">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1898">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1898">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1899">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-1899">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-1900">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1900">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1901">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1901">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1902">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1902">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1903">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1903">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1904">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1904">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1905">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1905">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1906">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1907">En el ejemplo de código siguiente se muestra cómo crear una expresión que compara dos enteros.</span><span class="sxs-lookup"><span data-stu-id="60e59-1907">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1908">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1908"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1909">No hay ningún operador "menor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1909">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1910">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1910">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1911">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-1912">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1912"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1913">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1914">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1914">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1915"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1915">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1916">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1916">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1917">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1917">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1918">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1918">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-1919">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1919">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-1920">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1920">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1921">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1921">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1922">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1922">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1923">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1923">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1924">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1924">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1925">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "menor que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1925">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1926">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1926">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1927">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1927">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1928">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1928">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1929">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1929">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1930">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1930">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1931">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1931">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-1932">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1932">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1933">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1933">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1934">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1934">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1935">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1935">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1936">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1936">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1937">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1937">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1938">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1938">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1939">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1939"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-1940"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-1940"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-1941"><paramref name="method" /> es <see langword="null" /> y el operador "menor que" no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1941"><paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-1942">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1942">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1943">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1943">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1944">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1945">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1945">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1946"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1946">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1947">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1947">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1948">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1948">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1949">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1949">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-1950">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1950">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-1951">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1951">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-1952">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1952">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1953">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1953">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1954">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1954">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1955">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1956">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "menor o igual que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1956">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1957">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1957">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1958">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1958">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1959">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1960">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1960">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1961">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1961">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1962">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-1962">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-1963">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1963">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1964">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1964">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1965">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1965">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1966">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1966">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1967">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1967">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-1968">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1968">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-1969">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-1970">En el ejemplo de código siguiente se muestra cómo crear una expresión que compara dos enteros.</span><span class="sxs-lookup"><span data-stu-id="60e59-1970">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-1971">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1971"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-1972">No hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-1972">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-1973">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1973">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-1974">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-1975">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1975"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-1976">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-1976">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-1977">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</span><span class="sxs-lookup"><span data-stu-id="60e59-1977">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-1978"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-1978">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-1979">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1979">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-1980">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1980">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-1981">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1981">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-1982">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1982">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-1983">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1983">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-1984">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1984">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-1985">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-1985">Implementing Method</span></span>  
 <span data-ttu-id="60e59-1986">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-1986">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-1987">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1987">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1988">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador "menor o igual que", el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1988">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1989">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-1989">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-1990">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-1990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-1991">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1992">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-1993">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-1994">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1994">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-1995">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-1995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-1996">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1996">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-1997">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-1997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-1998">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-1998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-1999">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-1999">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-2000">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2001">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2001">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2002">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2002"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2003"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2003"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2004"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2004"><paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2005">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2005">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="60e59-2006"><see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2006">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2007">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2007">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2008">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2008">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="60e59-2009"><see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2009">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2010"><paramref name="member" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2010"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2011">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2011">-or-</span></span>  
  
 <span data-ttu-id="60e59-2012">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2012">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2013"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2013"><paramref name="member" /> does not represent a field or property.</span></span>  
  
 <span data-ttu-id="60e59-2014">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2014">-or-</span></span>  
  
 <span data-ttu-id="60e59-2015">El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2015">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="60e59-2016"><see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2016">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2017">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2017">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2018">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2018">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="60e59-2019"><see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2019">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2020"><paramref name="member" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2020"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2021">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2021">-or-</span></span>  
  
 <span data-ttu-id="60e59-2022">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2022">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2023"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2023"><paramref name="member" /> does not represent a field or property.</span></span>  
  
 <span data-ttu-id="60e59-2024">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2024">-or-</span></span>  
  
 <span data-ttu-id="60e59-2025">El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2025">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="60e59-2026">
          <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2026">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2027">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2027">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2028">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2028">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2029"><see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2029">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2030"><paramref name="propertyAccessor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2030"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2031">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2031">-or-</span></span>  
  
 <span data-ttu-id="60e59-2032">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2032">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2033"><paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2033"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
 <span data-ttu-id="60e59-2034">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2034">-or-</span></span>  
  
 <span data-ttu-id="60e59-2035">El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2035">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="60e59-2036">
          <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2036">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2037">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2037">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2038">Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2038">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2039"><see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2039">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2040"><paramref name="propertyAccessor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2040"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2041">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2041">-or-</span></span>  
  
 <span data-ttu-id="60e59-2042">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2042">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2043"><paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2043"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
 <span data-ttu-id="60e59-2044">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2044">-or-</span></span>  
  
 <span data-ttu-id="60e59-2045">El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2045">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2046">Crea una interfaz <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2046">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2047">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2047">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2048">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2048">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2049">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2049">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2050"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2050">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2051">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2051">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2052">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2052">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2053">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para crear un <xref:System.Linq.Expressions.ListInitExpression> que representa la inicialización de una nueva instancia de diccionario con dos pares de clave / valor.</span><span class="sxs-lookup"><span data-stu-id="60e59-2053">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2054">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2054"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2055">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2055">-or-</span></span>  
  
 <span data-ttu-id="60e59-2056">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2056">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2057"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2057"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2058">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2058">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2059">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2059">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2060">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2060">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2061"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2061">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2062">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2062">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2063">Para poder utilizar esta sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Type o su tipo base debe declarar un método único denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2063">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="60e59-2064">El tipo del argumento debe ser asignable desde el tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del primer elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2064">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="60e59-2065">El <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propiedad de devuelto <xref:System.Linq.Expressions.ListInitExpression> contiene un elemento de tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2065">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="60e59-2066">El <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es una colección singleton que contiene el elemento correspondiente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2066">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="60e59-2067">El <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa el método de complemento que se ha detectado en `newExpression`. Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2067">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2068">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2068">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2069">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2069"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2070">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2070">-or-</span></span>  
  
 <span data-ttu-id="60e59-2071">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2071">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2072"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2072"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2073">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2073">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2074">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2074">-or-</span></span>  
  
 <span data-ttu-id="60e59-2075">El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2075">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
 <span data-ttu-id="60e59-2076">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2076">-or-</span></span>  
  
 <span data-ttu-id="60e59-2077">El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2077">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2078">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2078">-or-</span></span>  
  
 <span data-ttu-id="60e59-2079">Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2079">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2080">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2080">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2081">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2081">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2082">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2082">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2083"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2083">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2084">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2084">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2085">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2085">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2086">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para crear un <xref:System.Linq.Expressions.ListInitExpression> que representa la inicialización de una nueva instancia de diccionario con dos pares de clave / valor.</span><span class="sxs-lookup"><span data-stu-id="60e59-2086">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2087">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2087"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2088">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2088">-or-</span></span>  
  
 <span data-ttu-id="60e59-2089">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2089">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2090"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2090"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2091">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2091">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2092">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2092">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2093">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2093">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2094"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2094">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2095">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2095">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2096">Para poder utilizar esta sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Type o su tipo base debe declarar un método único denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2096">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="60e59-2097">El tipo del argumento debe ser asignable desde el tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del primer elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2097">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="60e59-2098">El <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propiedad de devuelto <xref:System.Linq.Expressions.ListInitExpression> contiene un elemento de tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2098">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="60e59-2099">El <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es una colección singleton que contiene el elemento correspondiente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2099">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="60e59-2100">El <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa el método de complemento que se ha detectado en `newExpression`. Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2100">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2101">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2101">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2102">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2102"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2103">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2103">-or-</span></span>  
  
 <span data-ttu-id="60e59-2104">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2104">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2105"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2105"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2106">No hay ningún método de instancia denominado "Add" (no distingue mayúsculas de minúsculas) declarado en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2106">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2107">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2107">-or-</span></span>  
  
 <span data-ttu-id="60e59-2108">El método de adición en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2108">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
 <span data-ttu-id="60e59-2109">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2109">-or-</span></span>  
  
 <span data-ttu-id="60e59-2110">El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método de adición en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2110">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
 <span data-ttu-id="60e59-2111">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2111">-or-</span></span>  
  
 <span data-ttu-id="60e59-2112">Existe más de un método compatible con los argumentos denominado "Add" (no distingue mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60e59-2112">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2113">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2113">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="60e59-2114"><see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2114">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2115">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2115">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2116">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2116">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2117"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2117">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2118">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2118">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2119">If `addMethod` is `null`, `newExpression`. Type o su tipo base debe declarar un método único denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2119">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="60e59-2120">Si `addMethod` no es `null`, debe representar un método de instancia llamado "Add" (con distinción entre mayúsculas y minúsculas) que tenga exactamente un parámetro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2120">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="60e59-2121">El tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `initializers` debe ser asignable al tipo de argumento del método add.</span><span class="sxs-lookup"><span data-stu-id="60e59-2121">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="60e59-2122">El <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propiedad de devuelto <xref:System.Linq.Expressions.ListInitExpression> contiene un elemento de tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2122">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="60e59-2123">El <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es una colección singleton que contiene el elemento correspondiente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2123">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="60e59-2124">El <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2124">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="60e59-2125">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2125">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2126">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2126"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2127">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2127">-or-</span></span>  
  
 <span data-ttu-id="60e59-2128">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2128">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2129"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2129"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
 <span data-ttu-id="60e59-2130">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2130">-or-</span></span>  
  
 <span data-ttu-id="60e59-2131"><paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2131"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
 <span data-ttu-id="60e59-2132">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2132">-or-</span></span>  
  
 <span data-ttu-id="60e59-2133"><paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2133"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2134"><paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2134"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2135">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2135">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="60e59-2136"><see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2136">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2137">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2137">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2138">Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</span><span class="sxs-lookup"><span data-stu-id="60e59-2138">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="60e59-2139"><see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2139">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2140">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression` debe representar un tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2140">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="60e59-2141">If `addMethod` is `null`, `newExpression`. Type o su tipo base debe declarar un método único denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2141">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="60e59-2142">Si `addMethod` no es `null`, debe representar un método de instancia llamado "Add" (con distinción entre mayúsculas y minúsculas) que tenga exactamente un parámetro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2142">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="60e59-2143">El tipo representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `initializers` debe ser asignable al tipo de argumento del método add.</span><span class="sxs-lookup"><span data-stu-id="60e59-2143">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="60e59-2144">El <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propiedad de devuelto <xref:System.Linq.Expressions.ListInitExpression> contiene un elemento de tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2144">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="60e59-2145">El <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es una colección singleton que contiene el elemento correspondiente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2145">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="60e59-2146">El <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propiedad de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> es igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2146">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="60e59-2147">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.ListInitExpression> es igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2147">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2148">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2148"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2149">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2149">-or-</span></span>  
  
 <span data-ttu-id="60e59-2150">Uno o más elementos de <paramref name="initializers" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2150">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2151"><paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2151"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
 <span data-ttu-id="60e59-2152">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2152">-or-</span></span>  
  
 <span data-ttu-id="60e59-2153"><paramref name="addMethod" /> no es <see langword="null" /> y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2153"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
 <span data-ttu-id="60e59-2154">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2154">-or-</span></span>  
  
 <span data-ttu-id="60e59-2155"><paramref name="addMethod" /> no es <see langword="null" /> y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2155"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2156"><paramref name="addMethod" /> es <see langword="null" /> y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2156"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2157">Crea una interfaz <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2157">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-2158">Cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2158">The body of the loop.</span></span></param>
        <summary><span data-ttu-id="60e59-2159">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="60e59-2160">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2160">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-2161">Cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2161">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="60e59-2162">Destino Break empleado por el cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2162">The break target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="60e59-2163">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado y el destino Break.</span><span class="sxs-lookup"><span data-stu-id="60e59-2163">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span></span></summary>
        <returns><span data-ttu-id="60e59-2164">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2164">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-2165">En el ejemplo siguiente se muestra cómo crear una expresión de bloque que contiene un <xref:System.Linq.Expressions.LoopExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2165">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-2166">Cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2166">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="60e59-2167">Destino Break empleado por el cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2167">The break target used by the loop body.</span></span></param>
        <param name="continue"><span data-ttu-id="60e59-2168">Destino Continue empleado por el cuerpo del bucle.</span><span class="sxs-lookup"><span data-stu-id="60e59-2168">The continue target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="60e59-2169">Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2169">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="60e59-2170">Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2170">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2171">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2171">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="60e59-2172"><see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2172">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="60e59-2173"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2173">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2174"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</span><span class="sxs-lookup"><span data-stu-id="60e59-2174">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <summary><span data-ttu-id="60e59-2175">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando a un método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2175">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2176"><see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2176">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2177">El `binaryType` parámetro determina qué <xref:System.Linq.Expressions.BinaryExpression> método de generador que se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-2177">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="60e59-2178">Por ejemplo, si `binaryType` es <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2178">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2179">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> método para crear un <xref:System.Linq.Expressions.BinaryExpression> que representa la resta de un número de otro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2180"><paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2180"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2181">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2181"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="60e59-2182"><see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2182">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="60e59-2183"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2183">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2184"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</span><span class="sxs-lookup"><span data-stu-id="60e59-2184">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-2185">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2185"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2186"><see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2186">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-2187">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2187">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2188"><see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2188">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2189">El `binaryType` parámetro determina qué <xref:System.Linq.Expressions.BinaryExpression> método generador llamará a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-2189">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="60e59-2190">Por ejemplo, si `binaryType` es <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2190">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="60e59-2191">El `liftToNull` y `method` se omiten los parámetros si el método de generador adecuado no tiene un parámetro correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60e59-2191">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2192"><paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2192"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2193">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2193"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="60e59-2194"><see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2194">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="60e59-2195"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2195">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2196"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</span><span class="sxs-lookup"><span data-stu-id="60e59-2196">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-2197">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2197"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2198">Objeto <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2198">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-2199"><see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</span><span class="sxs-lookup"><span data-stu-id="60e59-2199">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span></span> <span data-ttu-id="60e59-2200">Este parámetro solo se usa si <c>binaryType</c> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</span><span class="sxs-lookup"><span data-stu-id="60e59-2200">This parameter is used only if <c>binaryType</c> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</span></span></param>
        <summary><span data-ttu-id="60e59-2201">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2202"><see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2202">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2203">El `binaryType` parámetro determina qué <xref:System.Linq.Expressions.BinaryExpression> método generador llamará a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-2203">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="60e59-2204">Por ejemplo, si `binaryType` es <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2204">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="60e59-2205">El `liftToNull`, `method` y `conversion` se omiten los parámetros si el método de generador adecuado no tiene un parámetro correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60e59-2205">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2206"><paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2206"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2207">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2207"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2208">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</span><span class="sxs-lookup"><span data-stu-id="60e59-2208">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="variable"><span data-ttu-id="60e59-2209"><see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</span><span class="sxs-lookup"><span data-stu-id="60e59-2209">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-2210">Cuerpo de la instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-2210">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="60e59-2211">Cuerpo del filtro <see cref="T:System.Exception" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2211">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="60e59-2212">Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2212">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="60e59-2213">Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2213">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2214">`type` debe ser distinto de null y coincide con el tipo de `variable` (si se proporciona).</span><span class="sxs-lookup"><span data-stu-id="60e59-2214">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2215">Crea una clase <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2215">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2216">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2216">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2217">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2217">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2218">Argumentos de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2218">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2219">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2219">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-2220"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2220">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2221">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2221">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2222">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2222">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-2223">Argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2223">The argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2224">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2224">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span></span></summary>
        <returns><span data-ttu-id="60e59-2225"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2225">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2226">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2226">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2227">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2227">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2228">Argumentos de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2228">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2229">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2229">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-2230"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2230">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2231">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2231">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2232">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2232">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-2233">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2233">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-2234">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2234">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2235">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2235">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2236"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2236">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2237">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2237">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2238">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2238">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-2239">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2239">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-2240">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2240">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-2241">Tercer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2241">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2242">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2242">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2243"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2243">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="60e59-2244">Tipo de delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2244">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60e59-2245">Enlazador en tiempo de ejecución de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2245">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="60e59-2246">Primer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2246">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="60e59-2247">Segundo argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2247">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="60e59-2248">Tercer argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2248">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="60e59-2249">Cuarto argumento de la operación dinámica.</span><span class="sxs-lookup"><span data-stu-id="60e59-2249">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="60e59-2250">Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2250">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2251"><see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2251">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><span data-ttu-id="60e59-2252"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2252">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span></span></param>
        <param name="target"><span data-ttu-id="60e59-2253">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2253">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-2254">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2254">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-2255">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2255">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2256">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto al objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2256">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span></span> <span data-ttu-id="60e59-2257">Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2257">The value passed to the label upon jumping can also be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-2258"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</span><span class="sxs-lookup"><span data-stu-id="60e59-2258">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-2259">Objeto al que pertenece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2259">The object to which the property belongs.</span></span> <span data-ttu-id="60e59-2260">Debe ser null si la propiedad es <see langword="static" /> (<see langword="shared" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60e59-2260">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span></span></param>
        <param name="indexer"><span data-ttu-id="60e59-2261"><see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</span><span class="sxs-lookup"><span data-stu-id="60e59-2261">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2262"><c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> en Visual Basic) que contiene los argumentos que se van a emplear para indizar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2262">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span></span></param>
        <summary><span data-ttu-id="60e59-2263">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada en un objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2263">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span></span></summary>
        <returns><span data-ttu-id="60e59-2264">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2264">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2265"><see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2265">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span></span> <span data-ttu-id="60e59-2266">Puede ser null para los miembros estáticos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2266">This can be null for static members.</span></span></param>
        <param name="member"><span data-ttu-id="60e59-2267"><see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-2267">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-2268">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2268">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span></span></summary>
        <returns><span data-ttu-id="60e59-2269"><see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2269">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2270">Este método puede utilizarse para crear un <xref:System.Linq.Expressions.MemberExpression> que representa el acceso a un campo o una propiedad, según el tipo de `member`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2270">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="60e59-2271">Si `member` es de tipo <xref:System.Reflection.FieldInfo>, llama a este método <xref:System.Linq.Expressions.Expression.Field%2A> para crear la <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2271">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="60e59-2272">Si `member` es de tipo <xref:System.Reflection.PropertyInfo>, llama a este método <xref:System.Linq.Expressions.Expression.Property%2A> para crear la <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2272">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2273"><paramref name="member" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2273"><paramref name="member" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2274"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2274"><paramref name="member" /> does not represent a field or property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2275">Tipo de resultado de la expresión try.</span><span class="sxs-lookup"><span data-stu-id="60e59-2275">The result type of the try expression.</span></span> <span data-ttu-id="60e59-2276">Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</span><span class="sxs-lookup"><span data-stu-id="60e59-2276">If null, bodh and all handlers must have identical type.</span></span></param>
        <param name="body"><span data-ttu-id="60e59-2277">Cuerpo del bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-2277">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="60e59-2278">Cuerpo del bloque finally.</span><span class="sxs-lookup"><span data-stu-id="60e59-2278">The body of the finally block.</span></span> <span data-ttu-id="60e59-2279">Pasa null si el bloque try no tiene ningún bloque finally asociado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2279">Pass null if the try block has no finally block associated with it.</span></span></param>
        <param name="fault"><span data-ttu-id="60e59-2280">Cuerpo del bloque fault.</span><span class="sxs-lookup"><span data-stu-id="60e59-2280">The body of the fault block.</span></span> <span data-ttu-id="60e59-2281">Pasa null si el bloque try no tiene ningún bloque fault asociado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2281">Pass null if the try block has no fault block associated with it.</span></span></param>
        <param name="handlers"><span data-ttu-id="60e59-2282">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-2282">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="60e59-2283">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2283">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="60e59-2284">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2284">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2285">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2285">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="60e59-2286"><see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2286">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="60e59-2287"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</span><span class="sxs-lookup"><span data-stu-id="60e59-2287">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-2288"><see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</span><span class="sxs-lookup"><span data-stu-id="60e59-2288">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <summary><span data-ttu-id="60e59-2289">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2289">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2290"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2290">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2291">El `unaryType` parámetro determina qué <xref:System.Linq.Expressions.UnaryExpression> método de generador que se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-2291">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="60e59-2292">Por ejemplo, si `unaryType` es igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2292">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="60e59-2293">El `type`parámetro se ignora si no se aplica al método de generador que se llama.</span><span class="sxs-lookup"><span data-stu-id="60e59-2293">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2294"><paramref name="operand" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2294"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2295"><paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2295"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="60e59-2296"><see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2296">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="60e59-2297"><see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</span><span class="sxs-lookup"><span data-stu-id="60e59-2297">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-2298"><see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase <see langword="null" /> si no es aplicable).</span><span class="sxs-lookup"><span data-stu-id="60e59-2298">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2299"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2299">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-2300">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2300">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2301"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2301">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2302">El `unaryType` parámetro determina qué <xref:System.Linq.Expressions.UnaryExpression> método de generador que se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="60e59-2302">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="60e59-2303">Por ejemplo, si `unaryType` es igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2303">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="60e59-2304">El `type` y `method` se omiten los parámetros si no se aplican al método de generador que se llama.</span><span class="sxs-lookup"><span data-stu-id="60e59-2304">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2305"><paramref name="operand" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2305"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2306"><paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</span><span class="sxs-lookup"><span data-stu-id="60e59-2306"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2307">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2307">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="60e59-2308">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2308">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2309">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2309">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2310">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2310">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="60e59-2311"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2311">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2312">El `member` parámetro debe representar un campo o propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2312">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2313">El valor de <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2313"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2314"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2314"><paramref name="member" /> does not represent a field or property.</span></span>  
  
 <span data-ttu-id="60e59-2315">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2315">-or-</span></span>  
  
 <span data-ttu-id="60e59-2316">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2316">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="60e59-2317">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2317">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2318">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2318">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2319">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2319">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="60e59-2320"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2320">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2321">El `member` parámetro debe representar un campo o propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2321">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2322">El valor de <paramref name="member" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2322"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2323"><paramref name="member" /> no representa ningún campo ni ninguna propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2323"><paramref name="member" /> does not represent a field or property.</span></span>  
  
 <span data-ttu-id="60e59-2324">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2324">-or-</span></span>  
  
 <span data-ttu-id="60e59-2325">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2325">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="60e59-2326"><see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2326">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2327">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2327">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2328">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2328">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2329"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2329">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2330">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2330"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2331"><paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2331"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
 <span data-ttu-id="60e59-2332">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2332">-or-</span></span>  
  
 <span data-ttu-id="60e59-2333">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2333">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="60e59-2334"><see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2334">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2335">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2335">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2336">Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2336">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-2337"><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2337">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2338">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2338"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2339"><paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2339"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
 <span data-ttu-id="60e59-2340">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2340">-or-</span></span>  
  
 <span data-ttu-id="60e59-2341">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2341">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2342">Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2342">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2343">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2343">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2344">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2344">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2345">Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2345">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
        <returns><span data-ttu-id="60e59-2346"><see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2346">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2347">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberInitExpression> es igual a la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2347">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2348">En el ejemplo siguiente se muestra una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2348">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2349">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2349"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2350">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2350">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="60e59-2351">
          <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2351">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="60e59-2352">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2352">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2353">Crea una interfaz <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2353">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-2354"><see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2354">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2355">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberInitExpression> es igual a la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2355">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2356">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> método para crear un <xref:System.Linq.Expressions.MemberInitExpression> que representa la inicialización de dos miembros de un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2356">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2357">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2357"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2358">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2358">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2359">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2360">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2361">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2362">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2363"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2364">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2365">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2366">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2367">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2367">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2368">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2369">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2370">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2370">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2371">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2372">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de módulo, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2373">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2373">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2374">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2375">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2376">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2377">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2378">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2379">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2380">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2381">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2382">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2383">El tipo del nodo es el tipo de resultado del operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2383">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="60e59-2384">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2385">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2385">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2386">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2386"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2387">No hay ningún operador de módulo definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2387">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2388">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2389">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2390">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2391">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2392"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2393">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2394">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2395">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2396">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2396">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2397">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2398">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2399">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2399">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2400">El método de implementación para la operación se elige según las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="60e59-2400">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="60e59-2401">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2402">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de módulo, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2403">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2403">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2404">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2405">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2406">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2407">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2408">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2409">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2410">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2411">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2412">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2413">El tipo del nodo es el tipo de resultado del operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2413">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="60e59-2414">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2415">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2415">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2416">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2416"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2417"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2417"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2418"><paramref name="method" /> es <see langword="null" /> y el operador modulus no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2418"><paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2419">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2420">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2421">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2422">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2423"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2424">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2425">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2426">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2427">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2428"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2429">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2430">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2431">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-2432">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2433">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</span><span class="sxs-lookup"><span data-stu-id="60e59-2433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2434"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2435">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2436">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2437">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2438">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2438">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2439"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2439">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2440">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2440">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2441">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2441">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2442">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2442">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2443">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2443">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2444">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2444">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2445">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2445">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2446">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2446">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2447">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2447">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2448">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de multiplicación, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2448">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2449">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2449">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2450">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2450">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2451">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2451">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2452">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2452">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2453">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2453">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2454">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2454">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2455">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2455">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2456">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2456">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2457">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2457">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2458">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2458">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2459">El tipo del nodo es el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2459">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="60e59-2460">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2460">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2461">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2461">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2462">En el ejemplo de código siguiente se muestra cómo crear una expresión que multiplica dos valores.</span><span class="sxs-lookup"><span data-stu-id="60e59-2462">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2463">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2463"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2464">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2464">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2465">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2465">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2466">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2466">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2467">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2467">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2468">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2469"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2469">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2470">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2470">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2471">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2471">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2472">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2472">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2473">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2473">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2474">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2474">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2475">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2475">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2476">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2476">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2477">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2477">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2478">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2478">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2479">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de multiplicación, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2479">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2480">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2480">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2481">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2481">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2482">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2482">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2483">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2483">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2484">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2484">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2485">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2485">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2486">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2486">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2487">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2487">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2488">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2488">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2489">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2489">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2490">El tipo del nodo es el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2490">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="60e59-2491">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2491">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2492">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2492">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2493">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2493"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2494"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2494"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2495"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2495"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2496">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2496">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2497">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2497">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2498">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2498">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2499">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2499">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2500"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2500">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2501">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2502">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2503">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2503">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2504">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2504">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2505"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2505">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2506">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2507">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2508">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2508">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-2509">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2509">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2510">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2510">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2511"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2511">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2512">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2513">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2514">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2515">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2515">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2516"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2516">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2517">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2517">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2518">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2518">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2519">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2519">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2520">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2520">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2521"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2521">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2522">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2523">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2524">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2524">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-2525">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2525">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2526">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2526">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2527"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2527">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2528">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2529">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2530">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2531">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2531">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2532"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2532">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2533">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2533">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2534">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2534">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2535">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2535">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2536">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2536">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2537">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2537">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2538">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2538">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2539">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2539">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2540">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2540">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2541">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de multiplicación, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2541">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2542">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2542">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2543">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2543">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2544">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2544">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2545">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2545">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2546">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2546">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2547">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2547">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2548">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2548">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2549">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2549">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2550">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2550">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2551">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2551">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2552">El tipo del nodo es el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2552">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="60e59-2553">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2553">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2554">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2554">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2555">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2555"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2556">No hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2556">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2557">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2557">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2558">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2558">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2559">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2559">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2560">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2560">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2561"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2561">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2562">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2562">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2563">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2563">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2564">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2564">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2565">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2565">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2566">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2566">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2567">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2567">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2568">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2568">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2569">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2569">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2570">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2570">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2571">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de multiplicación, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2571">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2572">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2572">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2573">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2573">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2574">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2574">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2575">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2575">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2576">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2576">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2577">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2577">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2578">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2578">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2579">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2579">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2580">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2580">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2581">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2581">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2582">El tipo del nodo es el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2582">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="60e59-2583">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2583">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2584">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de multiplicación predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-2584">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2585">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2585"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2586"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2586"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2587"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2587"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2588">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2588">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2589">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2589">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2590">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2591"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2591">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2592">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2592">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2593">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2593">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2594">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2594">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2595">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-2595">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2596">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2596">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2597">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2597">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2598">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario menos, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2598">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2599">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2599">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2600">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2600">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2601">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2601">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2602">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2602">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2603">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2603">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2604">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2604">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2605">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2605">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2606">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2606">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2607">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2607">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2608">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2608">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2609">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2609">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2610">En el ejemplo siguiente se muestra cómo crear una expresión que represente una operación de negación aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2610">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2611"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2611"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2612">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2612">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2613">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2613">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2614">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2614">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2615">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</span><span class="sxs-lookup"><span data-stu-id="60e59-2615">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2616"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2616">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2617">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2617">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2618">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2618">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2619">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2619">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2620">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-2620">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2621">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2621">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2622">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2622">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2623">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2623">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2624">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario menos, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2624">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2625">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2625">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2626">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2626">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2627">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2627">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2628">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2628">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2629">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2629">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2630">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2630">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2631">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2631">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2632">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2632">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2633">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2633">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2634">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2634">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2635">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2635">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2636"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2636"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2637"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2637"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2638"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2638"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-2639">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2639">-or-</span></span>  
  
 <span data-ttu-id="60e59-2640"><paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2640"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2641">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2641">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2642">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2642">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2643">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-2644"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2644">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2645">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2645">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2646">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2646">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2647">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2647">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2648">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-2648">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2649">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2649">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2650">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2650">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2651">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario menos, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2651">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2652">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2652">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2653">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2653">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2654">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2654">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2655">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2655">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2656">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2656">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2657">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2657">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2658">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2658">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2659">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2659">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2660">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2660">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2661">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2661">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2662">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2662">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2663"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2663"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2664">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2664">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2665">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2665">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2666">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2666">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2667">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2667">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span> <span data-ttu-id="60e59-2668">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2668">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-2669"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2669">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2670">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2670">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2671">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2671">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2672">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2672">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2673">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-2673">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2674">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2674">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2675">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2675">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2676">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2676">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2677">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario menos, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2677">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2678">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2678">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2679">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2679">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2680">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2680">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2681">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2681">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2682">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2682">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2683">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2683">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2684">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2684">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2685">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2685">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2686">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2686">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2687">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2687">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2688">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2688">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2689"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2689"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2690"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2690"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2691"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2691"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-2692">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2692">-or-</span></span>  
  
 <span data-ttu-id="60e59-2693"><paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2693"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2694">Crea una interfaz <see cref="T:System.Linq.Expressions.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2694">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="60e59-2695">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2695">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2696">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2697"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2697">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2698">El <xref:System.Linq.Expressions.NewExpression.Arguments%2A> y <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedades del resultante <xref:System.Linq.Expressions.NewExpression> son colecciones vacías.</span><span class="sxs-lookup"><span data-stu-id="60e59-2698">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="60e59-2699">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad representa el tipo declarativo del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2699">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2700"><paramref name="constructor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2700"><paramref name="constructor" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2701">El constructor que <paramref name="constructor" /> representa tiene por lo menos un parámetro.</span><span class="sxs-lookup"><span data-stu-id="60e59-2701">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2702"><see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2702">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span></span></param>
        <summary><span data-ttu-id="60e59-2703">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2703">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-2704"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2704">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2705">El `type` parámetro debe representar un tipo que tiene un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="60e59-2705">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="60e59-2706">El <xref:System.Linq.Expressions.NewExpression.Arguments%2A> y <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedades del resultante <xref:System.Linq.Expressions.NewExpression> son colecciones vacías.</span><span class="sxs-lookup"><span data-stu-id="60e59-2706">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="60e59-2707">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad es igual a `type`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2707">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2708">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.New%28System.Type%29> método para crear un <xref:System.Linq.Expressions.NewExpression> que representa la construcción de una nueva instancia de un objeto de diccionario mediante una llamada al constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="60e59-2708">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2709"><paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2709"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2710">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="60e59-2710">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="60e59-2711">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2711">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2712">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2712">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2713">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2713">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2714"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2714">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2715">El `arguments` parámetro debe contener el mismo número de elementos que el número de parámetros del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2715">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2716">Si `arguments` es `null`, se considera vacía y el <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2716">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="60e59-2717">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> representa el tipo declarativo del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2717">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2718">El <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedad es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2718">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2719"><paramref name="constructor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2719"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2720">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2720">-or-</span></span>  
  
 <span data-ttu-id="60e59-2721">Un elemento de <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2721">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2722">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2722">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2723">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2723">-or-</span></span>  
  
 <span data-ttu-id="60e59-2724">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2724">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="60e59-2725">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2725">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2726">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2726">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2727">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2727">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-2728"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2728">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2729">El `arguments` parámetro debe contener el mismo número de elementos que el número de parámetros del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2729">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2730">Si `arguments` es `null`, se considera vacía y el <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2730">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="60e59-2731">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> representa el tipo declarativo del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2732">El <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedad es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2732">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2733"><paramref name="constructor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2733"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2734">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2734">-or-</span></span>  
  
 <span data-ttu-id="60e59-2735">Un elemento de <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2735">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2736">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2736">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2737">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2737">-or-</span></span>  
  
 <span data-ttu-id="60e59-2738">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2738">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="60e59-2739">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2739">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2740">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="60e59-2741">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2741">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2742">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2742">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="60e59-2743">Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</span><span class="sxs-lookup"><span data-stu-id="60e59-2743">The members that access the constructor initialized fields are specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-2744"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2744">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2745">El `arguments` parámetro debe contener el mismo número de elementos que el número de parámetros del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2745">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2746">Si `arguments` es `null`, se considera vacía y el <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2746">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="60e59-2747">Si `members` es `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2747">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="60e59-2748">Si `members` no `null`, debe tener el mismo número de elementos como `arguments` y cada elemento no debe ser `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2748">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="60e59-2749">Cada elemento de `members` debe ser un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> o <xref:System.Reflection.MethodInfo> que representa un miembro de instancia del tipo declarativo del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2749">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2750">Si estos datos representan una propiedad, la propiedad debe tener un `get` descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-2750">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="60e59-2751">El elemento correspondiente de `arguments` para cada elemento de `members` debe tener un <xref:System.Linq.Expressions.Expression.Type%2A> propiedad que representa un tipo que se puede asignar al tipo del miembro que la `members` representa el elemento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2751">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="60e59-2752">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> representa el tipo declarativo del constructor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2752">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2753"><paramref name="constructor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2753"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2754">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2754">-or-</span></span>  
  
 <span data-ttu-id="60e59-2755">Un elemento de <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2755">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2756">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2756">-or-</span></span>  
  
 <span data-ttu-id="60e59-2757">Un elemento de <paramref name="members" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2757">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2758">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2758">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2759">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2759">-or-</span></span>  
  
 <span data-ttu-id="60e59-2760">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2760">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2761">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2761">-or-</span></span>  
  
 <span data-ttu-id="60e59-2762">El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2762">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
 <span data-ttu-id="60e59-2763">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2763">-or-</span></span>  
  
 <span data-ttu-id="60e59-2764">Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2764">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="60e59-2765">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2765">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-2766">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2766">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="60e59-2767">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2767">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2768">Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2768">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="60e59-2769">Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-2769">The members that access the constructor initialized fields are specified as an array.</span></span></summary>
        <returns><span data-ttu-id="60e59-2770"><see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2770">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2771">El `arguments` parámetro debe contener el mismo número de elementos que el número de parámetros del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2771">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2772">Si `arguments` es `null`, se considera vacía y el <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2772">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="60e59-2773">Si `members` es `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> es una colección vacía.</span><span class="sxs-lookup"><span data-stu-id="60e59-2773">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="60e59-2774">Si `members` no `null`, debe tener el mismo número de elementos como `arguments` y cada elemento no debe ser `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2774">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="60e59-2775">Cada elemento de `members` debe ser un <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> o <xref:System.Reflection.MethodInfo> que representa un miembro de instancia del tipo declarativo del constructor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2775">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="60e59-2776">Si estos datos representan una propiedad, la propiedad debe ser capaz de recuperar el valor del campo asociado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2776">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="60e59-2777">El elemento correspondiente de `arguments` para cada elemento de `members` debe tener un <xref:System.Linq.Expressions.Expression.Type%2A> propiedad que representa un tipo que se puede asignar al tipo del miembro que la `members` representa el elemento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2777">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="60e59-2778">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewExpression> representa el tipo declarativo del constructor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-2778">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2779"><paramref name="constructor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2779"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2780">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2780">-or-</span></span>  
  
 <span data-ttu-id="60e59-2781">Un elemento de <paramref name="arguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2781">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2782">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2782">-or-</span></span>  
  
 <span data-ttu-id="60e59-2783">Un elemento de <paramref name="members" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2783">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2784">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2784">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2785">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2785">-or-</span></span>  
  
 <span data-ttu-id="60e59-2786">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que representa <paramref name="constructor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2786">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
 <span data-ttu-id="60e59-2787">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2787">-or-</span></span>  
  
 <span data-ttu-id="60e59-2788">El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2788">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
 <span data-ttu-id="60e59-2789">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2789">-or-</span></span>  
  
 <span data-ttu-id="60e59-2790">Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2790">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2791">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2791">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2792"><see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-2792">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="60e59-2793">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2793">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2794">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2794">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="60e59-2795"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2795">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2796">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewArrayExpression> representa un tipo de matriz cuyo rango es igual que la longitud de `bounds` y cuyo tipo de elemento es `type`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2796">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="60e59-2797">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `bounds` debe representar un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="60e59-2797">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2798">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para crear un árbol de expresión que representa la creación de una matriz de cadenas que tiene un rango de 2.</span><span class="sxs-lookup"><span data-stu-id="60e59-2798">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2799">El valor de <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2799"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2800">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2800">-or-</span></span>  
  
 <span data-ttu-id="60e59-2801">Un elemento de <paramref name="bounds" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2801">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2802">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="60e59-2802">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2803"><see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-2803">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="60e59-2804">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2804">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2805">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2805">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="60e59-2806"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2806">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2807">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewArrayExpression> representa un tipo de matriz cuyo rango es igual que la longitud de `bounds` y cuyo tipo de elemento es `type`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2807">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="60e59-2808">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `bounds` debe representar un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="60e59-2808">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2809">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para crear un árbol de expresión que representa la creación de una matriz de cadenas que tiene un rango de 2.</span><span class="sxs-lookup"><span data-stu-id="60e59-2809">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2810">El valor de <paramref name="type" /> o <paramref name="bounds" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2810"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2811">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2811">-or-</span></span>  
  
 <span data-ttu-id="60e59-2812">Un elemento de <paramref name="bounds" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2812">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-2813">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="60e59-2813">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2814">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2814">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2815"><see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-2815">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2816">
          <see cref="T:System.Collections.Generic.IEnumerable\`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2816">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2817">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2817">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="60e59-2818"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2818">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2819">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `initializers` debe representar un tipo que se puede asignar al tipo representado por `type`, posiblemente después de crear una *entre comillas*.</span><span class="sxs-lookup"><span data-stu-id="60e59-2819">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-2820">Un elemento se entrecomillará sólo si `type` es <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2820">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-2821">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2821">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-2822">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2822">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="60e59-2823">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewArrayExpression> representa un tipo de matriz cuyo rango es 1 y cuyo tipo de elemento es `type`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2824">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para crear un árbol de expresión que representa la creación de una matriz de cadenas unidimensional que se inicializa con una lista de expresiones de cadena.</span><span class="sxs-lookup"><span data-stu-id="60e59-2824">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2825">El valor de <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2825"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2826">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2826">-or-</span></span>  
  
 <span data-ttu-id="60e59-2827">Un elemento de <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2827">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2828">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo representado por <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2828">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-2829"><see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60e59-2829">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="60e59-2830">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2830">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-2831">Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2831">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="60e59-2832"><see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2832">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2833">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad de cada elemento de `initializers` debe representar un tipo que se puede asignar al tipo representado por `type`, posiblemente después de crear una *entre comillas*.</span><span class="sxs-lookup"><span data-stu-id="60e59-2833">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60e59-2834">Un elemento se entrecomillará sólo si `type` es <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2834">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="60e59-2835">Entrecomillar significa que el elemento se ajusta en un <xref:System.Linq.Expressions.ExpressionType.Quote> nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2835">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="60e59-2836">El nodo resultante es un <xref:System.Linq.Expressions.UnaryExpression> cuyo <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propiedad es el elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2836">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="60e59-2837">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.NewArrayExpression> representa un tipo de matriz cuyo rango es 1 y cuyo tipo de elemento es `type`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2837">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2838">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para crear un árbol de expresión que representa la creación de una matriz de cadenas unidimensional que se inicializa con una lista de expresiones de cadena.</span><span class="sxs-lookup"><span data-stu-id="60e59-2838">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2839">El valor de <paramref name="type" /> o <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2839"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-2840">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2840">-or-</span></span>  
  
 <span data-ttu-id="60e59-2841">Un elemento de <paramref name="initializers" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2841">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2842">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2842">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60e59-2843">Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2843">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <value><span data-ttu-id="60e59-2844">Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2844">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2845">El <xref:System.Linq.Expressions.Expression.NodeType%2A> propiedad proporciona una descripción más especializada de un <xref:System.Linq.Expressions.Expression> que simplemente su tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2845">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="60e59-2846">Por ejemplo, un <xref:System.Linq.Expressions.BinaryExpression> puede usarse para representar muchos tipos diferentes de expresiones binarias, como una operación de división o una operación "mayor que".</span><span class="sxs-lookup"><span data-stu-id="60e59-2846">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="60e59-2847">El <xref:System.Linq.Expressions.Expression.NodeType%2A> propiedad describe estas expresiones binarias como <xref:System.Linq.Expressions.ExpressionType.Divide> y <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="60e59-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="60e59-2848">El tipo CLR estático de la expresión que la <xref:System.Linq.Expressions.Expression> representa del objeto representado por la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2848">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2849">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-2849">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2850">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2851">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2852"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-2852">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2853">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2853">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2854">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2854">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2855">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2855">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2856">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2856">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2857">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2857">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2858">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2858">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2859">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario not, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2859">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2860">De lo contrario, si `expression`. Type es un tipo numérico o booleano, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2860">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2861">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2861">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2862">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2862">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2863">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2863">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2864">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2864">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2865">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2865">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2866">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo que no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2866">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2867">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2867">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2868">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2868">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2869">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2869">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2870">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2870">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-2871">En el ejemplo siguiente se muestra cómo crear una expresión que represente una operación lógica no operación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2871">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2872"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2872"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2873">No hay ningún operador unario Not definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2873">The unary not operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2874">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2875">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2876">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-2876">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span> <span data-ttu-id="60e59-2877">Se puede especificar el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2877">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-2878"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2878">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2879">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2879">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-2880">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2880">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2881">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2881">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2882">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2882">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2883">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2883">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2884">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2884">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2885">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2885">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-2886">If `expression`. El tipo es un tipo definido por el usuario que define el operador unario not, el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2886">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2887">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2887">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2888">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2888">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2889">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2889">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2890">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2890">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2891">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2891">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2892">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2892">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2893">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2893">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2894">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2894">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2895">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2895">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-2896">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2896">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2897">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2897">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2898"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2898"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2899"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-2899"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2900"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario Not definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2900"><paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-2901">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-2901">-or-</span></span>  
  
 <span data-ttu-id="60e59-2902"><paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2902"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2903">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2903">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2904">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2904">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2905">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2905">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2906">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2906">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-2907"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2907">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2908">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2908">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2909">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2909">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2910">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2910">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="60e59-2911">De lo contrario, es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2911">Otherwise, it is `false`.</span></span> <span data-ttu-id="60e59-2912">La propiedad <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> es siempre `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2912">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="60e59-2913">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2913">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2914">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2914">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2915">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2915">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2916">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2916">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2917">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desigualdad, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2917">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2918">De lo contrario, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2918">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2919">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2919">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2920">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2920">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2921">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2921">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2922">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2922">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2923">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="60e59-2923">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="60e59-2924">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2924">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2925">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2925">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-2926">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2926">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2927">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2927">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2928">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2928">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-2929">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2929">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2930">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2931">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2931"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-2932">No hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2932">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2933">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2933">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2934">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2934">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull">
          <span data-ttu-id="60e59-2935">Es <see langword="true" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="true" />; es <see langword="false" /> para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2935"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2936">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2936">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2937">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</span><span class="sxs-lookup"><span data-stu-id="60e59-2937">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-2938"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2938">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2939">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2939">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2940">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2940">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2941">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> propiedad es `true` y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propiedad es igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2941">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="60e59-2942">En caso contrario, que son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2942">Otherwise, they are both `false`.</span></span> <span data-ttu-id="60e59-2943">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2943">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2944">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2944">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2945">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2945">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2946">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2946">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2947">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2947">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2948">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desigualdad, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2948">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2949">De lo contrario, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2949">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2950">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2950">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2951">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2951">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2952">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2952">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2953">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2953">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2954">Si se cumplen las dos condiciones siguientes, se eleva el nodo; Además, el tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2954">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="60e59-2955">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2955">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2956">El tipo de valor devuelto del método de implementación es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2956">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="60e59-2957">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2957">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2958">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2958">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2959">El tipo del nodo es <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-2959">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="60e59-2960">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2960">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2961">El tipo del nodo es que aceptan valores NULL <xref:System.Boolean> si `liftToNull` es `true` o <xref:System.Boolean> si `liftToNull` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2961">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-2962">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2962"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-2963"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2963"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-2964"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-2964"><paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2965">Devuelve la expresión que representa el complemento a unos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2965">Returns the expression representing the ones complement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2966">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2966">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="60e59-2967">Devuelve la expresión que representa el complemento a unos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2967">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="60e59-2968">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2968">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-2969">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2969">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-2970"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2970">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-2971">Devuelve la expresión que representa el complemento a unos.</span><span class="sxs-lookup"><span data-stu-id="60e59-2971">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="60e59-2972">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2972">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-2973">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-2973">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-2974">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-2975">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-2975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-2976">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-2976">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-2977"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-2977">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-2978">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2978">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-2979">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2979">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-2980">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2980">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-2981">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2981">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-2982">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2982">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-2983">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2983">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-2984">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-2984">Implementing Method</span></span>  
 <span data-ttu-id="60e59-2985">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2985">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-2986">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `OR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2986">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2987">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-2987">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-2988">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-2988">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-2989">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2989">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2990">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2990">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-2991">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2991">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-2992">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-2992">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-2993">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-2993">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-2994">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-2994">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-2995">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-2995">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-2996">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2996">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-2997">El tipo del nodo es el tipo de resultado de predefinido bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-2997">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-2998">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-2998">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-2999">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-2999">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3000">En el ejemplo de código siguiente se muestra cómo crear una expresión que represente una operación OR lógica.</span><span class="sxs-lookup"><span data-stu-id="60e59-3000">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3001">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3001"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3002">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3002">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3003">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3003">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3004">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3004">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3005">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3005">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3006">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3006">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3007"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3007">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3008">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3008">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3009">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3009">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3010">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3010">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3011">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3011">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3012">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3012">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3013">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3013">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3014">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3014">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3015">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3015">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3016">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3016">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3017">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `OR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3017">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3018">De lo contrario, si `left`. Tipo y `right`. Type son tipos enteros o booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3018">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3019">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3019">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3020">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3020">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3021">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3021">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3022">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3022">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3023">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3023">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3024">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3024">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3025">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3025">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3026">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3026">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3027">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3027">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3028">El tipo del nodo es el tipo de resultado de predefinido bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3028">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-3029">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3029">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3030">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de predefinido bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3030">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3031">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3031"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3032"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3032"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3033"><paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3033"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3034">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3034">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3035">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3035">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3036">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3036">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3037">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3037">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3038"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3038">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3039">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3039">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3040">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3040">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3041">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3041">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3042">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3042">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3043"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3043">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3044">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3044">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3045">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3045">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3046">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3046">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-3047">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3047">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3048">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3048">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3049"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3049">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3050">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando solo si el primer operando se evalúa como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3051">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3051">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3052">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3052">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3053">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3053">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3054"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3054">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3055">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3055">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3056">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3056">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3057">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3057">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3058">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3058">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3059">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3059">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3060">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3060">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3061">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3061">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3062">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3062">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3063">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `OR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3063">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="60e59-3064">El atributo conditional `OR` no se pueden sobrecargar el operador en C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-3064">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="60e59-3065">Sin embargo, el atributo conditional `OR` operador se evalúa utilizando bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3065">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="60e59-3066">Por lo tanto, una sobrecarga definida por el usuario del bit a bit `OR` puede ser el método de implementación para este tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3066">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="60e59-3067">De lo contrario, si `left`. Tipo y `right`. Type son tipos booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3067">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3068">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3068">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3069">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3069">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3070">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3070">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3071">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3071">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3072">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3072">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3073">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL, y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3073">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3074">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3074">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3075">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3075">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3076">`left`. Tipo y `right`. Tipo son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-3076">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="60e59-3077">If `left`. Tipo y `right`. Tipo que no acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3077">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3078">El tipo del nodo es el tipo de resultado de la instrucción condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3078">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-3079">If `left`. Tipo y `right`. Tipo que acepta valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3079">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3080">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de la instrucción condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3080">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3081">En el ejemplo de código siguiente se muestra cómo crear una expresión que represente una operación lógica `OR` operación que evalúa el segundo operando solo si el primer operando se evalúa como `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3081">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3082">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3082"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3083">No hay ningún operador <see langword="OR" /> bit a bit definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3083">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-3084">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3084">-or-</span></span>  
  
 <span data-ttu-id="60e59-3085"><paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-3085"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3086">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3086">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3087">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3087">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3088">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3088">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3089">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación <see langword="OR" /> condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3089">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3090"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3090">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3091">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3091">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3092">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3092">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3093">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3093">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3094">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3094">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3095">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3095">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3096">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3096">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3097">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3097">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3098">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3098">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3099">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3099">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-3100">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga bit a bit `OR` (operador), el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3100">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="60e59-3101">El atributo conditional `OR` no se pueden sobrecargar el operador en C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60e59-3101">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="60e59-3102">Sin embargo, el atributo conditional `OR` operador se evalúa utilizando bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3102">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="60e59-3103">Por lo tanto, una sobrecarga definida por el usuario del bit a bit `OR` puede ser el método de implementación para este tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3103">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="60e59-3104">De lo contrario, si `left`. Tipo y `right`. Type son tipos booleanos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3104">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3105">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3105">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3106">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3106">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3107">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3107">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3108">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3108">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3109">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3109">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3110">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL, y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3110">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3111">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3111">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3112">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3112">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3113">`left`. Tipo y `right`. Tipo son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-3113">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="60e59-3114">If `left`. Tipo y `right`. Tipo que no acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3114">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3115">El tipo del nodo es el tipo de resultado de la instrucción condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3115">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="60e59-3116">If `left`. Tipo y `right`. Tipo que acepta valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3116">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3117">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado de la instrucción condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3117">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3118">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3118"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3119"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3119"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3120"><paramref name="method" /> es <see langword="null" /> y el operador <see langword="OR" /> bit a bit no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3120"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-3121">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3121">-or-</span></span>  
  
 <span data-ttu-id="60e59-3122"><paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</span><span class="sxs-lookup"><span data-stu-id="60e59-3122"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3123">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3123">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3124">Tipo del parámetro o variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-3124">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="60e59-3125">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="60e59-3126">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3126">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-3127">En el ejemplo siguiente se muestra cómo crear un <xref:System.Linq.Expressions.MethodCallExpression> objeto que imprime el valor de un <xref:System.Linq.Expressions.ParameterExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3127">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3128">Tipo del parámetro o variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-3128">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-3129">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</span><span class="sxs-lookup"><span data-stu-id="60e59-3129">The name of the parameter or variable, used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="60e59-3130">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3130">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="60e59-3131"><see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3131">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3132"><paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3132"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3133">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3133">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3134">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3134">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="60e59-3135">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3136"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3136">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3137">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3137">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3138"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3138">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-3139">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3139">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3140"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3140">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3141">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3142">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3142">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="60e59-3143">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3144"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3144">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3145">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3145">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3146"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3146">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-3147">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</span><span class="sxs-lookup"><span data-stu-id="60e59-3147">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3148"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3148">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3149">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-3149">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3150">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3150">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3151">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3151">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3152">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-3152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="60e59-3153"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3153">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3154">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3154">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3155">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3155">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3156">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3156">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3157">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3157">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3158">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3158">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3159">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3159">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3160">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3160">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3161">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3161">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3162">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de exponenciación, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3162">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3163">De lo contrario, si `left`. Tipo y `right`. Tipo son <xref:System.Double>, el método de implementación es <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3163">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3164">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3164">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="60e59-3165">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3165">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3166">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3166">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3167">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3167">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3168">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3168">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3169">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3169">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3170">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3170"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3171">No hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3171">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-3172">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3172">-or-</span></span>  
  
 <span data-ttu-id="60e59-3173"><paramref name="left" />.Type y/o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3173"><paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3174">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3174">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3175">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3175">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3176">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3176">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3177">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-3177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="60e59-3178"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3178">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3179">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3179">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3180">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3180">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3181">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3181">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3182">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3182">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3183">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3183">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3184">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3184">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3185">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3185">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3186">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3186">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3187">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3187">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3188">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de exponenciación, el <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3188">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3189">De lo contrario, si `left`. Tipo y `right`. Tipo son <xref:System.Double>, el método de implementación es <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3189">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3190">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3190">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="60e59-3191">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3191">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3192">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3192">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3193">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3193">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3194">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3194">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3195">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3195">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3196">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3196"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3197"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3197"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3198"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3198"><paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-3199">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3199">-or-</span></span>  
  
 <span data-ttu-id="60e59-3200"><paramref name="method" /> es <see langword="null" /> y <paramref name="left" />.Type o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3200"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3201">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3202">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3202">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3203">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3204">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3204">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3205"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3205">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3206">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3206">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3207">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3207">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3208">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3208">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3209">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3209">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3210"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3210">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3211">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3211">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3212">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3212">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3213">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3213">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-3214">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3214">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3215">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3215">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3216"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3216">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3217">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3217">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3218">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3218">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="60e59-3219">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3220"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3220">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3221">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3221">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3222"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3222">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-3223">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3223">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3224"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3224">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3225">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3226">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3226">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="60e59-3227">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3228"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3228">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3229">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</span><span class="sxs-lookup"><span data-stu-id="60e59-3229">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3230"><see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3230">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="60e59-3231">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3231">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="60e59-3232"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3232">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3233">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3233">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3234">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3234">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="60e59-3235">Puede ser null para las propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="60e59-3235">This can be null for static properties.</span></span></param>
        <param name="propertyAccessor"><span data-ttu-id="60e59-3236"><see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3236">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <summary><span data-ttu-id="60e59-3237">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad usando un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3237">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="60e59-3238"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3238">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3239">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad de <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3239">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="60e59-3240">Si el método representado por `propertyAccessor` es `static` (`Shared` en Visual Basic), `expression` puede ser `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3240">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3241"><paramref name="propertyAccessor" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3241"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-3242">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3242">-or-</span></span>  
  
 <span data-ttu-id="60e59-3243">El método que <paramref name="propertyAccessor" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3243">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3244"><paramref name="expression" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3244"><paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span></span>  
  
 <span data-ttu-id="60e59-3245">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3245">-or-</span></span>  
  
 <span data-ttu-id="60e59-3246">El método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3246">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3247">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3247">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="60e59-3248">Puede ser null para las propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="60e59-3248">This can be null for static properties.</span></span></param>
        <param name="property"><span data-ttu-id="60e59-3249">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3249">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3250">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3250">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3251"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3251">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3252">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad de <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3252">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="60e59-3253">Si la propiedad representada por `property` es `static` (`Shared` en Visual Basic), `expression` puede ser `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3253">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3254"><paramref name="property" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3254"><paramref name="property" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="60e59-3255">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3255">-or-</span></span>  
  
 <span data-ttu-id="60e59-3256">La propiedad que <paramref name="property" /> representa no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) y el valor de <paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3256">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3257"><paramref name="expression" />.Type no se puede asignar al tipo declarativo de la propiedad que <paramref name="property" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-3257"><paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3258"><see cref="T:System.Linq.Expressions.Expression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad denominada <c>propertyName</c>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3258">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <c>propertyName</c>.</span></span> <span data-ttu-id="60e59-3259">Puede ser <see langword="null" /> para las propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="60e59-3259">This can be <see langword="null" /> for static properties.</span></span></param>
        <param name="propertyName"><span data-ttu-id="60e59-3260">Nombre de una propiedad a la que se va a obtener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3260">The name of a property to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-3261">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3261">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3262"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3262">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3263">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.PropertyInfo.PropertyType%2A> propiedad de la <xref:System.Reflection.PropertyInfo> que representa la propiedad denotada por `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3263">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="60e59-3264">Este método busca `expression`. Tipo y sus tipos base para una propiedad que tiene el nombre `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3264">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="60e59-3265">Propiedades públicas tienen preferencia sobre las propiedades de no público.</span><span class="sxs-lookup"><span data-stu-id="60e59-3265">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="60e59-3266">Si se encuentra una propiedad coincidente, este método pasa `expression` y <xref:System.Reflection.PropertyInfo> que representa esa propiedad para <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3266">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3267">En el ejemplo siguiente se muestra cómo crear una expresión que representa el acceso a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3267">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3268">El valor de <paramref name="expression" /> o <paramref name="propertyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3268"><paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-3269">No se ha definido ninguna propiedad denominada <paramref name="propertyName" /> en <paramref name="expression" />.Type o sus tipos base.</span><span class="sxs-lookup"><span data-stu-id="60e59-3269">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-3270">Objeto al que pertenece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3270">The object to which the property belongs.</span></span> <span data-ttu-id="60e59-3271">Si la propiedad es estática o compartida, deberá ser null.</span><span class="sxs-lookup"><span data-stu-id="60e59-3271">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="60e59-3272"><see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3272">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-3273"><see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3273">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="60e59-3274">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</span><span class="sxs-lookup"><span data-stu-id="60e59-3274">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3275">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3275">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-3276">Objeto al que pertenece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3276">The object to which the property belongs.</span></span> <span data-ttu-id="60e59-3277">Si la propiedad es estática o compartida, deberá ser null.</span><span class="sxs-lookup"><span data-stu-id="60e59-3277">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="60e59-3278"><see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3278">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-3279">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3279">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="60e59-3280">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</span><span class="sxs-lookup"><span data-stu-id="60e59-3280">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3281">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3281">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="60e59-3282">Objeto al que pertenece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3282">The object to which the property belongs.</span></span> <span data-ttu-id="60e59-3283">Si la propiedad es estática o compartida, deberá ser null.</span><span class="sxs-lookup"><span data-stu-id="60e59-3283">If the property is static/shared, it must be null.</span></span></param>
        <param name="propertyName"><span data-ttu-id="60e59-3284">Nombre del indizador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3284">The name of the indexer.</span></span></param>
        <param name="arguments"><span data-ttu-id="60e59-3285">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3285">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="60e59-3286">Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</span><span class="sxs-lookup"><span data-stu-id="60e59-3286">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3287">Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3287">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3288">Objeto contenedor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3288">The containing object of the property.</span></span> <span data-ttu-id="60e59-3289">Puede ser null para las propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="60e59-3289">This can be null for static properties.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3290"><see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3290">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span></span></param>
        <param name="propertyName"><span data-ttu-id="60e59-3291">Propiedad a la que se va a obtener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3291">The property to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-3292">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60e59-3292">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span></span></summary>
        <returns><span data-ttu-id="60e59-3293">Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3293">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3294"><see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo llamados <c>propertyOrFieldName</c>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3294">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <c>propertyOrFieldName</c>.</span></span> <span data-ttu-id="60e59-3295">Puede ser null para los miembros estáticos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3295">This can be null for static members.</span></span></param>
        <param name="propertyOrFieldName"><span data-ttu-id="60e59-3296">Nombre de una propiedad o un campo al que se va a obtener acceso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3296">The name of a property or field to be accessed.</span></span></param>
        <summary><span data-ttu-id="60e59-3297">Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o a un campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3297">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span></span></summary>
        <returns><span data-ttu-id="60e59-3298"><see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3298">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3299">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.MemberExpression> es igual a la <xref:System.Reflection.PropertyInfo.PropertyType%2A> o <xref:System.Reflection.FieldInfo.FieldType%2A> propiedades de la <xref:System.Reflection.PropertyInfo> o <xref:System.Reflection.FieldInfo>, respectivamente, que representa la propiedad o el campo denotado por `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3299">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="60e59-3300">Este método busca `expression`. Tipo y sus tipos base para una propiedad o campo que tiene el nombre `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3300">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="60e59-3301">Campos y propiedades públicos tienen preferencia sobre los campos y propiedades no público.</span><span class="sxs-lookup"><span data-stu-id="60e59-3301">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="60e59-3302">Además, las propiedades tienen preferencia sobre los campos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3302">Also, properties are given preference over fields.</span></span> <span data-ttu-id="60e59-3303">Si se encuentra una propiedad o un campo coincidente, este método pasa `expression` y <xref:System.Reflection.PropertyInfo> o <xref:System.Reflection.FieldInfo> que representa esa propiedad o campo para <xref:System.Linq.Expressions.Expression.Property%2A> o <xref:System.Linq.Expressions.Expression.Field%2A>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="60e59-3303">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3304">En el ejemplo siguiente se muestra cómo crear una expresión que representa el acceso a una propiedad o campo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3304">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3305">El valor de <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3305"><paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60e59-3306">No se ha definido ninguna propiedad o ningún campo denominado <paramref name="propertyOrFieldName" /> en <paramref name="expression" />.Type o sus tipos base.</span><span class="sxs-lookup"><span data-stu-id="60e59-3306">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3307">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3307">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3308">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor de tipo <see cref="T:System.Linq.Expressions.Expression" /> constante.</span><span class="sxs-lookup"><span data-stu-id="60e59-3308">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3309"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3309">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3310">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> representa el tipo construido <xref:System.Linq.Expressions.Expression%601>, donde el argumento de tipo es el tipo representado por `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3310">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="60e59-3311">La propiedad <xref:System.Linq.Expressions.UnaryExpression.Method%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3311">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="60e59-3312">Ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3312">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3313"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3313"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-3314">Reduce este nodo a una expresión más simple.</span><span class="sxs-lookup"><span data-stu-id="60e59-3314">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="60e59-3315">Si CanReduce devuelve true, debería devolver una expresión válida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3315">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="60e59-3316">Este método puede devolver otro nodo que se debe reducir a su vez.</span><span class="sxs-lookup"><span data-stu-id="60e59-3316">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="60e59-3317">Expresión reducida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3317">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-3318">Reduce este nodo a una expresión más simple.</span><span class="sxs-lookup"><span data-stu-id="60e59-3318">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="60e59-3319">Si CanReduce devuelve true, debería devolver una expresión válida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3319">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="60e59-3320">Este método puede devolver otro nodo que se debe reducir a su vez.</span><span class="sxs-lookup"><span data-stu-id="60e59-3320">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="60e59-3321">Expresión reducida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3321">The reduced expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3322">A diferencia de Reduce, este método comprueba que el nodo reducido cumple determinadas invariables.</span><span class="sxs-lookup"><span data-stu-id="60e59-3322">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-3323">Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3323">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span></span></summary>
        <returns><span data-ttu-id="60e59-3324">Expresión reducida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3324">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3325">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3326">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3327">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-3327">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-3328"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3328">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3329">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3330">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3331">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</span><span class="sxs-lookup"><span data-stu-id="60e59-3331">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="60e59-3332"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3332">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3333">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3333">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-3334">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3334">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
        <returns><span data-ttu-id="60e59-3335">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3335">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3336">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3336">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3337">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3337">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="60e59-3338">Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3338">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3339">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</span><span class="sxs-lookup"><span data-stu-id="60e59-3339">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-3340">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3340">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="60e59-3341">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</span><span class="sxs-lookup"><span data-stu-id="60e59-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
        <returns><span data-ttu-id="60e59-3342"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3342">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-3343">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3343">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-3344">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3344">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="60e59-3345">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</span><span class="sxs-lookup"><span data-stu-id="60e59-3345">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span> <span data-ttu-id="60e59-3346">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3346">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-3347"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3347">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-3348">En el ejemplo siguiente se muestra cómo crear una expresión que contiene el <xref:System.Linq.Expressions.Expression.Return%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60e59-3348">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-3349">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3349">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3350">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3350">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3351">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3351">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="60e59-3352"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3352">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="60e59-3353">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3353">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="60e59-3354">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3354">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3355">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3355">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3356">Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3356">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span> <span data-ttu-id="60e59-3357">Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3357">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="60e59-3358"><see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</span><span class="sxs-lookup"><span data-stu-id="60e59-3358">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3359">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3360">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3361">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3362">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3363"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3364">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3365">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3366">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3367">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3367">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3368">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3369">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3370">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3370">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3371">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3372">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desplazamiento a la derecha, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3373">De lo contrario, si `left`. El tipo es un tipo integral (uno de <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, o los correspondientes tipos que aceptan valores NULL) y `right`. El tipo es <xref:System.Int32>, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3373">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3374">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3375">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3376">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3377">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3378">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3379">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3380">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3381">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3382">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3383">El tipo del nodo es el tipo de resultado del operador de desplazamiento a la derecha predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3383">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="60e59-3384">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3385">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de desplazamiento a la derecha predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3385">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3386">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3386"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3387">No hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3387">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3388">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3389">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3390">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3391">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3392"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3393">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3394">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3395">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3396">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3396">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3397">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3398">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3399">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3399">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3400">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3400">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3401">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-3402">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de desplazamiento a la derecha, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3403">De lo contrario, si `left`. El tipo es un tipo integral (uno de <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, o los correspondientes tipos que aceptan valores NULL) y `right`. El tipo es <xref:System.Int32>, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3403">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3404">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3405">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3406">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3407">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3408">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3409">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3410">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3411">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3412">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3413">El tipo del nodo es el tipo de resultado del operador de desplazamiento a la derecha predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3413">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="60e59-3414">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3415">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de desplazamiento a la derecha predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3415">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3416">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3416"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3417"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3417"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3418"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3418"><paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3419">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3420">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3421">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3422">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3423"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3424">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3425">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3426">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3427">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3428"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3429">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3430">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3431">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-3432">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3433">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</span><span class="sxs-lookup"><span data-stu-id="60e59-3433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3434"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3435">Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3435">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="60e59-3436">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3436">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-3437">Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3438">Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3438">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="60e59-3439">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3439">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="60e59-3440">Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3440">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3441">Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3441">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3442">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3442">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3443">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3443">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3444">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3444">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3445">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3445">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3446"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3446">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3447">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3447">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3448">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3448">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3449">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3449">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3450">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3450">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3451">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3451">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3452">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3452">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3453">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3453">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3454">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3454">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3455">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de resta, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3455">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3456">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3456">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3457">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3457">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3458">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3458">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3459">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3459">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3460">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3460">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3461">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3461">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3462">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3462">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3463">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3463">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3464">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3464">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3465">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3465">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3466">El tipo del nodo es el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3466">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="60e59-3467">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3467">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3468">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3468">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3469">En el ejemplo de código siguiente se muestra cómo crear una expresión que resta el argumento del primer argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3469">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3470">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3470"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3471">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3471">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3472">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3472">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3473">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3473">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3474">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3474">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3475">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3475">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3476"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3476">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3477">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3477">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3478">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3478">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3479">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3479">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3480">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3480">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3481">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3481">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3482">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3482">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3483">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3483">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3484">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3484">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3485">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3485">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-3486">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de resta, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3486">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3487">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3487">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3488">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3488">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3489">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3489">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3490">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3490">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3491">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3491">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3492">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3492">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3493">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3493">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3494">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3494">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3495">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3495">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3496">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3496">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3497">El tipo del nodo es el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3497">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="60e59-3498">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3498">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3499">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3499">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3500">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3500"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3501"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3501"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3502"><paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3502"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3503">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3504">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3505">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3505">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3506">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3507"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3508">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3509">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3510">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3511">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3511">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3512"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3512">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3513">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3514">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3515">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3515">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-3516">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3516">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3517">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3518"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3519">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3520">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3521">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3521">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3522">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3523"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3524">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3525">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3526">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3527">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3527">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3528"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3528">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3529">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3530">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3531">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3531">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="60e59-3532">
          <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3532">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3533">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3534"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3535">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3536">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3536">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3537">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3537">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3538">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3538">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3539"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3539">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3540">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3540">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3541">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3541">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3542">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3542">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3543">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3543">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3544">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3544">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3545">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3545">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3546">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3546">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3547">Las siguientes reglas determinan el método de implementación seleccionado para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3547">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3548">Si el <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de resta, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3548">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3549">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3549">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3550">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3550">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3551">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3551">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3552">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3552">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3553">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3553">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3554">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3554">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3555">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3555">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3556">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3556">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3557">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3557">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3558">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3558">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3559">El tipo del nodo es el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3559">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="60e59-3560">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3560">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3561">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3561">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3562">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3562"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3563">No hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3563">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60e59-3564">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3564">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="60e59-3565">
          <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3565">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3566">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3566">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3567">Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3567">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="60e59-3568"><see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3568">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3569">Resultante <xref:System.Linq.Expressions.BinaryExpression> tiene la <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propiedad establecida en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3569">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="60e59-3570">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3570">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3571">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3571">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3572">De lo contrario, son `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3572">Otherwise, they are `false`.</span></span> <span data-ttu-id="60e59-3573">La propiedad <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3573">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="60e59-3574">La siguiente información describe el método de implementación, el tipo de nodo, y si se eleva un nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3574">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3575">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3575">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3576">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3576">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="60e59-3577">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma dos argumentos, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3577">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-3578">De lo contrario, si la <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del `left` o `right` representa un tipo definido por el usuario que sobrecarga el operador de resta, la <xref:System.Reflection.MethodInfo> que representa ese método es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3578">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3579">De lo contrario, si `left`. Tipo y `right`. Type son tipos numéricos, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3579">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3580">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3580">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3581">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3581">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3582">If `left`. Tipo y `right`. Tipo son asignables a los correspondientes tipos de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3582">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3583">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3583">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3584">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3584">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3585">`left`. Tipo y `right`. Tipo son ambos tipos de valor de los cuales al menos uno acepta valores NULL y los correspondientes tipos que no aceptan valores NULL son iguales a los correspondientes tipos de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3585">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3586">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3586">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3587">Si el método de implementación es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3587">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3588">If `left`. Tipo y `right`. Tipo son acepta valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3588">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3589">El tipo del nodo es el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3589">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="60e59-3590">If `left`. Tipo y `right`. Tipo son que aceptan valores NULL, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3590">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="60e59-3591">El tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de resultado del operador de resta predefinido.</span><span class="sxs-lookup"><span data-stu-id="60e59-3591">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3592">El valor de <paramref name="left" /> o <paramref name="right" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3592"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3593"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente dos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3593"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3594"><paramref name="method" /> es <see langword="null" /> y el operador de resta no está definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3594"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3595">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3595">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="60e59-3596">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3596">The value to be tested against each case.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3597">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3597">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3598">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> sin un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3598">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span></span></summary>
        <returns><span data-ttu-id="60e59-3599">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3599">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3600">Todos los <xref:System.Linq.Expressions.SwitchCase> objetos en un <xref:System.Linq.Expressions.SwitchExpression> objeto debe tener el mismo tipo, a menos que la <xref:System.Linq.Expressions.SwitchExpression> tiene el tipo de `void`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3600">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="60e59-3601">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tiene un modo implícito `break` instrucción, lo que significa que no hay ningún paso implícito de una etiqueta de caso a otro.</span><span class="sxs-lookup"><span data-stu-id="60e59-3601">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="60e59-3602">Si `switchValue` no coincide con cualquiera de los casos, se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3602">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3603">En el ejemplo siguiente se muestra cómo crear una expresión que representa una instrucción swtich sin un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3603">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="60e59-3604">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3604">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="60e59-3605">Resultado del modificador si <c>switchValue</c> no coincide con ninguno de los casos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3605">The result of the switch if <c>switchValue</c> does not match any of the cases.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3606">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3606">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3607">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3607">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="60e59-3608">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3608">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3609">Todos los <xref:System.Linq.Expressions.SwitchCase> objetos en un <xref:System.Linq.Expressions.SwitchExpression> objeto debe tener el mismo tipo, a menos que la <xref:System.Linq.Expressions.SwitchExpression> tiene el tipo de `void`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3609">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="60e59-3610">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tiene un modo implícito `break` instrucción, lo que significa que no hay ningún paso implícito de una etiqueta de caso a otro.</span><span class="sxs-lookup"><span data-stu-id="60e59-3610">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="60e59-3611">Si `switchValue` no coincide con cualquiera de los casos, el caso predeterminado representado por `defaultBody` se ejecuta.</span><span class="sxs-lookup"><span data-stu-id="60e59-3611">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3612">En el ejemplo siguiente se muestra cómo crear una expresión que representa una instrucción swtich que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3612">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="60e59-3613">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3613">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="60e59-3614">Resultado del modificador si <c>switchValue</c> no coincide con ninguno de los casos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3614">The result of the switch if <c>switchValue</c> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="60e59-3615">Método de comparación de igualdad que se va a usar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3615">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3616">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3616">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3617">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3617">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="60e59-3618">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3618">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="60e59-3619">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3619">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="60e59-3620">Resultado del modificador si <c>switchValue</c> no coincide con ninguno de los casos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3620">The result of the switch if <c>switchValue</c> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="60e59-3621">Método de comparación de igualdad que se va a usar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3621">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3622">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3622">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3623">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3623">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="60e59-3624">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3624">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3625">Tipo de resultado del modificador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3625">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="60e59-3626">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3626">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="60e59-3627">Resultado del modificador si <c>switchValue</c> no coincide con ninguno de los casos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3627">The result of the switch if <c>switchValue</c> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="60e59-3628">Método de comparación de igualdad que se va a usar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3628">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3629">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3629">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3630">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3630">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="60e59-3631">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3631">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3632">Tipo de resultado del modificador.</span><span class="sxs-lookup"><span data-stu-id="60e59-3632">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="60e59-3633">Valor que se va a probar con respecto a cada caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3633">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="60e59-3634">Resultado del modificador si <c>switchValue</c> no coincide con ninguno de los casos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3634">The result of the switch if <c>switchValue</c> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="60e59-3635">Método de comparación de igualdad que se va a usar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3635">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="60e59-3636">Conjunto de casos para esta expresión switch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3636">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3637">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción <see langword="switch" /> que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3637">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</span></span></summary>
        <returns><span data-ttu-id="60e59-3638">Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3638">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3639">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3640">Cuerpo del caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3640">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="60e59-3641">Valores de prueba del caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3641">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="60e59-3642">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3642">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
        <returns><span data-ttu-id="60e59-3643">Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3643">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3644">Todos los <xref:System.Linq.Expressions.SwitchCase> objetos en un <xref:System.Linq.Expressions.SwitchExpression> objeto debe tener el mismo tipo, a menos que la <xref:System.Linq.Expressions.SwitchExpression> tiene el tipo de `void`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3644">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="60e59-3645">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tiene un modo implícito `break` instrucción, lo que significa que no hay ningún paso implícito de una etiqueta de caso a otro.</span><span class="sxs-lookup"><span data-stu-id="60e59-3645">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3646">En el ejemplo siguiente se muestra cómo crear una expresión que representa una instrucción swtich que tiene un caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3646">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3647">Cuerpo del caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3647">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="60e59-3648">Valores de prueba del caso.</span><span class="sxs-lookup"><span data-stu-id="60e59-3648">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="60e59-3649">Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> para usarlo en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3649">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3650">Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3650">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3651">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3651">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="60e59-3652"><see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3652">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3653">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3654">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3654">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="60e59-3655"><see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3655">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="60e59-3656"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3656">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3657">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3657">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3658">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> establecidas en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3658">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="60e59-3659"><see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3659">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="60e59-3660"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3660">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="60e59-3661"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3661">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3662">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3662">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3663">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3663">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="60e59-3664"><see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3664">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="60e59-3665"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3665">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="60e59-3666"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3666">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <param name="documentType"><span data-ttu-id="60e59-3667"><see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3668">Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3668">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3669">Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> establecidas en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3669">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3670">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3670">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60e59-3671">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3671">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="60e59-3672">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
        <returns><span data-ttu-id="60e59-3673"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3673">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-3674">En el ejemplo siguiente se muestra cómo crear un <xref:System.Linq.Expressions.TryExpression> objeto que usa el <xref:System.Linq.Expressions.Expression.Throw%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60e59-3674">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60e59-3675">Una clase <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3675">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3676">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3676">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3677">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción con un tipo dado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3677">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="60e59-3678"><see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</span><span class="sxs-lookup"><span data-stu-id="60e59-3678">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60e59-3679">Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3679">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3680">Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3680">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3681">Cuerpo del bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3681">The body of the try block.</span></span></param>
        <param name="handlers"><span data-ttu-id="60e59-3682">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3682">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="60e59-3683">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault o finally.</span><span class="sxs-lookup"><span data-stu-id="60e59-3683">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span></span></summary>
        <returns><span data-ttu-id="60e59-3684">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3684">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-3685">En el ejemplo siguiente se muestra cómo crear un <xref:System.Linq.Expressions.TryExpression> objeto que contiene una instrucción catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3685">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3686">Cuerpo del bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3686">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="60e59-3687">Cuerpo del bloque finally.</span><span class="sxs-lookup"><span data-stu-id="60e59-3687">The body of the finally block.</span></span></param>
        <param name="handlers"><span data-ttu-id="60e59-3688">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3688">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="60e59-3689">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</span><span class="sxs-lookup"><span data-stu-id="60e59-3689">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span></span></summary>
        <returns><span data-ttu-id="60e59-3690">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3690">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60e59-3691">En el ejemplo siguiente se muestra cómo crear un <xref:System.Linq.Expressions.TryExpression> objeto que contiene una instrucción catch y finally (instrucción).</span><span class="sxs-lookup"><span data-stu-id="60e59-3691">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3692">Cuerpo del bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3692">The body of the try block.</span></span></param>
        <param name="fault"><span data-ttu-id="60e59-3693">Cuerpo del bloque fault.</span><span class="sxs-lookup"><span data-stu-id="60e59-3693">The body of the fault block.</span></span></param>
        <summary><span data-ttu-id="60e59-3694">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3694">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="60e59-3695">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3695">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="60e59-3696">Cuerpo del bloque try.</span><span class="sxs-lookup"><span data-stu-id="60e59-3696">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="60e59-3697">Cuerpo del bloque finally.</span><span class="sxs-lookup"><span data-stu-id="60e59-3697">The body of the finally block.</span></span></param>
        <summary><span data-ttu-id="60e59-3698">Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque finally con un bloque fault y ninguna instrucción Catch.</span><span class="sxs-lookup"><span data-stu-id="60e59-3698">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="60e59-3699">Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3699">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="60e59-3700">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</span><span class="sxs-lookup"><span data-stu-id="60e59-3700">An array of Type objects that specify the type arguments for the System.Action delegate type.</span></span></param>
        <param name="actionType"><span data-ttu-id="60e59-3701">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3701">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span></span> <span data-ttu-id="60e59-3702">Contiene null si no hay ningún delegado System.Action genérico que coincida con el objeto <c>typeArgs</c>. Este parámetro se pasa sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3702">Contains null if there is no generic System.Action delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="60e59-3703">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3703">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="60e59-3704">true si el tipo de delegado System.Action genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</span><span class="sxs-lookup"><span data-stu-id="60e59-3704">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="60e59-3705">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</span><span class="sxs-lookup"><span data-stu-id="60e59-3705">An array of Type objects that specify the type arguments for the System.Func delegate type.</span></span></param>
        <param name="funcType"><span data-ttu-id="60e59-3706">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3706">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="60e59-3707">Contiene null si no hay ningún delegado System.Func genérico que coincida con el objeto <c>typeArgs</c>. Este parámetro se pasa sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="60e59-3707">Contains null if there is no generic System.Func delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="60e59-3708">Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.</span><span class="sxs-lookup"><span data-stu-id="60e59-3708">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="60e59-3709">El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3709">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="60e59-3710">true si el tipo de delegado System.Func genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</span><span class="sxs-lookup"><span data-stu-id="60e59-3710">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60e59-3711">Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</span><span class="sxs-lookup"><span data-stu-id="60e59-3711">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span></span></summary>
        <value><span data-ttu-id="60e59-3712"><see cref="T:System.Type" /> que representa el tipo estático de la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3712">The <see cref="T:System.Type" /> that represents the static type of the expression.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3713">El <xref:System.Linq.Expressions.Expression.NodeType%2A> es el tipo del nodo de árbol de expresión, mientras que la <xref:System.Linq.Expressions.Expression.Type%2A> representa el estático tipo common language runtime (CLR) de la expresión que representa el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3713">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="60e59-3714">Por ejemplo, dos nodos con distintos tipos de nodos pueden tener el mismo <xref:System.Linq.Expressions.Expression.Type%2A>, tal y como se muestra en el ejemplo de código siguiente.</span><span class="sxs-lookup"><span data-stu-id="60e59-3714">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3715">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3715">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3716">
          <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3716">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3717">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra <see langword="null" /> si se produce un error de conversión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3717">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span></span></summary>
        <returns><span data-ttu-id="60e59-3718"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3718">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3719">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3719">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="60e59-3720">El <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> ambas propiedades están `false`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3720">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3721">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para crear un <xref:System.Linq.Expressions.UnaryExpression> que representa la conversión de referencia de una expresión de entero que no acepta valores NULL al tipo entero que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3721">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3722">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3722"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3723">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3723">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3724">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3724">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3725">Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="60e59-3725">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span></span></summary>
        <returns><span data-ttu-id="60e59-3726"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y para la que las propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3726">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3727">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3727">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3728">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3728">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3729">Crea una interfaz <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3729">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span></span></summary>
        <returns><span data-ttu-id="60e59-3730"><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para la que la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y para la que las propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> están establecidas en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3730">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3731">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> representa <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="60e59-3731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60e59-3732">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para crear un <xref:System.Linq.Expressions.TypeBinaryExpression> que representa una prueba del tipo de valor de cadena con el <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3732">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3733">El valor de <paramref name="expression" /> o <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3733"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3734">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</span><span class="sxs-lookup"><span data-stu-id="60e59-3734">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3735">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3735">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3736">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</span><span class="sxs-lookup"><span data-stu-id="60e59-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3737"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="60e59-3737">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3738">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3738">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-3739">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3739">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3740">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3740">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3741">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-3741">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3742">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3742">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3743">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3743">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3744">If `expression`. El tipo es un tipo definido por el usuario que define el operador, unario más el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3744">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3745">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3745">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3746">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3746">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3747">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3747">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3748">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3748">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3749">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3749">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3750">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3750">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3751">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3751">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3752">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3752">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3753">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3753">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-3754">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3754">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3755">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3755">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3756"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3756"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60e59-3757">No hay ningún operador unario más definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3757">The unary plus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3758">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="60e59-3759">
          <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3759">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="60e59-3760">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</span><span class="sxs-lookup"><span data-stu-id="60e59-3760">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="60e59-3761"><see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3761">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3762">El <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propiedad del resultante <xref:System.Linq.Expressions.UnaryExpression> se establece en el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3762">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="60e59-3763">El <xref:System.Linq.Expressions.Expression.Type%2A> propiedad está establecida en el tipo del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3763">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="60e59-3764">Si se eleva el nodo, el <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> y <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> ambas propiedades están `true`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3764">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="60e59-3765">En caso contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="60e59-3765">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="60e59-3766">Método de implementación</span><span class="sxs-lookup"><span data-stu-id="60e59-3766">Implementing Method</span></span>  
 <span data-ttu-id="60e59-3767">Las siguientes reglas determinan el método de implementación para la operación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3767">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="60e59-3768">Si `method` no `null` y representa un distinto de void, `static` (`Shared` en Visual Basic) método que toma un argumento, es el método de implementación para el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3768">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="60e59-3769">If `expression`. El tipo es un tipo definido por el usuario que define el operador, unario más el <xref:System.Reflection.MethodInfo> que representa que operador es el método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3769">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3770">De lo contrario, si `expression`. Type es un tipo numérico, el método de implementación es `null`.</span><span class="sxs-lookup"><span data-stu-id="60e59-3770">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="60e59-3771">Tipo de nodo y elevado en contraposición a no elevado</span><span class="sxs-lookup"><span data-stu-id="60e59-3771">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="60e59-3772">Si el método de implementación no es `null`:</span><span class="sxs-lookup"><span data-stu-id="60e59-3772">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="60e59-3773">If `expression`. El tipo es asignable al tipo de argumento del método de implementación, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3773">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="60e59-3774">El tipo del nodo es el tipo de valor devuelto del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3774">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="60e59-3775">Si se cumplen las dos condiciones siguientes, se eleva el nodo y el tipo del nodo es el tipo que acepta valores null que se corresponde con el tipo de valor devuelto del método de implementación:</span><span class="sxs-lookup"><span data-stu-id="60e59-3775">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="60e59-3776">`expression`. El tipo es un tipo de valor que aceptan valores NULL y el tipo de valor no acepta valores NULL correspondiente es igual al tipo de argumento del método de implementación.</span><span class="sxs-lookup"><span data-stu-id="60e59-3776">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="60e59-3777">El tipo de valor devuelto del método de implementación es un tipo de valor no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="60e59-3777">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="60e59-3778">Si el método de implementación es `null`, el tipo del nodo es `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3778">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="60e59-3779">If `expression`. El tipo es que no aceptan valores NULL, no se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3779">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="60e59-3780">En caso contrario, se eleva el nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3780">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="60e59-3781"><paramref name="expression" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3781"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60e59-3782"><paramref name="method" /> no es <see langword="null" /> y el método que representa devuelve <see langword="void" />, no es <see langword="static" /> (<see langword="Shared" /> en Visual Basic) o no toma exactamente un argumento.</span><span class="sxs-lookup"><span data-stu-id="60e59-3782"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="60e59-3783"><paramref name="method" /> es <see langword="null" /> y no hay ningún operador unario más definido para <paramref name="expression" />.Type.</span><span class="sxs-lookup"><span data-stu-id="60e59-3783"><paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
 <span data-ttu-id="60e59-3784">O bien</span><span class="sxs-lookup"><span data-stu-id="60e59-3784">-or-</span></span>  
  
 <span data-ttu-id="60e59-3785"><paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores null si se trata de un tipo de valor que acepta valores null) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3785"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="60e59-3786">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</span><span class="sxs-lookup"><span data-stu-id="60e59-3786">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span></span></param>
        <param name="type"><span data-ttu-id="60e59-3787">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3787">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="60e59-3788">Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</span><span class="sxs-lookup"><span data-stu-id="60e59-3788">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span></span></summary>
        <returns><span data-ttu-id="60e59-3789">Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3789">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60e59-3790">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3790">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3791">Tipo del parámetro o variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-3791">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="60e59-3792">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="60e59-3793">Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3793">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60e59-3794">Tipo del parámetro o variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-3794">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="60e59-3795">Nombre del parámetro o la variable.</span><span class="sxs-lookup"><span data-stu-id="60e59-3795">The name of the parameter or variable.</span></span> <span data-ttu-id="60e59-3796">Este nombre se emplea únicamente para depurar o imprimir.</span><span class="sxs-lookup"><span data-stu-id="60e59-3796">This name is used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="60e59-3797">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="60e59-3797">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="60e59-3798">Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3798">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="60e59-3799">Instancia de <see cref="T:System.Func`2" />.</span><span class="sxs-lookup"><span data-stu-id="60e59-3799">An instance of <see cref="T:System.Func`2" />.</span></span></param>
        <summary><span data-ttu-id="60e59-3800">Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida.</span><span class="sxs-lookup"><span data-stu-id="60e59-3800">Reduces the node and then calls the visitor delegate on the reduced expression.</span></span> <span data-ttu-id="60e59-3801">El método inicia una excepción si el nodo no es reducible.</span><span class="sxs-lookup"><span data-stu-id="60e59-3801">The method throws an exception if the node is not reducible.</span></span></summary>
        <returns><span data-ttu-id="60e59-3802">Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</span><span class="sxs-lookup"><span data-stu-id="60e59-3802">The expression being visited, or an expression which should replace it in the tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60e59-3803">Invalide este método para proporcionar lógica para recorrer los elementos secundarios del nodo.</span><span class="sxs-lookup"><span data-stu-id="60e59-3803">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="60e59-3804">Una implementación típica llamará al visitante. Visite en cada uno de sus elementos secundarios, y si alguno de ellos cambia, debe devolver una nueva copia de sí mismo con los elementos secundarios modificados.</span><span class="sxs-lookup"><span data-stu-id="60e59-3804">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>