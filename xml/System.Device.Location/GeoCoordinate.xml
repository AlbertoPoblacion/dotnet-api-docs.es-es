<Type Name="GeoCoordinate" FullName="System.Device.Location.GeoCoordinate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c06b1f703044283a51029efd8efeec2fe8255e5c" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58549789" /></Metadata><TypeSignature Language="C#" Value="public class GeoCoordinate : IEquatable&lt;System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GeoCoordinate extends System.Object implements class System.IEquatable`1&lt;class System.Device.Location.GeoCoordinate&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Device.Location.GeoCoordinate" />
  <TypeSignature Language="VB.NET" Value="Public Class GeoCoordinate&#xA;Implements IEquatable(Of GeoCoordinate)" />
  <TypeSignature Language="C++ CLI" Value="public ref class GeoCoordinate : IEquatable&lt;System::Device::Location::GeoCoordinate ^&gt;" />
  <TypeSignature Language="F#" Value="type GeoCoordinate = class&#xA;    interface IEquatable&lt;GeoCoordinate&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Device</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Device.Location.GeoCoordinate&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una ubicación geográfica que se determina a través de las coordenadas de latitud y longitud. También puede incluir información sobre la altitud, la exactitud, la velocidad y el rumbo.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Device.Location.GeoCoordinate." />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Device.Location.GeoCoordinate" /> sin ningún campo de datos establecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los campos de datos se establecen en <xref:System.Double.NaN>.  La nueva instancia de <xref:System.Device.Location.GeoCoordinate> es equivalente a <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
 Este constructor debe usarse para la serialización.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitud de la ubicación. Puede oscilar entre -90.0 y 90.0.</param>
        <param name="longitude">Longitud de la ubicación. Puede oscilar entre -180.0 y 180.0.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Device.Location.GeoCoordinate" /> a partir de datos de latitud y longitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de latitud y longitud deben corresponder a una ubicación en el mundo real.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Latitud o longitud fuera del intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitud. Puede oscilar entre -90.0 y 90.0.</param>
        <param name="longitude">Longitud. Puede oscilar entre -180.0 y 180.0.</param>
        <param name="altitude">Altitud en metros. Su valor puede ser negativo, 0, positivo o <see cref="F:System.Double.NaN" /> si es desconocido.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Device.Location.GeoCoordinate" /> a partir de datos de latitud, longitud y altitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de latitud y longitud deben corresponder a una ubicación en el mundo real.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" /> o <paramref name="altitude" /> está fuera del intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GeoCoordinate (double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 latitude, float64 longitude, float64 altitude, float64 horizontalAccuracy, float64 verticalAccuracy, float64 speed, float64 course) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (latitude As Double, longitude As Double, altitude As Double, horizontalAccuracy As Double, verticalAccuracy As Double, speed As Double, course As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GeoCoordinate(double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy, double speed, double course);" />
      <MemberSignature Language="F#" Value="new System.Device.Location.GeoCoordinate : double * double * double * double * double * double * double -&gt; System.Device.Location.GeoCoordinate" Usage="new System.Device.Location.GeoCoordinate (latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy, speed, course)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="latitude" Type="System.Double" />
        <Parameter Name="longitude" Type="System.Double" />
        <Parameter Name="altitude" Type="System.Double" />
        <Parameter Name="horizontalAccuracy" Type="System.Double" />
        <Parameter Name="verticalAccuracy" Type="System.Double" />
        <Parameter Name="speed" Type="System.Double" />
        <Parameter Name="course" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="latitude">Latitud de la ubicación. Puede oscilar entre -90.0 y 90.0.</param>
        <param name="longitude">Longitud de la ubicación. Puede oscilar entre -180.0 y 180.0.</param>
        <param name="altitude">Altitud en metros. Su valor puede ser negativo, 0, positivo o <see cref="F:System.Double.NaN" /> si es desconocido.</param>
        <param name="horizontalAccuracy">Exactitud de las coordenadas de latitud y longitud, en metros. Debe ser mayor o igual que 0. Si se proporciona el valor 0 a este constructor, la propiedad <see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" /> se establecerá en <see cref="F:System.Double.NaN" />.</param>
        <param name="verticalAccuracy">Exactitud de la altitud, en metros. Debe ser mayor o igual que 0. Si se proporciona el valor 0 a este constructor, la propiedad <see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" /> se establecerá en <see cref="F:System.Double.NaN" />.</param>
        <param name="speed">Velocidad medida en metros por segundo. Su valor puede ser negativo, 0, positivo o <see cref="F:System.Double.NaN" /> si es desconocido.  Una velocidad negativa puede indicar un movimiento marcha atrás.</param>
        <param name="course">Dirección de viaje, en lugar de la orientación. Este parámetro se mide en grados relativos al norte verdadero. Debe oscilar entre 0 y 360.0 o ser <see cref="F:System.Double.NaN" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Device.Location.GeoCoordinate" /> a partir de la latitud, longitud, altitud, exactitud horizontal, exactitud vertical, velocidad y rumbo.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="latitude" />, <paramref name="longitude" />, <paramref name="horizontalAccuracy" />, <paramref name="verticalAccuracy," /> o <paramref name="course" /> está fuera del intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Altitude">
      <MemberSignature Language="C#" Value="public double Altitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Altitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Altitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Altitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Altitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Altitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Altitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la altitud del objeto <see cref="T:System.Device.Location.GeoCoordinate" />, en metros.</summary>
        <value>Altitud, en metros.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La altitud se da en relación con el nivel del mar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Course">
      <MemberSignature Language="C#" Value="public double Course { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Course" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Course" />
      <MemberSignature Language="VB.NET" Value="Public Property Course As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Course { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Course : double with get, set" Usage="System.Device.Location.GeoCoordinate.Course" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la dirección en grados, con respecto al norte verdadero.</summary>
        <value>Dirección en grados con respecto al norte verdadero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El intervalo válido incluye los valores de 0,0 a 360,0, y `Double.NaN` si el encabezado no está definido.  
  
   
  
## Examples  
 El ejemplo siguiente imprime la <xref:System.Device.Location.GeoCoordinate.Course%2A> y <xref:System.Device.Location.GeoCoordinate.Speed%2A> propiedades de la ubicación actual <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Course" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos objetos <see cref="T:System.Device.Location.GeoCoordinate" /> son equivalentes, basándose solamente en la latitud y la longitud.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Device.Location.GeoCoordinate -&gt; bool" Usage="geoCoordinate.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other">Objeto <see cref="T:System.Device.Location.GeoCoordinate" /> que se va a comparar con el objeto llamador.</param>
        <summary>Determina si el objeto <see cref="T:System.Device.Location.GeoCoordinate" /> es equivalente al parámetro, basándose solamente en la latitud y la longitud.</summary>
        <returns>Es <see langword="true" /> si los objetos <see cref="T:System.Device.Location.GeoCoordinate" /> son iguales; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Equivalente <xref:System.Device.Location.GeoCoordinate> objetos tienen el mismo <xref:System.Device.Location.GeoCoordinate.Latitude%2A> y <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propiedades. El <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, y <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propiedades no se utilizan para determinar la equivalencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="geoCoordinate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto con el que se va a comparar el objeto <see cref="T:System.Device.Location.GeoCoordinate" />.</param>
        <summary>Determina si un objeto <see cref="T:System.Device.Location.GeoCoordinate" /> especificado es igual al objeto <see cref="T:System.Device.Location.GeoCoordinate" /> actual, basándose solamente en la latitud y la longitud.</summary>
        <returns>Es <see langword="true" /> si los objetos <see cref="T:System.Device.Location.GeoCoordinate" /> son iguales; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Equivalente <xref:System.Device.Location.GeoCoordinate> objetos tienen el mismo <xref:System.Device.Location.GeoCoordinate.Latitude%2A> y <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propiedades. El <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, y <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propiedades no se utilizan para determinar la equivalencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDistanceTo">
      <MemberSignature Language="C#" Value="public double GetDistanceTo (System.Device.Location.GeoCoordinate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDistanceTo(class System.Device.Location.GeoCoordinate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetDistanceTo(System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDistanceTo (other As GeoCoordinate) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDistanceTo(System::Device::Location::GeoCoordinate ^ other);" />
      <MemberSignature Language="F#" Value="member this.GetDistanceTo : System.Device.Location.GeoCoordinate -&gt; double" Usage="geoCoordinate.GetDistanceTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="other">Objeto <see cref="T:System.Device.Location.GeoCoordinate" /> de la ubicación con respecto a la cual se va a calcular la distancia.</param>
        <summary>Devuelve la distancia entre las coordenadas de latitud y longitud especificadas por este objeto <see cref="T:System.Device.Location.GeoCoordinate" /> y las especificadas por otro objeto <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <returns>Distancia entre las coordenadas de las dos ubicaciones, en metros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fórmula Haversine se usa para calcular la distancia.  La fórmula Haversine cuentas para la curvatura de la tierra, pero supone una tierra esférica en lugar de como un elipsoide. Para grandes distancias, la fórmula Haversine presenta un error de menor que 0,1 por ciento.  
  
 Altitud No se usa para calcular la distancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="geoCoordinate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sirve como función hash para <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <returns>Código hash para el objeto <see cref="T:System.Device.Location.GeoCoordinate" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Device.Location.GeoCoordinate> objetos que son equivalentes tienen el mismo código hash. Equivalente <xref:System.Device.Location.GeoCoordinate> objetos tienen el mismo <xref:System.Device.Location.GeoCoordinate.Latitude%2A> y <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propiedades. El <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, y <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propiedades no se utilizan para determinar la equivalencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAccuracy">
      <MemberSignature Language="C#" Value="public double HorizontalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.HorizontalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la exactitud de la latitud y longitud proporcionadas por el objeto <see cref="T:System.Device.Location.GeoCoordinate" />, en metros.</summary>
        <value>Exactitud de la latitud y longitud, en metros.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La precisión se puede considerar el radio de la seguridad de los datos de latitud y longitud.  Un área circular que se forma con la misma precisión que las coordenadas de radius y la latitud y longitud que el centro contiene la ubicación real.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.HorizontalAccuracy" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Device.Location.GeoCoordinate.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Device.Location.GeoCoordinate" /> no contiene datos de latitud o longitud.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Device.Location.GeoCoordinate" /> no contiene datos de latitud o longitud; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Device.Location.GeoCoordinate> que no contiene latitud o longitud es igual a <xref:System.Device.Location.GeoCoordinate.Unknown>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se comprueba si el <xref:System.Device.Location.GeoCoordinate> que corresponde a una ubicación es <xref:System.Device.Location.GeoCoordinate.Unknown> antes de imprimir su latitud y longitud.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Latitude">
      <MemberSignature Language="C#" Value="public double Latitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Latitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Latitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Latitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Latitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Latitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Latitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la latitud de <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <value>Latitud de la ubicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Latitud puede oscilar entre -90,0 y 90,0. Latitud se mide en grados Norte o sur desde el Ecuador. Los valores positivos están al norte del Ecuador y los valores negativos están al sur del Ecuador.  
  
   
  
## Examples  
 El ejemplo siguiente imprime los valores de latitud y longitud que se obtienen de un <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Latitude" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Longitude">
      <MemberSignature Language="C#" Value="public double Longitude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Longitude" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Longitude" />
      <MemberSignature Language="VB.NET" Value="Public Property Longitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Longitude { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Longitude : double with get, set" Usage="System.Device.Location.GeoCoordinate.Longitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud de <see cref="T:System.Device.Location.GeoCoordinate" />.</summary>
        <value>Longitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud puede oscilar entre -180,0 y 180.0. Longitud se mide en grados este u oeste del meridiano. Los valores negativos están al oeste del meridiano y los valores positivos están al este del meridiano.  
  
   
  
## Examples  
 El ejemplo siguiente imprime los valores de latitud y longitud que se obtienen de un <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.LocationEvent1#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.locationevent1/cs/locationevent.cs#1)]
 [!code-vb[System.Device.Location.LocationEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.locationevent1/vb/locationevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Longitude" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Equality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto <see cref="T:System.Device.Location.GeoCoordinate" /> que se va a comparar.</param>
        <param name="right">Segundo objeto <see cref="T:System.Device.Location.GeoCoordinate" /> que se va a comparar.</param>
        <summary>Determina si dos objetos <see cref="T:System.Device.Location.GeoCoordinate" /> hacen referencia a la misma ubicación.</summary>
        <returns>Es <see langword="true" /> si los objetos <see cref="T:System.Device.Location.GeoCoordinate" /> son equivalentes; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Equivalente <xref:System.Device.Location.GeoCoordinate> objetos tienen el mismo <xref:System.Device.Location.GeoCoordinate.Latitude%2A> y <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propiedades. El <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, y <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propiedades no se utilizan para determinar la equivalencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Device.Location.GeoCoordinate left, System.Device.Location.GeoCoordinate right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Device.Location.GeoCoordinate left, class System.Device.Location.GeoCoordinate right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.op_Inequality(System.Device.Location.GeoCoordinate,System.Device.Location.GeoCoordinate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As GeoCoordinate, right As GeoCoordinate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Device::Location::GeoCoordinate ^ left, System::Device::Location::GeoCoordinate ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Device.Location.GeoCoordinate * System.Device.Location.GeoCoordinate -&gt; bool" Usage="System.Device.Location.GeoCoordinate.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Device.Location.GeoCoordinate" />
        <Parameter Name="right" Type="System.Device.Location.GeoCoordinate" />
      </Parameters>
      <Docs>
        <param name="left">Primer objeto <see cref="T:System.Device.Location.GeoCoordinate" /> que se va a comparar.</param>
        <param name="right">Segundo objeto <see cref="T:System.Device.Location.GeoCoordinate" /> que se va a comparar.</param>
        <summary>Determina si dos objetos <see cref="T:System.Device.Location.GeoCoordinate" /> corresponden a ubicaciones diferentes.</summary>
        <returns>Es <see langword="true" /> si los objetos <see cref="T:System.Device.Location.GeoCoordinate" /> son diferentes; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Equivalente <xref:System.Device.Location.GeoCoordinate> objetos tienen el mismo <xref:System.Device.Location.GeoCoordinate.Latitude%2A> y <xref:System.Device.Location.GeoCoordinate.Longitude%2A> propiedades. El <xref:System.Device.Location.GeoCoordinate.Altitude%2A>, <xref:System.Device.Location.GeoCoordinate.HorizontalAccuracy%2A>, y <xref:System.Device.Location.GeoCoordinate.VerticalAccuracy%2A> propiedades no se utilizan para determinar la equivalencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Speed">
      <MemberSignature Language="C#" Value="public double Speed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Speed" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.Speed" />
      <MemberSignature Language="VB.NET" Value="Public Property Speed As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Speed { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Speed : double with get, set" Usage="System.Device.Location.GeoCoordinate.Speed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la velocidad en metros por segundo.</summary>
        <value>La velocidad en metros por segundo. La velocidad debe ser mayor o igual a cero, o <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente imprime la <xref:System.Device.Location.GeoCoordinate.Course%2A> y <xref:System.Device.Location.GeoCoordinate.Speed%2A> propiedades de la ubicación actual <xref:System.Device.Location.GeoCoordinate>.  
  
 [!code-csharp[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.courseandspeed/cs/courseandspeed.cs#2)]
 [!code-vb[System.Device.Location.CourseAndSpeed#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.courseandspeed/vb/courseandspeed.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.Speed" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Device.Location.GeoCoordinate.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="geoCoordinate.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que contiene la latitud y la longitud.</summary>
        <returns>Cadena que contiene la latitud y la longitud, separadas por una coma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de cadena devuelta por este método está pensada únicamente para depuración. Este método no devuelve ningún formato específico de la configuración regional para latitud y longitud.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unknown">
      <MemberSignature Language="C#" Value="public static readonly System.Device.Location.GeoCoordinate Unknown;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Device.Location.GeoCoordinate Unknown" />
      <MemberSignature Language="DocId" Value="F:System.Device.Location.GeoCoordinate.Unknown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unknown As GeoCoordinate " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Device::Location::GeoCoordinate ^ Unknown;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unknown : System.Device.Location.GeoCoordinate" Usage="System.Device.Location.GeoCoordinate.Unknown" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Device.Location.GeoCoordinate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa un objeto <see cref="T:System.Device.Location.GeoCoordinate" /> con campos desconocidos de latitud y longitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Device.Location.GeoCoordinate.IsUnknown%2A> propiedad puede usarse para comprobar si un <xref:System.Device.Location.GeoCoordinate> no contiene ningún dato.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se comprueba si el <xref:System.Device.Location.GeoCoordinate> que corresponde a una ubicación es <xref:System.Device.Location.GeoCoordinate.Unknown> antes de imprimir su latitud y longitud.  
  
 [!code-csharp[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/cs/getlocationdatasynchandleunknown.cs#1)]
 [!code-vb[System.Device.Location.GetLocationDataSyncHandleUnknown#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.device.location.getlocationdatasynchandleunknown/vb/GetLocationDataSyncHandleUnknown.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAccuracy">
      <MemberSignature Language="C#" Value="public double VerticalAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalAccuracy" />
      <MemberSignature Language="DocId" Value="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAccuracy As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalAccuracy { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAccuracy : double with get, set" Usage="System.Device.Location.GeoCoordinate.VerticalAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Device</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la exactitud de la altitud proporcionada por el objeto <see cref="T:System.Device.Location.GeoCoordinate" />, en metros.</summary>
        <value>Exactitud de la altitud, en metros.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Device.Location.GeoCoordinate.VerticalAccuracy" /> está fuera del intervalo válido.</exception>
      </Docs>
    </Member>
  </Members>
</Type>