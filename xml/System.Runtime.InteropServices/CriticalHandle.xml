<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56d9d023a154981435b37666fa081861ca0100c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480149" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una clase contenedora para los recursos de identificador.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.InteropServices.CriticalHandle> clase es similar a la <xref:System.Runtime.InteropServices.SafeHandle> (clase), salvo que <xref:System.Runtime.InteropServices.SafeHandle> implementa el recuento de referencias. Puede usar <xref:System.Runtime.InteropServices.CriticalHandle> en lugar de <xref:System.Runtime.InteropServices.SafeHandle> las consideraciones de rendimiento de dirección cuando puede proporcionar la sincronización necesaria más eficazmente por sí mismo.  
  
 Dado que la <xref:System.Runtime.InteropServices.CriticalHandle> clase no realiza el recuento de referencias, no proporciona protección contra ataques de seguridad por reciclaje de identificadores. Porque la referencia del algoritmo de recuento implícitamente serializa las operaciones, también se pierde una cierta cantidad de seguridad para subprocesos. Si se llama a la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método mientras una operación que esté utilizando el identificador está pendiente en otro subproceso, o si se llama a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> de dos subprocesos al mismo tiempo, los resultados no son deterministas. El <xref:System.Runtime.InteropServices.CriticalHandle> clase sigue ofreciendo la finalización crítica garantizada proporcionada por la <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> clase.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Esta clase no puede ser usada por código de confianza parcial o transparente.</permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valor de un identificador no válido (normalmente 0 ó -1).</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> con el valor de identificador no válido especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">La clase derivada reside en un ensamblado sin el permiso de acceso a código no administrado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Esta clase no puede ser usada por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca el identificador para soltar y liberar recursos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que se liberen los recursos. A diferencia de la <xref:System.Runtime.InteropServices.SafeHandle> de la clase, siempre se realizará inmediatamente porque no hay ningún recuento de referencias para indicar que otros subprocesos están utilizando este identificador. Por consiguiente, debe emplear un mecanismo de sincronización para asegurarse de que es seguro llamar a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método. Aunque la mayoría de las clases que usan el <xref:System.Runtime.InteropServices.CriticalHandle> no es necesario que la clase proporciona un finalizador, esto a veces es necesario (por ejemplo, para vaciar los búferes de archivos o para escribir algunos datos de nuevo en memoria). En este caso, la clase puede proporcionar un finalizador que se garantiza la ejecución antes de la <xref:System.Runtime.InteropServices.CriticalHandle> ejecute finalizador crítico.  
  
 Llame a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método cuando haya terminado con el <xref:System.Runtime.InteropServices.CriticalHandle> objeto. El <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deja la <xref:System.Runtime.InteropServices.CriticalHandle> objeto en un estado no utilizable.  
  
 **Tenga en cuenta** llamada siempre <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> antes de liberar la última referencia a la <xref:System.Runtime.InteropServices.CriticalHandle> objeto. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Runtime.InteropServices.CriticalHandle> del objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Marca el identificador para soltar y liberar recursos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que se liberen los recursos. A diferencia de la <xref:System.Runtime.InteropServices.SafeHandle> de la clase, siempre se realizará inmediatamente porque no hay ningún recuento de referencias para indicar que otros subprocesos están utilizando este identificador. Por consiguiente, debe emplear un mecanismo de sincronización para asegurarse de que es seguro llamar a la <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método. Aunque la mayoría de las clases que usan el <xref:System.Runtime.InteropServices.CriticalHandle> no es necesario que la clase proporciona un finalizador, esto a veces es necesario (por ejemplo, para vaciar los búferes de archivos o para escribir algunos datos de nuevo en memoria). En este caso, la clase puede proporcionar un finalizador que se garantiza la ejecución antes de la <xref:System.Runtime.InteropServices.CriticalHandle> ejecute finalizador crítico.  
  
 Llame a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método cuando haya terminado con el <xref:System.Runtime.InteropServices.CriticalHandle> objeto. El <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deja la <xref:System.Runtime.InteropServices.CriticalHandle> objeto en un estado no utilizable.  
  
 **Tenga en cuenta** llamada siempre la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método antes de liberar la última referencia a la <xref:System.Runtime.InteropServices.CriticalHandle> objeto. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Runtime.InteropServices.CriticalHandle> del objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para una operación de desecho normal; <see langword="false" /> para finalizar el identificador.</param>
        <summary>Libera los recursos no administrados utilizados por la clase <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> que especifica si se va a realizar una operación de desecho normal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nunca debería llamar explícitamente la <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método con el `disposing` parámetro establecido en `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos asociados al identificador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método es el destructor para la <xref:System.Runtime.InteropServices.CriticalHandle> clase. Código de la aplicación no debe llamar directamente a este método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica el identificador que se va a ajustar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No exponer públicamente el identificador (es decir, fuera de la clase derivada).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el identificador está cerrado.</summary>
        <value>
          <see langword="true" /> si el identificador está cerrado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método devuelve un valor que indica si la <xref:System.Runtime.InteropServices.CriticalHandle> identificador del objeto ya no está asociado a un recurso nativo. Esto difiere de la definición de la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propiedad, que calcula si un identificador determinado siempre se considera no válido. El <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método devuelve un `true` valor en los casos siguientes:  
  
-   El <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método se llamó.  
  
-   El <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método se llamó y no hay ninguna referencia a la <xref:System.Runtime.InteropServices.CriticalHandle> objeto en otros subprocesos.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene un valor que indica si este identificador es no válido.</summary>
        <value>
          <see langword="true" /> si el identificador es válido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas deben implementar la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propiedad para que common language runtime puede determinar si se requiere la finalización crítica. Las clases derivadas deben proporcionar una implementación que se ajuste al tipo general de identificador que admiten (0 ó -1 no es válido). Estas clases, a continuación, se pueden derivar de tipos de identificadores seguros concretos.  
  
 A diferencia de la <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> propiedad, que informa de si la <xref:System.Runtime.InteropServices.CriticalHandle> objeto ha finalizado con el identificador subyacente, la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propiedad calcula si el valor de identificador especificado siempre se considera no válido. Por lo tanto, la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propiedad siempre devuelve el mismo valor para cualquier valor de identificador.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, ejecuta el código necesario para liberar el identificador.</summary>
        <returns>
          <see langword="true" /> si el identificador se libera correctamente; en caso contrario, si se produce un error grave, <see langword="false" />. En este caso, genera un Asistente para depuración administrada [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método se garantiza que se llame solo una vez, siempre que se emplean mecanismos de sincronización correcta para garantizar que sólo una llamada a la <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> se realiza el método. El <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método no se llamará si la <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> o <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> propiedad es `true`. Implemente este método en su <xref:System.Runtime.InteropServices.CriticalHandle> sus clases derivadas para ejecutar cualquier código que es necesario para liberar el identificador. Dado que una de las funciones de <xref:System.Runtime.InteropServices.CriticalHandle> es garantizar la prevención de pérdidas de recursos, el código en la implementación de <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> nunca debe producir un error. El recolector de elementos no utilizados llame <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> después de que se han ejecutado los finalizadores normales para objetos que se recolectan al mismo tiempo, y garantiza que los recursos necesarios para invocar y que no se interrumpirá mientras se está en curso. Este método se prepararán como una región de ejecución restringida (CER) en el momento de construcción de la instancia (junto con todos los métodos en su gráfico de llamadas determinable estáticamente). Aunque esto evita las interrupciones de anulación de subproceso, aún debe procurar no introducir las rutas de acceso de error en su invalidado <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método. En particular, aplique el <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo de cualquier método que se llame desde <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. En la mayoría de los casos este código debería ser:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Además, para la limpieza sencilla (por ejemplo, al llamar a la API de Win32 `CloseHandle` en un identificador de archivo) puede comprobar el valor devuelto de la llamada de invocación de plataforma única. Para la limpieza compleja, habrá una gran cantidad de lógica del programa y muchas llamadas a métodos, algunos de los cuales pueden producir un error. Debe asegurarse de que la lógica del programa con código de reserva para cada uno de los casos.  
  
 Si el <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método `false` por cualquier motivo, genera un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Ayudante de depuración administrada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">El identificador preexistente que se va a utilizar.</param>
        <summary>Establece el identificador en el identificador preexistente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método sólo si tiene que proporcionar compatibilidad con un identificador preexistente (por ejemplo, si se devuelve el identificador en una estructura) dado que la infraestructura de interoperabilidad COM de .NET Framework no admite la serialización se controla en una estructura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca un identificador como no válido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método solo cuando sepa que el identificador no es válido y desea marcarlo como tal. Si lo hace, no cambia el valor de la <xref:System.Runtime.InteropServices.CriticalHandle.handle> campo; solo marca el identificador como no válido. El identificador podría contener entonces un valor potencialmente obsoleto. El efecto de esta llamada es que se realiza ningún intento para liberar los recursos.  
  
 Al igual que con la <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> sólo si tiene que proporcionar compatibilidad con un identificador preexistente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>