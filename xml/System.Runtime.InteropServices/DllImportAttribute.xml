<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e5ad390ef6e55e1305d31c7f58b06c4d1ec9c02b" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39828261" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica que una biblioteca de vínculos dinámicos (DLL) no administrada expone el método con atributos como un punto de entrada estático.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este atributo se puede aplicar a métodos.  
  
 El <xref:System.Runtime.InteropServices.DllImportAttribute> atributo proporciona la información necesaria para llamar a una función exportada desde una DLL no administrada. Como requisito mínimo, debe proporcionar el nombre del archivo DLL que contiene el punto de entrada.  
  
 Aplique este atributo directamente en C# y las definiciones de método de C++; Sin embargo, el compilador de Visual Basic emite este atributo cuando se usa el `Declare` instrucción. Para obtener definiciones de método complejo que incluyen <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos, aplique este atributo directamente a las definiciones de método de Visual Basic.  
  
 **Tenga en cuenta** JScript no admite este atributo. Puede usar C# o clases contenedoras de Visual Basic para tener acceso a los métodos de API no administrados desde programas de JScript.  
  
 Para obtener más información sobre el uso de la plataforma de invocación de servicio para las funciones de acceso de DLL no administradas, vea [consumir funciones de DLL no administradas](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  El <xref:System.Runtime.InteropServices.DllImportAttribute> no admite la serialización de tipos genéricos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Runtime.InteropServices.DllImportAttribute> atributo importar Win32 `MessageBox` función.  El ejemplo de código, a continuación, llama al método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nombre del archivo DLL que contiene el método no administrado. Puede incluir un nombre para mostrar del ensamblado, si el archivo DLL está incluido en un ensamblado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> con el nombre del archivo DLL que contiene el método que se va a importar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un archivo DLL no administrado se incluye en un ensamblado, por ejemplo, mediante el vinculador o el `/linkresource` opción del compilador, puede especificar el nombre para mostrar del ensamblado como parte de `dllName`. Por ejemplo, si una DLL no administrada denominada `unmanaged.dll` se incluye en un ensamblado administrado denominado `MyAssembly`, el atributo puede especificarse como se muestra en el código siguiente.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Runtime.InteropServices.DllImportAttribute> atributo importar Win32 `MessageBox` función.  El ejemplo de código, a continuación, llama al método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita o deshabilita el comportamiento de asignación de ajuste perfecto al convertir caracteres Unicode en caracteres ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `true`, con ajuste perfecto comportamiento de asignación está habilitada; en caso contrario, con ajuste perfecto asignación está deshabilitada. El <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo es `true` de forma predeterminada. Los valores de este campo reemplazan los valores en cualquier nivel para el <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> atributo.  
  
 Common language runtime se convierte en caracteres ANSI que cualquier administrado caracteres Unicode que pasa a un método no administrado que se ejecute en Windows 98 o Windows Millennium Edition. Asignación con ajuste perfecto permite que el serializador de interoperabilidad proporcionar un carácter de cierre coincidentes cuando no existe ninguna coincidencia exacta. Por ejemplo, el contador de referencias convierte el carácter Unicode de copyright para 'c' para métodos no administrados que aceptan caracteres ANSI. Algunos caracteres no tienen una representación con ajuste perfecto; estos caracteres se denominan no se puede asignar. No se puede asignar caracteres normalmente se convierten en el valor predeterminado '?' Carácter ANSI.  
  
> [!CAUTION]
>  Algunos caracteres Unicode se convierten en caracteres peligrosos, como la barra diagonal inversa '\\' carácter, que puede cambiar inadvertidamente una ruta de acceso. Estableciendo el <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, puede indicar la presencia de un carácter no se puede asignar al llamador iniciando una excepción.  
  
> [!CAUTION]
>  No se puede cambiar los valores predeterminados proporcionados por el <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> y <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos cuando se pasa una matriz administrada cuyos elementos son caracteres ANSI o punteros LPSTR a una matriz segura no administrada. Asignación con ajuste perfecto siempre está habilitada y se produce ninguna excepción. Tenga en cuenta que esta combinación puede poner en peligro su modelo de seguridad.  
  
   
  
## Examples  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute>, en lugar de la `Declare` instrucción, para definir una función DLL en código administrado. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo es uno de estos casos. El ejemplo siguiente muestra cómo aplicar el más estricto definiciones de método de invocación de seguridad de la asignación de caracteres a una plataforma especificando el juego de caracteres ANSI, deshabilitando el comportamiento de asignación con ajuste perfecto y producir una excepción en los caracteres Unicode sin asignar.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la convención de llamada de un punto de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca este campo en uno de los <xref:System.Runtime.InteropServices.CallingConvention> miembros de la enumeración. El valor predeterminado para el <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo es <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, que a su vez de forma predeterminada <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convención.  
  
 Para obtener más información, vea la convención de llamada en MSDN library.  
  
   
  
## Examples  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute>, en lugar de la `Declare` instrucción, para definir una función DLL en código administrado. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo es uno de estos casos.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica la forma de calcular las referencias de los parámetros de cadena al método, y controla los daños en los nombres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este campo con un miembro de la <xref:System.Runtime.InteropServices.CharSet> enumeración para especificar el comportamiento de serialización de parámetros de cadena y para especificar qué nombre de punto de entrada para invocar (el nombre exacto especificado o un nombre termina con "A" o "W"). El miembro de enumeración predeterminado para C# y Visual Basic es `CharSet.Ansi` y es el miembro de enumeración predeterminado para C++ `CharSet.None`, que es equivalente a `CharSet.Ansi`. En Visual Basic, usa el `Declare` instrucción para especificar el `CharSet` campo.  
  
 El <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influye en el comportamiento de la `CharSet` campo determinar qué nombre de punto de entrada va a invocar. Para obtener una descripción detallada y ejemplos de la serialización de cadenas y el nombre que coincida con el comportamiento asociado con el `CharSet` campo, vea [especificar un juego de caracteres](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Runtime.InteropServices.DllImportAttribute> atributo importar Win32 `MessageBox` función.  El ejemplo de código, a continuación, llama al método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica el nombre u ordinal del punto de entrada de la DLL al que se va a llamar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar el nombre del punto de entrada proporcionando una cadena que indica el nombre del archivo DLL que contiene el punto de entrada, o puede identificar el punto de entrada por su ordinal. Los ordinales van precedidos del signo #, por ejemplo, #1. Si se omite este campo, common language runtime usa el nombre del método de.NET marcado con el <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Para obtener más información, consulte [identificar funciones en archivos DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Para obtener ejemplos que muestran cómo utilizar el <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, vea [especificando un punto de entrada](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Runtime.InteropServices.DllImportAttribute> atributo importar Win32 `MessageBox` función.  El ejemplo de código se usa el <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> propiedad para especificar la función para importar y, a continuación, cambia el nombre a `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controla si el campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> hace que Common Language Runtime busque en un archivo DLL no administrado nombres de puntos de entrada distintos del especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `false`, se invoca el nombre del punto de entrada anexado por la letra A cuando el <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo se establece en `CharSet.Ansi`, y el nombre de punto de entrada anexado con la letra W se invoca cuando el <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo se establece en el `CharSet.Unicode`. Normalmente, los compiladores administrados establecen este campo.  
  
 En la tabla siguiente se muestra la relación entre el <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> y <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campos, basándose en los valores predeterminados impuestos por el lenguaje de programación. Puede invalidar la configuración predeterminada, pero hacerlo con precaución.  
  
|Lenguaje|ANSI|Unicode|Automático|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling: = True|ExactSpelling: = True|ExactSpelling: = False|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute>, en lugar de usar el `Declare` instrucción, para definir una función DLL en código administrado. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo es uno de estos casos.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si los métodos no administrados que tienen el valor devuelto <see langword="HRESULT" /> o <see langword="retval" /> se traducen directamente o si los valores devueltos <see langword="HRESULT" /> o <see langword="retval" /> se convierten automáticamente en excepciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `true` traducir directamente firmas no administradas con `HRESULT` o `retval` valores; establézcalo como `false` para convertir automáticamente `HRESULT` o `retval` valores a las excepciones. De forma predeterminada, el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo es `true`.  
  
 Cuando `true`, la firma del método resultante devuelve un valor entero que contiene el `HRESULT` valor.  En este caso, debe inspeccionar el valor devuelto y responder según corresponda manualmente en la aplicación.  
  
 Al establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo `false`, la firma del método resultante contiene un tipo de valor devuelto void en lugar de un entero (`HRESULT`) tipo de valor devuelto.  Cuando el método no administrado produce una `HRESULT`, el tiempo de ejecución omite automáticamente un valor devuelto de `S_OK` (o 0) y no inicia una excepción.  Para `HRESULT`s distinto `S_OK`, automáticamente, el runtime produce una excepción que se corresponde con el `HRESULT`.  Tenga en cuenta que el <xref:System.Runtime.InteropServices.DllImportAttribute> atributo solo realiza esta conversión a los métodos que devuelven un `HRESULT`.  
  
 Decide cambiar el comportamiento de los informes de errores predeterminada `HRESULT`s a las excepciones en casos donde las excepciones se ajusten mejor a la estructura de la aplicación de informes de errores.  
  
 Este campo es similar a la <xref:System.Runtime.InteropServices.PreserveSigAttribute>; sin embargo, en contraposición a la <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, el valor predeterminado para el atributo es `false`.  
  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute>, en lugar de usar el `Declare` instrucción, para definir una función DLL en código administrado. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo es uno de estos casos.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Runtime.InteropServices.DllImportAttribute> a importar no administrado `SHAutoComplete` funcionar una vez con el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo establecido en `true` y luego con el <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo establecido en `false`.  Este ejemplo de código hace que el `SHAutoComplete` función para generar errores con una excepción una vez y un `HRESULT` la siguiente.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que el destinatario de la llamada llamará a la función <see langword="SetLastError" /> de la API Win32 antes de volver del método con atributos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` para indicar que el destinatario llamará `SetLastError`; en caso contrario, `false`. El valor predeterminado es `false`.  
  
 Las llamadas de contador de referencias en tiempo de ejecución `GetLastError` y almacena en caché el valor devuelto para evitar que se sobrescriban con otras llamadas API. Puede recuperar el código de error mediante una llamada a <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute>, en lugar de usar el `Declare` instrucción, para definir una función DLL en código administrado. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo es uno de estos casos.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita o deshabilita el inicio de una excepción cuando un carácter Unicode que no se puede asignar se convierte en un carácter ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` para indicar que se produce una excepción cada vez que el serializador de interoperabilidad convierte un carácter que no puede asignarse; `false` para indicar que el <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo está deshabilitado. Este campo es `false` de forma predeterminada.  
  
 Common language runtime se convierte en caracteres ANSI que cualquier administrado caracteres Unicode que pasa a un método no administrado que se ejecute en Windows 98 o Windows Millennium Edition. Asignación con ajuste perfecto permite que el serializador de interoperabilidad proporcionar un carácter de cierre coincidentes cuando no existe ninguna coincidencia exacta. Por ejemplo, el contador de referencias convierte el carácter Unicode de copyright para 'c' para métodos no administrados que aceptan caracteres ANSI. Algunos caracteres no tienen una representación con ajuste perfecto; estos caracteres se denominan no se puede asignar. No se puede asignar caracteres normalmente se convierten en el valor predeterminado '?' Carácter ANSI.  
  
> [!CAUTION]
>  Algunos caracteres Unicode se convierten en caracteres peligrosos, como la barra diagonal inversa '\\' carácter, que puede cambiar inadvertidamente una ruta de acceso. Estableciendo el <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo `true`, puede indicar la presencia de un carácter no se puede asignar al llamador iniciando una excepción.  
  
> [!CAUTION]
>  No se puede cambiar los valores predeterminados proporcionados por el <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> y <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos cuando se pasa una matriz administrada cuyos elementos son caracteres ANSI o punteros LPSTR a una matriz segura no administrada. Asignación con ajuste perfecto siempre está habilitada y se produce ninguna excepción. Tenga en cuenta que esta combinación puede poner en peligro su modelo de seguridad.  
  
   
  
## Examples  
 En algunos casos, los desarrolladores de Visual Basic utilizan la <xref:System.Runtime.InteropServices.DllImportAttribute> para definir una función DLL en código administrado, en lugar de usar el `Declare` instrucción. Establecer el <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo es uno de estos casos. El ejemplo siguiente muestra cómo aplicar el más estricto definiciones de método de invocación de seguridad de la asignación de caracteres a una plataforma especificando el juego de caracteres ANSI, deshabilitando el comportamiento de asignación con ajuste perfecto y producir una excepción en los caracteres Unicode sin asignar.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del archivo DLL que contiene el punto de entrada.</summary>
        <value>Nombre del archivo DLL que contiene el punto de entrada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede proporcionar una ruta de acceso completa o relativa. Si se proporciona ninguna ruta de acceso, el archivo DLL debe ser en la ruta de acceso actual en tiempo de ejecución, a menos que se carga el archivo DLL por otros medios. Tenga en cuenta, sin embargo, que utiliza una ruta de acceso completa puede introducir imprecisión si se mueve el archivo DLL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>