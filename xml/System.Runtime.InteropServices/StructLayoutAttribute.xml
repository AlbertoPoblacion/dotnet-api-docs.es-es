<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="StructLayoutAttribute.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac540521d9554f0cf59a81ca8f000f7fb5aa654a557.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">40521d9554f0cf59a81ca8f000f7fb5aa654a557</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Lets you control the physical layout of the data fields of a class or structure in memory.</source>
          <target state="translated">Le permite controlar el diseño físico de los campos de datos de una clase o una estructura en la memoria.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>You can apply this attribute to classes or structures.</source>
          <target state="translated">Este atributo se puede aplicar a clases o estructuras.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</source>
          <target state="translated">Common language runtime controla el diseño físico de los campos de datos de una clase o estructura en la memoria administrada.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>However, if you want to pass the type to unmanaged code, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute to control the unmanaged layout of the type.</source>
          <target state="translated">Sin embargo, si desea pasar el tipo a código no administrado, puede usar el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atributo para controlar el diseño del tipo no administrado.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> to force the members to be laid out sequentially in the order they appear.</source>
          <target state="translated">Utilizar el atributo con <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> para forzar que los miembros que se disponen secuencialmente en el orden en que aparecen.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For , <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> controls both the layout in managed memory and the layout in unmanaged memory.</source>
          <target state="translated">Para, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> controla tanto el diseño en la memoria administrada y el diseño de memoria no administrada.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</source>
          <target state="translated">Para los tipos no bits/bytes, que controla el diseño cuando la clase o estructura, se calculan las referencias a código no administrado, pero no controla el diseño en la memoria administrada.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> to control the precise position of each data member.</source>
          <target state="translated">Utilizar el atributo con <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> para controlar la posición exacta de cada miembro de datos.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>This affects both managed and unmanaged layout, for both blittable and non-blittable types.</source>
          <target state="translated">Esto afecta al diseño administrado y no administrado, para los tipos bits/bytes y no bits/bytes.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> requires that you use the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> attribute to indicate the position of each field within the type.</source>
          <target state="translated">Usar <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> requiere el uso de la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> atributo para indicar la posición de cada campo dentro del tipo.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>C#, Visual Basic, and C++ compilers apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> layout value to structures by default.</source>
          <target state="translated">Los compiladores de C#, Visual Basic y C++ aplican el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> valor de diseño a estructuras de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For classes, you must apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value explicitly.</source>
          <target state="translated">Para las clases, se debe aplicar la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> valor explícitamente.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> also applies the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute; it always applies the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value when it imports a type library.</source>
          <target state="translated">El <bpt id="p1">[</bpt>Tlbimp.exe (importador de la biblioteca de tipos)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> también se aplica el <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atributo; siempre se aplica el <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> cuando importa una biblioteca de tipos de valor.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The following example demonstrates a managed declaration of the <ph id="ph1">`GetSystemTime`</ph> function and defines <ph id="ph2">`MySystemTime`</ph> class with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> layout.</source>
          <target state="translated">En el ejemplo siguiente se muestra una declaración administrada de la <ph id="ph1">`GetSystemTime`</ph> de función y define <ph id="ph2">`MySystemTime`</ph> clase con <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> diseño.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source><ph id="ph1">`GetSystemTime`</ph> gets the system time and prints to the console.</source>
          <target state="translated"><ph id="ph1">`GetSystemTime`</ph> Obtiene la hora del sistema y se imprime en la consola.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>A 16-bit integer that represents one of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> values that specifes how the class or structure should be arranged.</source>
          <target state="translated">Entero de 16 bits que representa uno de los valores de <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> que especifica cómo debe organizarse la clase o la estructura.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> con el miembro de enumeración <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>This constructor takes an underlying 16-bit integer that represents each <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration member.</source>
          <target state="translated">Este constructor toma un entero subyacente de 16 bits que representa cada uno de ellos <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> miembro de enumeración.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> uses this constructor.</source>
          <target state="translated">El <bpt id="p1">[</bpt>Tlbimp.exe (importador de la biblioteca de tipos)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> utiliza este constructor.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>One of the enumeration values that specifes how the class or structure should be arranged.</source>
          <target state="translated">Uno de los valores de enumeración que especifica cómo debe organizarse la clase o la estructura.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> con el miembro de enumeración <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>For readable code that is less prone to error, always use this constructor.</source>
          <target state="translated">Para el código legible que es menos propenso a errores, siempre que utilice este constructor.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>Indicates whether string data fields within the class should be marshaled as <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> or <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> by default.</source>
          <target state="translated">Indica si las referencias de los campos de datos de cadena dentro de la clase deben calcularse como <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> o <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, all string arguments are converted to Unicode characters (<ph id="ph3">`LPWSTR`</ph>) before they are passed to the unmanaged implementation.</source>
          <target state="translated">Si el <ph id="ph1">`CharSet`</ph> campo está establecido en <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, todos los argumentos de cadena se convierten en caracteres Unicode (<ph id="ph3">`LPWSTR`</ph>) antes de pasarlos a la implementación no administrada.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the field is set to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, the strings are converted to ANSI strings (<ph id="ph2">`LPSTR`</ph>).</source>
          <target state="translated">Si el campo está establecido en <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, las cadenas se convierten en cadenas ANSI (<ph id="ph2">`LPSTR`</ph>).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</source>
          <target state="translated">Si el <ph id="ph1">`CharSet`</ph> campo se establece en <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, la conversión depende de la plataforma (ANSI en Windows 98 y Windows Millennium Edition y Unicode en versiones posteriores).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Controls the alignment of data fields of a class or structure in memory.</source>
          <target state="translated">Controla la alineación de los campos de datos de una clase o una estructura en la memoria.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field controls the alignment of a type's fields in memory.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> campo controla la alineación de los campos de un tipo en la memoria.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>It affects both <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Afecta a ambos <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> y <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>By default, the value is 0, indicating the default packing size for the current platform.</source>
          <target state="translated">De forma predeterminada, el valor es 0, indica que el tamaño de la plataforma actual de empaquetado predeterminado.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</source>
          <target state="translated">El valor de <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> debe ser 0, 1, 2, 4, 8, 16, 32, 64 o 128:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The fields of a type instance are aligned by using the following rules:</source>
          <target state="translated">Los campos de una instancia de tipo se alinean mediante las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</source>
          <target state="translated">La alineación del tipo es el tamaño de su elemento más grande (1, 2, 4, 8, etc., bytes) o el empaquetado especificado un tamaño, lo que sea menor.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</source>
          <target state="translated">Cada campo debe alinearse con campos de su propio tamaño (1, 2, 4, 8, etc., bytes) o la alineación del tipo, lo que sea menor.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</source>
          <target state="translated">Dado que la alineación predeterminada del tipo es el tamaño de su elemento más grande, que es mayor o igual que todas las demás longitudes de campo, esto suele significar que los campos están alineados por su tamaño.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields align on 1-byte boundaries, <ph id="ph2">&lt;xref:System.Int16&gt;</ph> fields align on 2-byte boundaries, and <ph id="ph3">&lt;xref:System.Int32&gt;</ph> fields align on 4-byte boundaries.</source>
          <target state="translated">Por ejemplo, incluso si el campo más grande en un tipo es un entero de 64 bits (8 bytes) o el campo de módulo se establece en 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> campos alineación en límites de 1 byte, <ph id="ph2">&lt;xref:System.Int16&gt;</ph> campos alineación en límites de 2 bytes, y <ph id="ph3">&lt;xref:System.Int32&gt;</ph> campos alineación en límites de 4 bytes.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Padding is added between fields to satisfy the alignment requirements.</source>
          <target state="translated">Se agregaron bytes de relleno entre los campos para satisfacer los requisitos de alineación.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, consider the following structure, which consists of two <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields and one <ph id="ph2">&lt;xref:System.Int32&gt;</ph> field, when it is used with various values for the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field.</source>
          <target state="translated">Por ejemplo, considere la siguiente estructura, que consta de dos <ph id="ph1">&lt;xref:System.Byte&gt;</ph> campos y uno <ph id="ph2">&lt;xref:System.Int32&gt;</ph> campo, cuando se usa con varios valores para el <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> campo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To successfully compile the C# examples, you must specify the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Para compilar correctamente el ejemplo de C#, debe especificar el <ph id="ph1">`/unsafe`</ph> modificador del compilador.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If you specify the default packing size, the size of the structure is 8 bytes.</source>
          <target state="translated">Si especifica el tamaño de empaquetado predeterminado, el tamaño de la estructura tiene 8 bytes.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</source>
          <target state="translated">Los dos bytes ocupan los primeros dos bytes de memoria, como bytes deben estar en línea en los límites de un byte.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is 4 bytes, which is the size of its largest fields, <ph id="ph1">`i3`</ph>, there are two bytes of padding followed by the integer field.</source>
          <target state="translated">Dado que la alineación predeterminada del tipo es de 4 bytes, que es el tamaño de sus campos más grandes, <ph id="ph1">`i3`</ph>, hay dos bytes de relleno seguido por el campo de número entero.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 6 bytes.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> está establecido en 2, el tamaño de la estructura es 6 bytes.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>As before, the two bytes occupy the first two bytes of memory.</source>
          <target state="translated">Como antes, los dos bytes que ocupan los primeros dos bytes de memoria.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</source>
          <target state="translated">Como campos ahora alinearán en límites de 2 bytes, no hay ningún relleno entre el segundo byte y el entero.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, <ph id="ph2">`i3`</ph>, which is 4.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> se establece en 4, el tamaño de la estructura es el mismo que en el caso predeterminado, donde alineación del tipo definido por el tamaño de su campo más grande, <ph id="ph2">`i3`</ph>, que es 4.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the still same as in the default case, because the <ph id="ph2">`i3`</ph> field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> está establecido en 8, el tamaño de la estructura sigue siendo igual que en el valor predeterminado de casos, dado que el <ph id="ph2">`i3`</ph> campo alinea en un límite de 4 bytes, que es menor que el límite de 8 bytes especificado por el campo de módulo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</source>
          <target state="translated">He aquí otro ejemplo, considere la siguiente estructura, que consta de campos de dos bytes, el campo de un entero de 32 bits con signo, una matriz de byte único elemento y un valor decimal.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>With the default packing size, the size of the structure is 28 bytes.</source>
          <target state="translated">Con el tamaño de empaquetado predeterminado, el tamaño de la estructura es 28 bytes.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</source>
          <target state="translated">Los dos bytes ocupan los primeros dos bytes de memoria, seguido de dos bytes de relleno, seguido por el número entero.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Next is the one-byte array, followed by three bytes of padding.</source>
          <target state="translated">A continuación figura la matriz de un byte, seguida de tres bytes de relleno.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <ph id="ph2">&lt;xref:System.Int32&gt;</ph> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> structure as a whole.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> campo, d5, se alinea en un límite de 4 bytes porque un valor decimal se compone de cuatro <ph id="ph2">&lt;xref:System.Int32&gt;</ph> campos, por lo que su alineación se basa en el tamaño de la mayor de sus campos en lugar de en el tamaño de la <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> estructura como un todo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 24 bytes.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> está establecido en 2, el tamaño de la estructura es de 24 bytes.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</source>
          <target state="translated">En comparación con la alineación predeterminada, se han quitado los dos bytes de relleno entre los dos bytes y el entero porque la alineación del tipo ahora está 4 en lugar de 2.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>And the three bytes of padding after <ph id="ph1">`a4`</ph> have been replaced by one byte of padding, since <ph id="ph2">`d5`</ph> now aligns on a 2-byte boundary rather than a 4-byte boundary.</source>
          <target state="translated">Y los tres bytes de relleno después <ph id="ph1">`a4`</ph> se han reemplazado por un byte de relleno, ya que <ph id="ph2">`d5`</ph> ahora se alinea en un límite de 2 bytes en lugar de un límite de 4 bytes.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> está establecido en 8, el tamaño de la estructura es el mismo que en el caso predeterminado, porque todos los requisitos de alineación de esta estructura están inferior a 8.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field is frequently used when structures are exported during disk and network write operations.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> campo se utiliza con frecuencia cuando se exportan las estructuras durante el disco y las operaciones de escritura de la red.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The field is also frequently used during platform invoke and interop operations.</source>
          <target state="translated">El campo también se suele usar durante la plataforma de invocación y las operaciones de interoperabilidad.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</source>
          <target state="translated">En ocasiones, el campo se usa para reducir los requisitos de memoria, que produce un tamaño de empaquetado más estricto.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</source>
          <target state="translated">Sin embargo, este uso requiere una consideración cuidadosa de restricciones de hardware reales y realmente puede degradar el rendimiento.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>Indicates the absolute size of the class or structure.</source>
          <target state="translated">Indica el tamaño absoluto de la clase o estructura.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</source>
          <target state="translated">Este campo debe ser igual o mayor que el tamaño total, en bytes, de los miembros de la clase o estructura.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</source>
          <target state="translated">Este campo es principalmente para los autores de compiladores que desean extender la memoria ocupada por una estructura para el acceso directo y no administrado.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>For example, you can use this field when working with unions that are not represented in metadata directly.</source>
          <target state="translated">Por ejemplo, puede usar este campo cuando se trabaja con uniones que no están representadas directamente en metadatos.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> value that specifies how the class or structure is arranged.</source>
          <target state="translated">Obtiene el valor de <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> que especifica la forma en que está organizada la clase o estructura.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>One of the enumeration values that specifies how the class or structure is arranged.</source>
          <target state="translated">Uno de los valores de enumeración que especifica cómo se organiza la clase o la estructura.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>