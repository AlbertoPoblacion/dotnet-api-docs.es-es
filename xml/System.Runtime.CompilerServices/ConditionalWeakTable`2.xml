<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dbf347a600196f6012ffdb19e1733f7b6934173d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36541733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <typeparam name="TKey">Tipo de referencia al que se adjunta el campo.</typeparam>
    <typeparam name="TValue">Tipo del campo. Debe ser un tipo de referencia.</typeparam>
    <summary>Enables compilers to dynamically attach object fields to managed objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase permite a los compiladores de lenguaje adjuntar propiedades arbitrarias a objetos administrados en tiempo de ejecución. Un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto es un diccionario que se enlaza un objeto administrado, que se representa mediante una clave, su propiedad adjunta, que se representa mediante un valor. Las claves del objeto son las instancias individuales de la `TKey` (clase) a la que se adjunta la propiedad y sus valores son los valores de propiedad que se asignan a los objetos correspondientes.  
  
 Las claves deben ser únicas; en otras palabras, la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase es compatible con un valor adjunto por objeto administrado. Dos claves son iguales si pasarlas a la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`.  
  
> [!NOTE]
>  No se puede controlar las comparaciones de igualdad invalidando <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para establecer explícitamente el código hash para una clave. El <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase no usa el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método para calcular los códigos hash y, por lo tanto, no se invoca <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> invalida.  
  
 Aunque la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase contiene una colección de pares clave/valor, es mejor considerar como una tabla en lugar de un objeto de diccionario. La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase difiere de un diccionario de varias maneras:  
  
-   No se conserva las claves. Es decir, una clave no se mantiene activa solo porque es un miembro de la colección.  
  
-   No incluye todos los métodos (como `GetEnumerator` o `Contains`) que normalmente tiene un diccionario.  
  
-   No implementa la <xref:System.Collections.Generic.IDictionary%602> interfaz.  
  
 La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase difiere de otros objetos de colección en la administración de la duración de los objetos de las claves almacenadas en la colección. Normalmente, cuando un objeto se almacena en una colección, su duración dura hasta que se quita (y no hay ninguna referencia adicional para el objeto) o hasta que se destruya el propio objeto de colección. Sin embargo, en la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> (clase), agregar un par clave-valor a la tabla no garantiza que la clave se conservará, aunque se puede tener acceso directamente desde un valor almacenado en la tabla (por ejemplo, si la tabla contiene una clave, A, con un valor V1 y una segunda clave, B, con un valor P2 que contiene una referencia a una). En su lugar, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> quita automáticamente la entrada de clave/valor en cuanto no existen otras referencias a una clave fuera de la tabla. En este ejemplo se ilustra.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra que una clave almacenada en el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla no se conserva después de que se destruyen las referencias a él fuera de la tabla. El ejemplo define dos clases: `ManagedClass`, que representa la clave en la tabla, y `ClassData`, que representa el valor de clave. El ejemplo crea tres objetos de cada tipo. También crea una instancia de un <xref:System.WeakReference> objeto que representa el segundo `ManagedClass`y, a continuación, destruye el segundo `ManagedClass` instancia. Al intentar recuperar el segundo `ManagedClass` objeto desde el <xref:System.WeakReference.Target%2A> propiedad indica que no permanecen ninguna referencia al objeto.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Instancias de la <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> clase son seguros para subprocesos. No requieren llamadores a hacer cualquier bloqueo adicional.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor crea una instancia vacía <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla; es decir, la tabla no contiene ningún pares clave/valor. Puede agregar pares clave/valor mediante una llamada a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método.  
  
 Todas las claves de un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto debe ser único. Las claves no son únicas si hacen referencia al mismo objeto (es decir, si se pasan como argumentos para la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">The key to add. <c>key</c> represents the object to which the property is attached.</param>
        <param name="value">The key's property value.</param>
        <summary>Adds a key to the table.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas las claves de un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto debe ser único. Las claves no son únicas si hacen referencia al mismo objeto (es decir, si se pasan como argumentos para la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).  
  
 Si la clave es la recolección durante la operación de suma, se quita el par clave/valor existente y se agrega el par clave/valor nuevo sin que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia. El ejemplo, a continuación, se llama la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla. Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> already exists.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados llame <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> cuando el objeto actual está preparado para finalizarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">The key to search for. <c>key</c> represents the object to which the property is attached.</param>
        <summary>Atomically searches for a specified key in the table and returns the corresponding value. If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</summary>
        <returns>The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `key` no existe en la tabla, el método agrega, junto con el objeto cuyas instancias se crean mediante una llamada al constructor predeterminado de la clase definida por el `TValue` parámetro de tipo genérico. Si el `TValue` clase no tiene ningún constructor predeterminado, un <xref:System.MissingMethodException> se produce.  
  
 Este es el método recomendado para recuperar un valor existente o agregar un nuevo valor para el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla si la clase de valor de la tabla define un constructor predeterminado. Si no define un constructor predeterminado, puede llamar en su lugar el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método, que se basa en un método proporcionado por devolución de llamada a una instancia del objeto que representa el valor de la tabla  
  
 Para recuperar el valor de una clave existente sin agregar el par clave/valor si la clave no se encuentra en la tabla, llame a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia. El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla. Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.  </para>
          </block>  The class that represents the table's value does not define a default constructor.</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">The key to search for. <c>key</c> represents the object to which the property is attached.</param>
        <param name="createValueCallback">A delegate to a method that can create a value for the given <c>key</c>. It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</param>
        <summary>Atomically searches for a specified key in the table and returns the corresponding value. If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</summary>
        <returns>The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `key` no existe en la tabla, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invoca el método definido por el `createValueCallback` parámetro y pasa la clave. Un nuevo valor se enlaza a la clave en la tabla y se devuelve como resultado.  
  
 Use este método solo cuando la clase que representa el valor de la tabla no define un constructor predeterminado. Si define un constructor predeterminado, use el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método en su lugar. Para recuperar el valor de una clave existente sin agregar el par clave/valor si la clave no se encuentra en la tabla, llame a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.  
  
 Si varios subprocesos intentan crear la misma clave, `createValueCallback` se puede invocar varias veces con la misma clave. Solo una de estas llamadas se realizará correctamente y su valor devuelto se agregará a la tabla. El subproceso se realiza correctamente para crear el valor es indeterminado. Esta regla permite a la tabla para invocar `createValueCallback` fuera el bloqueo de tabla interno para evitar interbloqueos.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia. También define una variable static (`Shared` en Visual Basic) `CreateAttachedValue` método que se puede asignar a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegar y pasa a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método. El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla. Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">The key to remove.</param>
        <summary>Removes a key and its value from the table.</summary>
        <returns>
          <see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave es la recolección durante esta operación, el método no provoca una excepción y el valor devuelto es indefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">The key that represents an object with an attached property.</param>
        <param name="value">When this method returns, contains the attached property value. If <c>key</c> is not found, <c>value</c> contains the default value.</param>
        <summary>Gets the value of the specified key.</summary>
        <returns>
          <see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave es recolección durante esta operación, el método puede devolver `false` y establecer `value` con el valor predeterminado el valor (como si la clave no estaban presente).  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia. El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares de clave/valor a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla. En cada caso, el ejemplo llama a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para confirmar que el par clave-valor se ha agregado a la tabla.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>