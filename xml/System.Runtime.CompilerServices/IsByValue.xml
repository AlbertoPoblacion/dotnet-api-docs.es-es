<Type Name="IsByValue" FullName="System.Runtime.CompilerServices.IsByValue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2676579da09b70edfe89eb11bd2e20fda838d810" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637062" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class IsByValue" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit IsByValue extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.IsByValue" />
  <TypeSignature Language="VB.NET" Value="Public Class IsByValue" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsByValue abstract sealed" />
  <TypeSignature Language="F#" Value="type IsByValue = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.CompilerServices.VisualC</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Indica que un argumento de método modificado se debería interpretar como si tuviera semántica de objeto pasado por valor. Este modificador se aplica para hacer referencia a los tipos.  Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.CompilerServices.IsByValue> clase es usada por el compilador de Microsoft C++ para denotar los parámetros de método y devuelven valores cuya semántica sigue las reglas de C++ de objetos pasados por valor.  
  
 Los compiladores emiten modificadores personalizados dentro de los metadatos para cambiar la manera en que el compilador de just-in-time (JIT) administra los valores cuando el comportamiento predeterminado no es adecuado.  Cuando el compilador JIT encuentra un modificador personalizado, controla el valor de la manera que especifica el modificador.  Compiladores pueden aplicar modificadores personalizados a métodos, parámetros y valores devueltos.  El compilador JIT debe responder a los modificadores requeridos pero puede pasar por alto los modificadores opcionales.  
  
 Puede emitir modificadores personalizados en los metadatos utilizando una de las técnicas siguientes:  
  
-   Uso de métodos en el <xref:System.Reflection.Emit.TypeBuilder> clase como <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, y <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.  
  
-   Generar un archivo de instrucciones de lenguaje intermedio (MSIL) de Microsoft que contenga llamadas a `modopt` y `modreq`y ensamblando el archivo con el [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
-   Uso de la API de reflexión no administrada.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo emitir una <xref:System.Runtime.CompilerServices.IsByValue> objeto en un ensamblado utilizando la reflexión.  
  
 [!code-cpp[Runtime.CompilerServices.IsByValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.CompilerServices.IsByValue/cpp/sample.cpp#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members />
</Type>