<Type Name="DbExpressionBuilder" FullName="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f079ada6bf4ff5b4e1c43e704b23781305d885c" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613987" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class DbExpressionBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DbExpressionBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Module DbExpressionBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbExpressionBuilder abstract sealed" />
  <TypeSignature Language="F#" Value="type DbExpressionBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una API para construir elementos <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> y permite tener acceso a dicha API como métodos de extensión en el propio tipo de expresión.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ Aggregate(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFunctionAggregate" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate (function, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Función que define la operación de agregado.</param>
        <param name="argument">Argumento sobre el que se calculará la función de agregado.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />.</summary>
        <returns>Nuevo agregado de función con una referencia a la función y al argumento especificados. La propiedad Distinct del agregado de la función tendrá el valor <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> o <paramref name="argument" /> null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> no es una función de agregado o tiene más de un argumento, o el tipo de resultado de <paramref name="argument" /> no es igual ni se puede promover al tipo de parámetro de <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateDistinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AggregateDistinct (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ AggregateDistinct(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member AggregateDistinct : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFunctionAggregate" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct (function, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Función que define la operación de agregado.</param>
        <param name="argument">Argumento sobre el que se calculará la función de agregado.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" /> que se aplica de un modo distinto.</summary>
        <returns>Nuevo agregado de función con una referencia a la función y al argumento especificados. La propiedad Distinct del agregado de la función tendrá el valor <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> o <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> no es una función de agregado o tiene más de un argumento, o el tipo de resultado de <paramref name="argument" /> no es igual ni se puede promover al tipo de parámetro de <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="All">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina si el predicado definido se aplica a todos los elementos del conjunto de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Un método que representa un predicado que se va a evaluar para cada miembro del conjunto de entrada.    Este método debe generar una expresión con un tipo de resultado booleano que proporcione la lógica del predicado.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina si el predicado definido se aplica a todos los elementos del conjunto de entrada.</summary>
        <returns>Nuevo DbQuantifierExpression que representa la operación All.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="predicate" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="Predicate" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Una expresión que representa un predicado que se va a evaluar para cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina si el predicado definido se aplica a todos los elementos del conjunto de entrada.</summary>
        <returns>Nuevo DbQuantifierExpression que representa la operación All.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbAndExpression And (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbAndExpression And(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function And (left As DbExpression, right As DbExpression) As DbAndExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbAndExpression ^ And(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbAndExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbAndExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión booleana que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión booleana que especifica el argumento derecho.</param>
        <summary>Crea un <see cref="T:System.Data.Common.CommandTrees.DbAndExpression" /> que realiza la operación de And lógico de los argumentos izquierdo y derecho.</summary>
        <returns>Nuevo DbAndExpression con argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" /> y <paramref name="right" /> no tienen un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que determina si el argumento de conjunto especificado no está vacío.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Any (this System.Data.Common.CommandTrees.DbExpression source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Any(class System.Data.Common.CommandTrees.DbExpression source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que determina si el argumento de conjunto especificado no está vacío.</summary>
        <returns>Nuevo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> aplicado a un nuevo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> con el argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Método que representa el predicado que se va a evaluar para cada miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado booleano que proporcione la lógica del predicado.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina si el predicado definido se aplica a cualquier elemento del conjunto de entrada.</summary>
        <returns>Nuevo DbQuantifierExpression que representa la operación Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="predicate" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="predicate" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Una expresión que representa un predicado que se va a evaluar para cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> que determina si el predicado definido se aplica a cualquier elemento del conjunto de entrada.</summary>
        <returns>Nuevo DbQuantifierExpression que representa la operación Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> es null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="predicate" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="As">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los argumentos especificados como un objeto de par clave-valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt; As (this System.Data.Common.CommandTrees.DbAggregate value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt; As(class System.Data.Common.CommandTrees.DbAggregate value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbAggregate,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbAggregate, alias As String) As KeyValuePair(Of String, DbAggregate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt; As(System::Data::Common::CommandTrees::DbAggregate ^ value, System::String ^ alias);" />
      <MemberSignature Language="F#" Value="static member As : System.Data.Common.CommandTrees.DbAggregate * string -&gt; System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbAggregate&gt;" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As (value, alias)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbAggregate" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">El valor del par clave-valor.</param>
        <param name="alias">La clave del par clave-valor.</param>
        <summary>Devuelve los argumentos especificados como un objeto de par clave-valor.</summary>
        <returns>Objeto de par clave-valor.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt; As (this System.Data.Common.CommandTrees.DbExpression value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt; As(class System.Data.Common.CommandTrees.DbExpression value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbExpression, alias As String) As KeyValuePair(Of String, DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt; As(System::Data::Common::CommandTrees::DbExpression ^ value, System::String ^ alias);" />
      <MemberSignature Language="F#" Value="static member As : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As (value, alias)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">El valor del par clave-valor.</param>
        <param name="alias">La clave del par clave-valor.</param>
        <summary>Devuelve los argumentos especificados como un objeto de par clave-valor.</summary>
        <returns>Objeto de par clave-valor.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding Bind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding Bind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Bind (input As DbExpression) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ Bind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Expresión que se va a enlazar.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> objeta que usa un nombre de variable generado para enlazar la expresión dada.</summary>
        <returns>Nuevo enlace de expresiones con la expresión especificada y un nombre de variable generado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> no tiene un resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding BindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding BindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BindAs (input As DbExpression, varName As String) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ BindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName);" />
      <MemberSignature Language="F#" Value="static member BindAs : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs (input, varName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Expresión que se va a enlazar.</param>
        <param name="varName">Nombre de variable que se debe utilizar para el enlace.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> objeta que usa el nombre de variable especificado para enlazar la expresión dada.</summary>
        <returns>Nuevo enlace de expresiones con la expresión especificada y un nombre de variable.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="varName" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> no tiene un resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="Case">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCaseExpression Case (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, System.Data.Common.CommandTrees.DbExpression elseExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCaseExpression Case(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, class System.Data.Common.CommandTrees.DbExpression elseExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Function Case (whenExpressions As IEnumerable(Of DbExpression), thenExpressions As IEnumerable(Of DbExpression), elseExpression As DbExpression) As DbCaseExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCaseExpression ^ Case(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ whenExpressions, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ thenExpressions, System::Data::Common::CommandTrees::DbExpression ^ elseExpression);" />
      <MemberSignature Language="F#" Value="static member Case : seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbCaseExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case (whenExpressions, thenExpressions, elseExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCaseExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="whenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="thenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="elseExpression" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="whenExpressions">Lista de expresiones que proporcionan la expresión condicional para cada caso.</param>
        <param name="thenExpressions">Una lista de expresiones que proporcionan el resultado de cada caso.</param>
        <param name="elseExpression">Una expresión que define el resultado cuando no coincide con ningún caso.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbCaseExpression" />.</summary>
        <returns>Nuevo DbCaseExpression con los casos especificados y el resultado predeterminado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="whenExpressions" /> o <paramref name="thenExpressions" /> es null, o contiene null, o <paramref name="elseExpression" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="whenExpressions" /> o <paramref name="thenExpressions" /> está vacío o <paramref name="whenExpressions" /> contiene una expresión con un tipo de resultado no booleano, o no existe un tipo de resultado común para todas las expresiones de <paramref name="thenExpressions" /> y <paramref name="elseExpression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CastTo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCastExpression CastTo (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage toType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCastExpression CastTo(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CastTo (argument As DbExpression, toType As TypeUsage) As DbCastExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbCastExpression ^ CastTo(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ toType);" />
      <MemberSignature Language="F#" Value="static member CastTo : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbCastExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo (argument, toType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCastExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="toType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Argumento al que se debe aplicar la conversión.</param>
        <param name="toType">Metadatos de tipo que especifican el tipo al que se va a convertir.</param>
        <summary>Crea una nueva <see cref="T:System.Data.Common.CommandTrees.DbCastExpression" /> que aplica una operación de conversión a un argumento polimórfico.</summary>
        <returns>Nuevo DbCastExpression con el argumento y el tipo de destino especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> o <paramref name="toType" /> es null.</exception>
        <exception cref="T:System.ArgumentException">La conversión especificada no es válida.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Constant (value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor constante que se va a representar.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con el valor constante especificado.</summary>
        <returns>Nuevo DbConstantExpression con el valor especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es una instancia de un tipo de constante válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (this System.Data.Metadata.Edm.TypeUsage constantType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(class System.Data.Metadata.Edm.TypeUsage constantType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Data.Metadata.Edm.TypeUsage,System.Object)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Constant (constantType As TypeUsage, value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Data::Metadata::Edm::TypeUsage ^ constantType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : System.Data.Metadata.Edm.TypeUsage * obj -&gt; System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant (constantType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constantType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="constantType">Tipo del valor constante.</param>
        <param name="value">Valor constante que se va a representar.</param>
        <summary>Crea una nueva <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> del tipo primitivo especificado con el valor constante definido.</summary>
        <returns>Nuevo DbConstantExpression con el valor especificado y un tipo de resultado de <paramref name="constantType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> o <paramref name="constantType" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es una instancia de un tipo de constante válido, <paramref name="constantType" /> no representa un tipo primitivo, o <paramref name="value" /> es de un tipo primitivo diferente al representado mediante <paramref name="constantType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRef">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta de un tipo dado basándose en los valores de clave.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="keyValues">Colección de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s que proporcionan los valores de clave. Estas expresiones deben coincidir (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta basándose en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> es null, o <paramref name="keyValues" /> es nulo o contiene un valor null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="keyValues" /> no coincide con el recuento de miembros clave declarado por el tipo de elemento de <paramref name="entitySet" />, o <paramref name="keyValues" /> contiene una expresión con un tipo de resultado que no es compatible con el tipo del miembro clave correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="keyValues">Colección de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s que proporcionan los valores de clave. Estas expresiones deben coincidir (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta basándose en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> es null, o <paramref name="keyValues" /> es nulo o contiene un valor null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="keyValues" /> no coincide con el recuento de miembros clave declarado por el tipo de elemento de <paramref name="entitySet" />, o <paramref name="keyValues" /> contiene una expresión con un tipo de resultado que no es compatible con el tipo del miembro clave correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Metadata.Edm.EntityType * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, entityType, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="entityType">Tipo específico de la entidad a la que se hace referencia. Debe ser un tipo de entidad de la misma jerarquía que el tipo de elemento del conjunto de entidades.</param>
        <param name="keyValues">Colección de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s que proporcionan los valores de clave. Estas expresiones deben coincidir (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta de un tipo dado basándose en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="entityType" /> es null, o <paramref name="keyValues" /> es null o contiene null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="keyValues" /> no coincide con el recuento de miembros clave declarado por el tipo de elemento de <paramref name="entitySet" />, o <paramref name="keyValues" /> contiene una expresión con un tipo de resultado que no es compatible con el tipo del miembro clave correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Metadata.Edm.EntityType * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, entityType, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="entityType">Tipo específico de la entidad a la que se hace referencia. Debe ser un tipo de entidad de la misma jerarquía que el tipo de elemento del conjunto de entidades.</param>
        <param name="keyValues">Colección de <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s que proporcionan los valores de clave. Estas expresiones deben coincidir (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta de un tipo dado basándose en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="entityType" /> es null, o <paramref name="keyValues" /> es null o contiene null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="keyValues" /> no coincide con el recuento de miembros clave declarado por el tipo de elemento de <paramref name="entitySet" />, o <paramref name="keyValues" /> contiene una expresión con un tipo de resultado que no es compatible con el tipo del miembro clave correspondiente.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CrossApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member CrossApply : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Un método que especifica la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. No se incluyen las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío.</summary>
        <returns>Un nuevo DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El resultado de <paramref name="apply" /> contiene un nombre o expresión que es null.</exception>
        <exception cref="T:System.ArgumentException">El resultado de <paramref name="apply" /> contiene un nombre o una expresión que no son válidos en un enlace de expresiones.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberSignature Language="F#" Value="static member CrossApply : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply (input, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. No se incluyen las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío.</summary>
        <returns>Un nuevo DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="apply" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpressionBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Function CrossJoin (inputs As IEnumerable(Of DbExpressionBinding)) As DbCrossJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCrossJoinExpression ^ CrossJoin(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpressionBinding ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member CrossJoin : seq&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; -&gt; System.Data.Common.CommandTrees.DbCrossJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCrossJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Una lista de enlaces de expresión que especifica los conjuntos de entrada.</param>
        <summary>Crea una nueva <see cref="T:System.Data.Common.CommandTrees.DbCrossJoinExpression" /> que combina incondicionalmente los conjuntos especificados por la lista de enlaces de expresión de entrada.</summary>
        <returns>Nuevo DbCrossJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossJoin, que representa la unión incondicional de los conjuntos de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputs" /> es null, o contiene elemento null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputs" /> contiene menos de 2 enlaces de expresión.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deref">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDerefExpression Deref (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDerefExpression Deref(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deref (argument As DbExpression) As DbDerefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDerefExpression ^ Deref(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Deref : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbDerefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDerefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que proporciona la referencia. Esta expresión debe tener un tipo de referencia.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression" /> que recupera una entidad concreta para la que se ha proporcionado una expresión de referencia.</summary>
        <returns>Nuevo DbDerefExpression que recupera la entidad especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de referencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDistinctExpression Distinct (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDistinctExpression Distinct(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct (argument As DbExpression) As DbDistinctExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDistinctExpression ^ Distinct(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbDistinctExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDistinctExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que define el conjunto sobre el que se va a realizar la operación distinta.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbDistinctExpression" /> que quita los duplicados del argumento de conjunto dado.</summary>
        <returns>Nuevo DbDistinctExpression que representa la operación distinta aplicada al argumento determinado especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Divide (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Divide(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Divide (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Divide(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que divide el argumento izquierdo por el argumento derecho.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de división.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico común entre <paramref name="left" /> o <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbElementExpression Element (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbElementExpression Element(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Element (argument As DbExpression) As DbElementExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbElementExpression ^ Element(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Element : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbElementExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbElementExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbElementExpression" /> que convierte un conjunto en un singleton.</summary>
        <returns>DbElementExpression que representa la conversión del argumento de conjunto establecido en un singleton.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression Equal (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression Equal(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equal (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ Equal(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que compara los argumentos izquierdo y derecho para ver si son iguales.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación de igualdad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuya igualdad se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExceptExpression Except (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExceptExpression Except(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (left As DbExpression, right As DbExpression) As DbExceptExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExceptExpression ^ Except(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Except : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExceptExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExceptExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que define el argumento del conjunto izquierdo.</param>
        <param name="right">Una expresión que define el argumento del conjunto derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbExceptExpression" /> que calcula la resta de argumento del conjunto derecho del argumento del conjunto izquierdo.</summary>
        <returns>Nueva DbExceptExpression que representa la diferencia entre el argumento izquierdo y derecho.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado de colección común entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Exists (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Exists(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Exists (argument As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Exists(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Exists : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que determina si el argumento de conjunto especificado no está vacío.</summary>
        <returns>Nuevo <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> aplicado a un nuevo <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> con el argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="False">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression False { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression False" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property False As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ False { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.False : System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una expresión <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con el valor booleano <see langword="false" />.</summary>
        <value>Una expresión <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con el valor booleano <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Filter (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Filter(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Filter (input As DbExpressionBinding, predicate As DbExpression) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Filter(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Filter : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFilterExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Una expresión que representa un predicado que se va a evaluar para cada miembro del conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> que filtra los elementos del conjunto de entrada definido utilizando el predicado especificado.</summary>
        <returns>Nuevo DbFilterExpression que genera el conjunto filtrado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="predicate" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FullOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha, en la condición de combinación especificada, mediante FullOuterJoin como <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member FullOuterJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Un método que representa la condición según la que se va a combinar. Este método debe generar una expresión con un tipo de resultado booleano que proporciona la lógica de la condición de combinación.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha, en la condición de combinación especificada, mediante FullOuterJoin como <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Una nueva clase DbJoinExpression, con un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de FullOuterJoin, que representa la operación de combinación externa completa que se aplica a los conjuntos de entrada izquierdo y derecho en la condición de combinación dada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="joinCondition" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="joinCondition" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member FullOuterJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Una expresión que especifica la condición según la que se va a combinar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por los enlaces de las expresiones izquierda y derecha según la condición de combinación definida, usando FullOuterJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nueva clase DbJoinExpression, con un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de FullOuterJoin, que representa la operación de combinación externa completa que se aplica a los conjuntos de entrada izquierdo y derecho en la condición de combinación dada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> es null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="joinCondition" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEntityRef (argument As DbExpression) As DbEntityRefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbEntityRefExpression ^ GetEntityRef(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member GetEntityRef : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbEntityRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbEntityRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Expresión que proporciona la entidad. Esta expresión debe tener un tipo de resultado de entidad.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression" /> que recupera la referencia de la entidad especificada en forma estructural.</summary>
        <returns>Nuevo DbEntityRefExpression que recupera una referencia a la entidad especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de entidad.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRefKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetRefKey (argument As DbExpression) As DbRefKeyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefKeyExpression ^ GetRefKey(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member GetRefKey : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRefKeyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefKeyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Expresión que proporciona la referencia. Esta expresión debe tener un tipo de referencia con un tipo de elemento de entidad.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression" /> que recupera los valores de clave de la referencia especificada en forma estructural.</summary>
        <returns>Nuevo DbRefKeyExpression que recupera los valores de clave de la referencia especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de referencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina si el argumento izquierdo es mayor que el argumento derecho.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación mayor que.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuyo orden se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina si el argumento izquierdo es mayor o igual que el argumento derecho.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación mayor o igual que.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuyo orden se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBind (input As DbExpression) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberSignature Language="F#" Value="static member GroupBind : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbGroupExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Expresión que se va a enlazar.</param>
        <summary>Crea un nuevo enlace de expresión de grupo que usa los nombres de variable y de variable de grupo generados para enlazar la expresión definida.</summary>
        <returns>Nuevo enlace de expresiones de grupo con la expresión especificada y un nombre de variable generado y un nombre de variable de grupo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs(System.Data.Common.CommandTrees.DbExpression,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBindAs (input As DbExpression, varName As String, groupVarName As String) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName, System::String ^ groupVarName);" />
      <MemberSignature Language="F#" Value="static member GroupBindAs : System.Data.Common.CommandTrees.DbExpression * string * string -&gt; System.Data.Common.CommandTrees.DbGroupExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs (input, varName, groupVarName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
        <Parameter Name="groupVarName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Expresión que se va a enlazar.</param>
        <param name="varName">Nombre de variable que se debe utilizar para el enlace.</param>
        <param name="groupVarName">Nombre de variable que se debe usar para hacer referencia al grupo cuando el nuevo enlace de la expresión de grupo se utiliza en una expresión group-by.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> que usa el nombre de variable y los nombres de variable de grupo especificados para enlazar la expresión definida.</summary>
        <returns>Nuevo enlace de expresiones de grupo con la expresión, el nombre de la variable y el nombre de variable del grupo especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="varName" /> o <paramref name="groupVarName" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupByExpression GroupBy (this System.Data.Common.CommandTrees.DbGroupExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupByExpression GroupBy(class System.Data.Common.CommandTrees.DbGroupExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy(System.Data.Common.CommandTrees.DbGroupExpressionBinding,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbAggregate}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy (input As DbGroupExpressionBinding, keys As IEnumerable(Of KeyValuePair(Of String, DbExpression)), aggregates As IEnumerable(Of KeyValuePair(Of String, DbAggregate))) As DbGroupByExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupByExpression ^ GroupBy(System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ keys, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt;&gt; ^ aggregates);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Data.Common.CommandTrees.DbGroupExpressionBinding * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbAggregate&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbGroupByExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy (input, keys, aggregates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupByExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbGroupExpressionBinding" RefType="this" />
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
        <Parameter Name="aggregates" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> que especifica el conjunto de entrada.</param>
        <param name="keys">Una lista de pares cadena-expresión que definen las columnas de agrupación.</param>
        <param name="aggregates">Lista de expresiones que especifican los agregados a aplicar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbGroupByExpression" /> que agrupa los elementos del conjunto de entrada según las claves de grupo especificadas y aplica los agregados dados.</summary>
        <returns>Nuevo DbGroupByExpression con el conjunto especificado de entrada, claves y agregados de agrupación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbGroupByExpression permite que la lista de claves o la lista de agregados que deben estar en blanco, pero no ambos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="keys" /> o <paramref name="aggregates" /> es null, <paramref name="keys" /> contiene un nombre de columna clave o expresión null, o <paramref name="aggregates" /> contiene un nombre de columna agregado o agregado null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keys" /> y <paramref name="aggregates" /> están vacíos, o se especificó un nombre de columna no válido o duplicado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InnerJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha según la condición de combinación definida, usando InnerJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member InnerJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Un método que representa la condición según la que se va a combinar. Este método debe generar una expresión con un tipo de resultado booleano que proporciona la lógica de la condición de combinación.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha según la condición de combinación definida, usando InnerJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuevo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa la operación de combinación interna completa aplicada a los conjuntos de entrada izquierdo y derecho según la condición de combinación especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="joinCondition" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="joinCondition" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member InnerJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Una expresión que especifica la condición según la que se va a combinar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por los enlaces de las expresiones izquierda y derecha según la condición de combinación definida, usando InnerJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuevo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa la operación de combinación interna completa aplicada a los conjuntos de entrada izquierdo y derecho según la condición de combinación especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIntersectExpression Intersect (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIntersectExpression Intersect(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect (left As DbExpression, right As DbExpression) As DbIntersectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIntersectExpression ^ Intersect(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIntersectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIntersectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que define el argumento del conjunto izquierdo.</param>
        <param name="right">Una expresión que define el argumento del conjunto derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbIntersectExpression" /> que calcula la intersección de los argumentos del conjunto izquierdo y derecho.</summary>
        <returns>Nueva DbIntersectExpression que representa la intersección de los argumentos de los argumentos izquierdo y derecho.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado de colección común entre <paramref name="left" /> o <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> que representa la aplicación de la función Lambda especificada a los argumentos dados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, arguments As IEnumerable(Of DbExpression)) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Common.CommandTrees.DbLambda * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbLambdaExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (lambda, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="lambda">Instancia de <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> que representa la función Lambda que se va a aplicar.</param>
        <param name="arguments">Una lista de expresiones que proporcionan los argumentos.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> que representa la aplicación de la función Lambda especificada a los argumentos dados.</summary>
        <returns>Nuevo DbLambdaExpression que representa la aplicación de la función lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> o <paramref name="arguments" /> es null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="arguments" /> no es igual al número de variables declarado por <paramref name="lambda" />, o <paramref name="arguments" /> contiene una expresión que tiene un tipo de resultado que no es igual ni se puede promover al tipo de variable correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, ParamArray arguments As DbExpression()) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Common.CommandTrees.DbLambda * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbLambdaExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (lambda, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="lambda">Instancia de <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> que representa la función Lambda que se va a aplicar.</param>
        <param name="arguments">Expresiones que proporcionan los argumentos.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> que representa la aplicación de la función Lambda especificada a los argumentos dados.</summary>
        <returns>Nuevo DbLambdaExpression que representa la aplicación de la función lambda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> o <paramref name="arguments" /> es null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="arguments" /> no es igual al número de variables declarado por <paramref name="lambda" />, o <paramref name="arguments" /> contiene una expresión que tiene un tipo de resultado que no es igual ni se puede promover al tipo de variable correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, arguments As IEnumerable(Of DbExpression)) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Metadata.Edm.EdmFunction * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbFunctionExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (function, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Metadatos para la función que se va a invocar.</param>
        <param name="arguments">Una lista de expresiones que proporcionan los argumentos para la función.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> que representa la invocación de la función especificada con argumentos determinados.</summary>
        <returns>Nuevo DbFunctionExpression que representa la invocación de función.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> es null, o <paramref name="arguments" /> es nulo o contiene un valor null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="arguments" /> no es igual al número de parámetros declarados por <paramref name="function" />, o <paramref name="arguments" /> contiene una expresión que tiene un tipo de resultado que no es igual ni se puede promover al tipo de parámetro de función correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, ParamArray arguments As DbExpression()) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbFunctionExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (function, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="function">Metadatos para la función que se va a invocar.</param>
        <param name="arguments">Expresiones que proporcionan los argumentos para la función.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" /> que representa la invocación de la función especificada con argumentos determinados.</summary>
        <returns>Nuevo DbFunctionExpression que representa la invocación de función.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> es null, o <paramref name="arguments" /> es nulo o contiene un valor null.</exception>
        <exception cref="T:System.ArgumentException">El recuento de <paramref name="arguments" /> no es igual al número de parámetros declarados por <paramref name="function" />, o <paramref name="arguments" /> contiene una expresión que tiene un tipo de resultado que no es igual ni se puede promover al tipo de parámetro de función correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsEmpty (argument As DbExpression) As DbIsEmptyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsEmptyExpression ^ IsEmpty(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member IsEmpty : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIsEmptyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsEmptyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> que determina si el argumento de conjunto especificado es un conjunto vacío.</summary>
        <returns>Nuevo DbIsEmptyExpression con el argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsNullExpression IsNull (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsNullExpression IsNull(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNull (argument As DbExpression) As DbIsNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsNullExpression ^ IsNull(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member IsNull : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIsNullExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el argumento.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression" /> que determina si el argumento especificado es NULL.</summary>
        <returns>Nuevo DbIsNullExpression con el argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> tiene un tipo de resultado de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOf">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOf (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOf(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOf (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOf(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member IsOf : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbIsOfExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la instancia.</param>
        <param name="type">Metadatos de tipo que especifican el tipo con el que debe compararse el tipo de resultado de la instancia.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> que determina si el argumento definido es del tipo especificado o un subtipo.</summary>
        <returns>Nuevo DbIsOfExpression con la instancia y el tipo especificados y DbExpressionKind IsOf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression requiere que `argument` tiene un tipo de resultado polimórfico y que `type` es un tipo de la misma jerarquía de tipos que ese tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no está en la misma jerarquía de tipos que el tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOfOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOfOnly (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOfOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member IsOfOnly : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbIsOfExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la instancia.</param>
        <param name="type">Metadatos de tipo que especifican el tipo con el que debe compararse el tipo de resultado de la instancia.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> que determina si el argumento definido es del tipo especificado y solo de ese tipo (no un subtipo).</summary>
        <returns>Nuevo DbIsOfExpression con la instancia y el tipo especificados y DbExpressionKind IsOfOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression requiere que `argument` tiene un tipo de resultado polimórfico y que `type` es un tipo de la misma jerarquía de tipos que ese tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no está en la misma jerarquía de tipos que el tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression Join (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression Join(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey);" />
      <MemberSignature Language="F#" Value="static member Join : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join (outer, inner, outerKey, innerKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="outer">
          <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto externo.</param>
        <param name="inner">
          <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto interno.</param>
        <param name="outerKey">Método que especifica el modo en que el valor de clave externa debe derivar de un elemento del conjunto externo.</param>
        <param name="innerKey">Método que especifica el modo en que el valor de clave interna debe derivar de un elemento del conjunto interno.</param>
        <summary>Crea una nueva <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones externas e internas, en una condición de igualdad entre las claves especificadas de externas e internas, usando InnerJoin como <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Una nueva clase DbJoinExpression, con un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa la operación de combinación interna aplicada a los conjuntos de entrada izquierdo y derecho en una condición de combinación que compara los valores de las claves externa e interna para ver si son iguales.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión generada por <paramref name="outerKey" /> o <paramref name="innerKey" /> es null.</exception>
        <exception cref="T:System.ArgumentException">En las expresiones producidas por <paramref name="outerKey" /> y <paramref name="innerKey" /> no se puede realizar una comparación de igualdad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join``1(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TSelector) (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, 'Selector&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join (outer, inner, outerKey, innerKey, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Tipo de la propiedad <paramref name="selector" />.</typeparam>
        <param name="outer">
          <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto externo.</param>
        <param name="inner">
          <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto interno.</param>
        <param name="outerKey">Método que especifica el modo en que el valor de clave externa debe derivar de un elemento del conjunto externo.</param>
        <param name="innerKey">Método que especifica el modo en que el valor de clave interna debe derivar de un elemento del conjunto interno.</param>
        <param name="selector">Método que especifica el modo en que un elemento del conjunto de resultados debe derivar de los elementos de los conjuntos interno y externo. Este método debe generar una instancia de un tipo que sea compatible con Join y que pueda resolverse en una <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Los requisitos de compatibilidad de <c>TSelector</c> se describen en la sección Comentarios.</param>
        <summary>Crea una nueva <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que proyecta el selector especificado sobre los conjuntos especificados por las expresiones externas e internas, combinadas en una condición de igualdad entre las claves especificadas de externas e internas, usando InnerJoin como <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nueva DbProjectExpression con el selector especificado como su proyección, y una nueva DbJoinExpression como su entrada. La DbJoinExpression de entrada se crea con un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de InnerJoin, que representa la operación de combinación interna aplicada a los conjuntos de entrada izquierdo y derecho en una condición de combinación que compara los valores de las claves externa e interna para ver si son iguales.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que sea compatible con la combinación, `TSelector` debe derivarse de <xref:System.Data.Common.CommandTrees.DbExpression>, o debe ser un tipo anónimo con propiedades derivadas de DbExpression. Los siguientes son ejemplos de tipos admitidos para `TSelector`:  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => o.Property("Name"))  
```  
  
 (`TSelector` es <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => new { OName = o.Property("Name"), IName = i.Property("Name") })  
```  
  
 (`TSelector` es un tipo anónimo con propiedades derivadas de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El resultado de <paramref name="selector" /> es null tras la conversión a DbExpression.</exception>
        <exception cref="T:System.ArgumentException">El resultado de <paramref name="Selector" /> no es compatible con SelectMany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con la implementación de una función Lambda insertada y los parámetros formales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbVariableReferenceExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, variables As IEnumerable(Of DbVariableReferenceExpression)) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Data.Common.CommandTrees.DbExpression * seq&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; -&gt; System.Data.Common.CommandTrees.DbLambda" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda (body, variables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Expresión que define la lógica de la función Lambda.</param>
        <param name="variables">Colección <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que representa los parámetros formales para la función Lambda. Estas variables son válidas para el uso en la expresión <paramref name="body" />.</param>
        <summary>Crea un <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con la implementación de una función Lambda insertada y los parámetros formales.</summary>
        <returns>Nuevo DbLambda que describe una función Lambda alineada con el cuerpo y los parámetros formales especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" /> es null o contiene null, o <paramref name="body" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" /> contiene más de un elemento con el mismo nombre de variable.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, params System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbVariableReferenceExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, ParamArray variables As DbVariableReferenceExpression()) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, ... cli::array &lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbVariableReferenceExpression[] -&gt; System.Data.Common.CommandTrees.DbLambda" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda (body, variables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Data.Common.CommandTrees.DbVariableReferenceExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Expresión que define la lógica de la función Lambda.</param>
        <param name="variables">Colección <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que representa los parámetros formales para la función Lambda. Estas variables son válidas para el uso en la expresión <paramref name="body" />.</param>
        <summary>Crea un <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> con la implementación de una función Lambda insertada y los parámetros formales.</summary>
        <returns>Nuevo DbLambda que describe una función Lambda alineada con el cuerpo y los parámetros formales especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" /> es null o contiene null, o <paramref name="body" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" /> contiene más de un elemento con el mismo nombre de variable.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha según la condición de combinación definida, usando LeftOuterJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member LeftOuterJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Un método que representa la condición según la que se va a combinar. Este método debe generar una expresión con un tipo de resultado booleano que proporciona la lógica de la condición de combinación.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por las expresiones izquierda y derecha según la condición de combinación definida, usando LeftOuterJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuevo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de LeftOuterJoin, que representa la operación de combinación externa izquierda aplicada a los conjuntos de entrada izquierdo y derecho según la condición de combinación especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="joinCondition" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="joinCondition" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member LeftOuterJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto izquierdo.</param>
        <param name="right">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el argumento del conjunto derecho.</param>
        <param name="joinCondition">Una expresión que especifica la condición según la que se va a combinar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> que combina los conjuntos especificados por los enlaces de las expresiones izquierda y derecha según la condición de combinación definida, usando LeftOuterJoin como la <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Nuevo DbJoinExpression, con <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de LeftOuterJoin, que representa la operación de combinación externa izquierda aplicada a los conjuntos de entrada izquierdo y derecho según la condición de combinación especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> o <paramref name="joinCondition" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina si el argumento izquierdo es menor que el argumento derecho.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación menor que.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuyo orden se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que determina si el argumento izquierdo es menor o igual que el argumento derecho.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación menor o igual que.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuyo orden e igualdad se puedan comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Like">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> que compara la cadena de entrada especificada con el modelo definido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Like : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLikeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like (argument, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la cadena de entrada.</param>
        <param name="pattern">Una expresión que especifica la cadena del modelo.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> que compara la cadena de entrada especificada con el modelo definido.</summary>
        <returns>Nuevo DbLikeExpression con la entrada, el modelo y escape null especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> o <paramref name="pattern" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Argument" /> o <paramref name="pattern" /> no tiene un tipo de resultado de cadena.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern, System.Data.Common.CommandTrees.DbExpression escape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern, class System.Data.Common.CommandTrees.DbExpression escape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression, escape As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern, System::Data::Common::CommandTrees::DbExpression ^ escape);" />
      <MemberSignature Language="F#" Value="static member Like : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLikeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like (argument, pattern, escape)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="escape" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la cadena de entrada.</param>
        <param name="pattern">Una expresión que especifica la cadena del modelo.</param>
        <param name="escape">Una expresión opcional que especifica la cadena de escape.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> que compara la cadena de entrada especificada con el modelo definido utilizando el escape opcional.</summary>
        <returns>Nuevo DbLikeExpression con la entrada, el modelo y escape especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" />, <paramref name="pattern" /> o <paramref name="escape" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />, <paramref name="pattern" /> o <paramref name="escape" /> no tiene un tipo de resultado de cadena.</exception>
      </Docs>
    </Member>
    <Member MemberName="Limit">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Limit (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Limit(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Limit (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Limit(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Limit : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLimitExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la colección de entrada.</param>
        <param name="count">Una expresión que especifica el valor de límite.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> que restringe el número de elementos en la colección Argument al valor de Limit especificado. Los resultados enlazados no se incluyen en el resultado.</summary>
        <returns>Nuevo DbLimitExpression con valores de límite de argumento y recuento especificados que no incluye resultados iguales.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección, o <paramref name="count" /> no tiene ningún tipo de resultado que sea igual o se pueda promover a un tipo entero de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Minus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Minus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Minus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Minus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Minus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Minus : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que resta el argumento derecho del argumento izquierdo.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de resta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico común entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Modulo (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Modulo(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Modulo (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Modulo(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que calcula el resto del argumento izquierdo dividido por el argumento derecho.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de módulos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico común entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Multiply (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Multiply(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Multiply (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Multiply(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que multiplica el argumento izquierdo por el argumento derecho.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de multiplicación.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico común entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> que representa la navegación de una relación de asociación o composición.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Common.CommandTrees.DbExpression navigateFrom, System.Data.Metadata.Edm.RelationshipEndMember fromEnd, System.Data.Metadata.Edm.RelationshipEndMember toEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Common.CommandTrees.DbExpression navigateFrom, class System.Data.Metadata.Edm.RelationshipEndMember fromEnd, class System.Data.Metadata.Edm.RelationshipEndMember toEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (navigateFrom As DbExpression, fromEnd As RelationshipEndMember, toEnd As RelationshipEndMember) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Common::CommandTrees::DbExpression ^ navigateFrom, System::Data::Metadata::Edm::RelationshipEndMember ^ fromEnd, System::Data::Metadata::Edm::RelationshipEndMember ^ toEnd);" />
      <MemberSignature Language="F#" Value="static member Navigate : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.RelationshipEndMember * System.Data.Metadata.Edm.RelationshipEndMember -&gt; System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate (navigateFrom, fromEnd, toEnd)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="fromEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
        <Parameter Name="toEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="navigateFrom">Una expresión que especifica la instancia desde la que se debe producir la navegación.</param>
        <param name="fromEnd">Metadatos de la propiedad que representa el final de la relación desde la que se debe producir la navegación.</param>
        <param name="toEnd">Metadatos de la propiedad que representa el final de la relación hacia la que se debe producir la navegación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> que representa la navegación de una relación de asociación o composición.</summary>
        <returns>Nuevo DbRelationshipNavigationExpression que representa la navegación de los extremos de la relación desde y hasta especificados del tipo de relación especificada desde la instancia origen de navegación especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> requiere que se producen siempre la navegación de una referencia de modo que `navigateFrom` siempre debe tener un tipo de resultado de referencia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fromEnd" />, <paramref name="toEnd" /> o <paramref name="navigateFrom" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromEnd" /> y <paramref name="toEnd" /> no se declaran con el mismo tipo de relación o <paramref name="navigateFrom" /> tiene un tipo de resultado incompatible con el tipo de propiedad de <paramref name="fromEnd" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, System.Data.Common.CommandTrees.DbExpression navigateFrom);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, class System.Data.Common.CommandTrees.DbExpression navigateFrom) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Metadata.Edm.RelationshipType,System.String,System.String,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (type As RelationshipType, fromEndName As String, toEndName As String, navigateFrom As DbExpression) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Metadata::Edm::RelationshipType ^ type, System::String ^ fromEndName, System::String ^ toEndName, System::Data::Common::CommandTrees::DbExpression ^ navigateFrom);" />
      <MemberSignature Language="F#" Value="static member Navigate : System.Data.Metadata.Edm.RelationshipType * string * string * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate (type, fromEndName, toEndName, navigateFrom)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.RelationshipType" RefType="this" />
        <Parameter Name="fromEndName" Type="System.String" />
        <Parameter Name="toEndName" Type="System.String" />
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="type">Metadatos para el tipo de relación que representa la relación.</param>
        <param name="fromEndName">Nombre de la propiedad del tipo de relación que representa el final de la relación desde la que debe realizarse la navegación.</param>
        <param name="toEndName">Nombre de la propiedad del tipo de relación que representa el final de la relación en la que debe realizarse la navegación.</param>
        <param name="navigateFrom">Una expresión que especifica la instancia desde la que se debe producir la navegación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> que representa la navegación de una relación de asociación o composición.</summary>
        <returns>Nuevo DbRelationshipNavigationExpression que representa la navegación de los extremos de la relación desde y hasta especificados del tipo de relación especificada desde la instancia origen de navegación especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> requiere que se producen siempre la navegación de una referencia de modo que `navigateFrom` siempre debe tener un tipo de resultado de referencia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />, <paramref name="fromEndName" />, <paramref name="toEndName" /> o <paramref name="navigateFrom" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no está asociado al área de trabajo de metadatos de este árbol de comandos o <paramref name="navigateFrom" /> está asociado a otro árbol de comandos diferente, o <paramref name="type" /> no declara una propiedad de final de relación con el nombre <paramref name="toEndName" /> o <paramref name="fromEndName" />, o <paramref name="navigateFrom" /> tiene un tipo de resultado que no es compatible con el tipo de propiedad de la propiedad de final de relación con el nombre <paramref name="fromEndName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Negate (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Negate(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Negate (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Negate(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el argumento.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que niega el valor del argumento.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de negación.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico para <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, arguments As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Data.Metadata.Edm.TypeUsage * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New (instanceType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="instanceType">Tipo de la nueva instancia.</param>
        <param name="arguments">Expresiones que especifican valores de nuevas instancias, interpretadas según el tipo de la instancia.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Si el argumento de tipo es un tipo de colección, los argumentos especifican los elementos de la colección. De lo contrario, los argumentos se usan como valores de propiedad o de columna en la nueva instancia.</summary>
        <returns>Nuevo DbNewInstanceExpression con el tipo y los argumentos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `instanceType` es un tipo de colección, a continuación, todas las expresiones de `arguments` debe tener un tipo de resultado que se pueda promover al tipo de elemento de la `instanceType`. Si `instanceType` es un tipo de fila, `arguments` debe contener tantas expresiones como las columnas existentes en el tipo de fila y el tipo de resultado de cada expresión debe ser igual o promovible al tipo de la columna correspondiente. Un tipo de fila que no declara ninguna columna no es válido. Si `instanceType` es un tipo de entidad `arguments` debe contener tal muchas expresiones como las propiedades definidas por el tipo y el tipo de resultado de cada expresión debe ser igual o promovible al tipo de la propiedad correspondiente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" /> o <paramref name="arguments" /> es null, <paramref name="arguments" /> o contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> está vacío o los tipos de resultado de las expresiones incluidas no coinciden con los requisitos de <paramref name="instanceType" />. Vea la sección de notas para más información.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, ParamArray arguments As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Data.Metadata.Edm.TypeUsage * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New (instanceType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instanceType">Tipo de la nueva instancia.</param>
        <param name="arguments">Expresiones que especifican valores de nuevas instancias, interpretadas según el tipo de la instancia.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Si el argumento de tipo es un tipo de colección, los argumentos especifican los elementos de la colección. De lo contrario, los argumentos se usan como valores de propiedad o de columna en la nueva instancia.</summary>
        <returns>Nuevo DbNewInstanceExpression con el tipo y los argumentos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `instanceType` es un tipo de colección, a continuación, todas las expresiones de `arguments` debe tener un tipo de resultado que se pueda promover al tipo de elemento de la `instanceType`. Si `instanceType` es un tipo de fila, `arguments` debe contener tantas expresiones como las columnas existentes en el tipo de fila y el tipo de resultado de cada expresión debe ser igual o promovible al tipo de la columna correspondiente. Un tipo de fila que no declara ninguna columna no es válido. Si `instanceType` es un tipo de entidad `arguments` debe contener tal muchas expresiones como las propiedades definidas por el tipo y el tipo de resultado de cada expresión debe ser igual o promovible al tipo de la propiedad correspondiente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" /> o <paramref name="arguments" /> es null, <paramref name="arguments" /> o contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> está vacío o los tipos de resultado de las expresiones incluidas no coinciden con los requisitos de <paramref name="instanceType" />. Vea la sección de notas para más información.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewCollection">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que construye una colección que contiene los elementos especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (elements As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberSignature Language="F#" Value="static member NewCollection : seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection elements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">Una lista de expresiones que proporcionan los elementos de la colección.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que construye una colección que contiene los elementos especificados. El tipo de la colección está basado en el tipo común de los elementos. Si no existe ningún tipo de elemento común, se inicia una excepción.</summary>
        <returns>Nuevo DbNewInstanceExpression con el tipo de colección y los argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" /> es null, o contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" /> está vacío o contiene expresiones para las que no existe ningún tipo de resultado común.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (params System.Data.Common.CommandTrees.DbExpression[] elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Data.Common.CommandTrees.DbExpression[] elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (ParamArray elements As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberSignature Language="F#" Value="static member NewCollection : System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection elements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elements">Una lista de expresiones que proporcionan los elementos de la colección.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que construye una colección que contiene los elementos especificados. El tipo de la colección está basado en el tipo común de los elementos. Si no existe ningún tipo de elemento común, se inicia una excepción.</summary>
        <returns>Nuevo DbNewInstanceExpression con el tipo de colección y los argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" /> es null, o contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" /> está vacío o contiene expresiones para las que no existe ningún tipo de resultado común.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewEmptyCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection (this System.Data.Metadata.Edm.TypeUsage collectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection(class System.Data.Metadata.Edm.TypeUsage collectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NewEmptyCollection (collectionType As TypeUsage) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewEmptyCollection(System::Data::Metadata::Edm::TypeUsage ^ collectionType);" />
      <MemberSignature Language="F#" Value="static member NewEmptyCollection : System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection collectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="collectionType">Tipo de metadatos para la colección que se va a crear.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que construye una colección vacía del tipo de colección especificado.</summary>
        <returns>Nuevo DbNewInstanceExpression con el tipo de colección especificado y una lista vacía de <paramref name="Arguments" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionType" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionType" /> no es un tipo de colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow (columnValues As IEnumerable(Of KeyValuePair(Of String, DbExpression))) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewRow(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ columnValues);" />
      <MemberSignature Language="F#" Value="static member NewRow : seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow columnValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="columnValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="columnValues">Lista de pares clave-valor cadena-DbExpression que define la estructura y los valores de la fila.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> que genera una fila con las columnas con nombre especificadas y los valores definidos, especificados como expresiones.</summary>
        <returns>Nuevo DbNewInstanceExpression que representa la construcción de la fila.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="columnValues" /> es null o contiene un elemento con un nombre de columna o expresión null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="columnValues" /> está vacío o contiene un nombre de columna duplicado o no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNotExpression Not (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNotExpression Not(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Not (argument As DbExpression) As DbNotExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNotExpression ^ Not(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Not : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbNotExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNotExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión booleana que especifica el argumento.</param>
        <summary>Crea una expresión <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> que realiza la negación lógica del argumento definido.</summary>
        <returns>Nuevo DbNotExpression con el argumento especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression NotEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression NotEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NotEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ NotEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> que compara los argumentos izquierdo y derecho para ver si no son iguales.</summary>
        <returns>Nuevo DbComparisonExpression que representa la comparación de desigualdad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado cuya igualdad se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNullExpression Null (this System.Data.Metadata.Edm.TypeUsage nullType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNullExpression Null(class System.Data.Metadata.Edm.TypeUsage nullType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Null (nullType As TypeUsage) As DbNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNullExpression ^ Null(System::Data::Metadata::Edm::TypeUsage ^ nullType);" />
      <MemberSignature Language="F#" Value="static member Null : System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbNullExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null nullType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nullType">Tipo del valor NULL.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbNullExpression" />, que representa un valor NULL con tipo.</summary>
        <returns>Instancia de DbNullExpression.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nullType" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfType (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfType(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfType(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbOfTypeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="type">Metadatos del tipo que deben tener los elementos del conjunto de entrada para poder incluirlos en el conjunto resultante.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> que genera un conjunto de elementos del conjunto de entrada dado que son del tipo especificado.</summary>
        <returns>Nuevo DbOfTypeExpression con el argumento y el tipo determinados especificados, y un ExpressionKind de <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression requiere que `argument` tiene una colección de tipo de resultado con un tipo de elemento polimórfico y que `type` es un tipo de la misma jerarquía de tipos que ese tipo de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección o <paramref name="type" /> no pertenece a la misma jerarquía de tipos que el tipo de elemento tipo de resultado de la colección <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfTypeOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfTypeOnly (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfTypeOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member OfTypeOnly : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbOfTypeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="type">Metadatos del tipo con el que deben coincidir exactamente los elementos del conjunto de entrada para poder incluirlos en el conjunto resultante.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> que genera un conjunto de elementos del conjunto de entrada dado que son exactamente del tipo especificado.</summary>
        <returns>Nuevo DbOfTypeExpression con el argumento y el tipo determinados especificados, y un ExpressionKind de <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfTypeOnly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression requiere que `argument` tiene una colección de tipo de resultado con un tipo de elemento polimórfico y que `type` es un tipo de la misma jerarquía de tipos que ese tipo de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="type" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección o <paramref name="type" /> no pertenece a la misma jerarquía de tipos que el tipo de elemento tipo de resultado de la colección <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOrExpression Or (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOrExpression Or(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Or (left As DbExpression, right As DbExpression) As DbOrExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOrExpression ^ Or(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbOrExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOrExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión booleana que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión booleana que especifica el argumento derecho.</param>
        <summary>Crea una expresión <see cref="T:System.Data.Common.CommandTrees.DbOrExpression" /> que realiza la operación de OR lógico de los argumentos izquierdo y derecho.</summary>
        <returns>Nuevo DbOrExpression con argumentos especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" /> o <paramref name="right" /> no tiene un tipo de resultado booleano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación ascendente y la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación ascendente y la intercalación predeterminada.</summary>
        <returns>Nueva clase DbSortExpression que representa la operación order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene un tipo de resultado con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación ascendente y la intercalación especificada.</summary>
        <returns>Nueva clase DbSortExpression que representa la operación order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene ningún tipo de resultado de cadena con comparación de orden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación descendente y la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación descendente y la intercalación predeterminada.</summary>
        <returns>Nueva clase DbSortExpression que representa la operación order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene un tipo de resultado con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según la clave de ordenación especificada, con criterio de ordenación descendente y la intercalación especificada.</summary>
        <returns>Nueva clase DbSortExpression que representa la operación order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene ningún tipo de resultado de cadena con comparación de orden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OuterApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member OuterApply : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Un método que especifica la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. Las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío tienen un valor de <see langword="null" /> en la columna apply.</summary>
        <returns>Un nuevo DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El resultado de <paramref name="apply" /> contiene un nombre o expresión que es null.</exception>
        <exception cref="T:System.ArgumentException">El resultado de <paramref name="apply" /> contiene un nombre o una expresión que no son válidos en un enlace de expresiones.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberSignature Language="F#" Value="static member OuterApply : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply (input, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Un objeto <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> que especifica la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. Las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío tienen un valor de <see langword="null" /> en la columna apply.</summary>
        <returns>Un nuevo DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="apply" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Parameter (type As TypeUsage, name As String) As DbParameterReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbParameterReferenceExpression ^ Parameter(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : System.Data.Metadata.Edm.TypeUsage * string -&gt; System.Data.Common.CommandTrees.DbParameterReferenceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbParameterReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo del parámetro al que se hace referencia.</param>
        <param name="name">Nombre del parámetro al que se hace referencia.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> que hace referencia a un parámetro con el nombre y tipo especificados.</summary>
        <returns>DbParameterReferenceExpression que representa una referencia a un parámetro con el nombre y el tipo especificados. El tipo de resultado de la expresión será el mismo que para <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Plus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Plus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Plus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Plus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Plus : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que especifica el argumento izquierdo.</param>
        <param name="right">Una expresión que especifica el argumento derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que agrega el argumento izquierdo al argumento derecho.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de suma.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico común entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Project (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Project(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Project (input As DbExpressionBinding, projection As DbExpression) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Project(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ projection);" />
      <MemberSignature Language="F#" Value="static member Project : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project (input, projection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="projection" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="projection">Una expresión que se va a proyectar sobre el conjunto.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que proyecta la expresión especificada sobre el conjunto de entrada definido.</summary>
        <returns>Nuevo DbProjectExpression que representa la operación de proyección.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="projection" /> es null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa la recuperación de la propiedad de navegación especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.EdmProperty propertyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.EdmProperty propertyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EdmProperty)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyMetadata As EdmProperty) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::EdmProperty ^ propertyMetadata);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.EdmProperty -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, propertyMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyMetadata" Type="System.Data.Metadata.Edm.EdmProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia desde la que se va a recuperar la propiedad. Puede ser NULL si la propiedad es estática.</param>
        <param name="propertyMetadata">Metadatos de la propiedad que se va a recuperar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa la recuperación de la propiedad de navegación especificada.</summary>
        <returns>Nuevo DbPropertyExpression que representa la recuperación de la propiedad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyMetadata" /> es null o <paramref name="instance" /> es null y la propiedad no es estática.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.NavigationProperty navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.NavigationProperty navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.NavigationProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::NavigationProperty ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.NavigationProperty -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="navigationProperty" Type="System.Data.Metadata.Edm.NavigationProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia desde la que se va a recuperar la propiedad de navegación.</param>
        <param name="navigationProperty">Metadatos de la propiedad de navegación que se va a recuperar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa la recuperación de la propiedad de navegación especificada.</summary>
        <returns>Nuevo DbPropertyExpression que representa la recuperación de la propiedad de navegación.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigationProperty" /> o <paramref name="instance" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, relationshipEnd As RelationshipEndMember) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::RelationshipEndMember ^ relationshipEnd);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.RelationshipEndMember -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, relationshipEnd)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="relationshipEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia de la que se va a recuperar el miembro de fin de relación.</param>
        <param name="relationshipEnd">Metadatos del miembro de fin de relación que se va a recuperar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa la recuperación del miembro de fin de relación especificado.</summary>
        <returns>Nuevo DbPropertyExpression que representa la recuperación de la relación y del miembro.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipEnd" /> es null o <paramref name="instance" /> es null y la propiedad no es estática.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyName As String) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia desde la que se va a recuperar la propiedad.</param>
        <param name="propertyName">Nombre de la propiedad que se va a recuperar.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> que representa la recuperación de la propiedad de instancia con el nombre especificado de la instancia determinada.</summary>
        <returns>Nuevo DbPropertyExpression que representa la recuperación de la propiedad.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyName" /> es null o <paramref name="instance" /> es null y la propiedad no es estática.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">No se declara ninguna propiedad con el nombre especificado por el tipo de <paramref name="instance" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RefFromKey">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva clase <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta basada en los valores de clave.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow);" />
      <MemberSignature Language="F#" Value="static member RefFromKey : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey (entitySet, keyRow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="keyRow">Expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que construye un registro con columnas que coinciden (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <summary>Crea una nueva clase <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta basada en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` debe ser una expresión que especifica los valores de clave que identifican la entidad que se hace referencia dentro de la entidad especificada establecida. El tipo de resultado de `keyRow` debe contener una columna correspondiente para cada propiedad clave definida por `entitySet's` tipo de entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> o <paramref name="keyRow" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyRow" /> no tiene un tipo de resultado de registro que coincida con las propiedades de clave del tipo de entidad del conjunto de entidades al que se hace referencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow, System.Data.Metadata.Edm.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow, class System.Data.Metadata.Edm.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EntityType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow, System::Data::Metadata::Edm::EntityType ^ entityType);" />
      <MemberSignature Language="F#" Value="static member RefFromKey : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.EntityType -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey (entitySet, keyRow, entityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
      </Parameters>
      <Docs>
        <param name="entitySet">Conjunto de entidades en el que reside el elemento al que se hace referencia.</param>
        <param name="keyRow">Expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que construye un registro con columnas que coinciden (en número, tipo y orden) con las propiedades clave del tipo de entidad al que se hace referencia.</param>
        <param name="entityType">Tipo de la entidad a la que se debería referir la referencia.</param>
        <summary>Crea una nueva clase <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> que codifica una referencia a una entidad concreta basada en los valores de clave.</summary>
        <returns>Nueva clase DbRefExpression que hace referencia al elemento con los valores de clave especificados en el conjunto de entidades especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` debe ser una expresión que especifica los valores de clave que identifican la entidad que se hace referencia dentro de la entidad especificada establecida. El tipo de resultado de `keyRow` debe contener una columna correspondiente para cada propiedad clave definida por `entitySet's` tipo de entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />, <paramref name="keyRow" /> o <paramref name="entityType" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entityType" /> no está en la misma jerarquía de tipos que el tipo de entidad del conjunto de entidades, o <paramref name="keyRow" /> no tiene un tipo de resultado de registro que coincida con las propiedades de clave del tipo de entidad del conjunto de entidades a que se hace referencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbScanExpression Scan (this System.Data.Metadata.Edm.EntitySetBase targetSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbScanExpression Scan(class System.Data.Metadata.Edm.EntitySetBase targetSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan(System.Data.Metadata.Edm.EntitySetBase)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Scan (targetSet As EntitySetBase) As DbScanExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbScanExpression ^ Scan(System::Data::Metadata::Edm::EntitySetBase ^ targetSet);" />
      <MemberSignature Language="F#" Value="static member Scan : System.Data.Metadata.Edm.EntitySetBase -&gt; System.Data.Common.CommandTrees.DbScanExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan targetSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbScanExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSet" Type="System.Data.Metadata.Edm.EntitySetBase" RefType="this" />
      </Parameters>
      <Docs>
        <param name="targetSet">Metadatos del conjunto de entidades o relaciones al que se va a hacer referencia.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbScanExpression" /> que hace referencia a la entidad o conjunto de relaciones especificados.</summary>
        <returns>Nuevo DbScanExpression basado en el conjunto de entidades o relaciones especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetSet" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TProjection&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt; projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, !!TProjection&gt; projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TProjection) (source As DbExpression, projection As Func(Of DbExpression, TProjection)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TProjection&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Select(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, TProjection&gt; ^ projection);" />
      <MemberSignature Language="F#" Value="static member Select : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, 'Projection&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select (source, projection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProjection" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="projection" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProjection">Tipo de resultado del método de <paramref name="projection" />.</typeparam>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="projection">Método que especifica cómo derivar la expresión proyectada, dado un miembro del conjunto de entrada. Este método debe generar una instancia de un tipo que sea compatible con Select y se pueda resolver en una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Los requisitos de compatibilidad de <c>TProjection</c> se describen en la sección Comentarios.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que selecciona la expresión especificada sobre el conjunto de entrada definido.</summary>
        <returns>Nuevo DbProjectExpression que representa la operación de selección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que sea compatible con Select, `TProjection` debe derivarse de <xref:System.Data.Common.CommandTrees.DbExpression>, o debe ser un tipo anónimo con propiedades derivadas de DbExpression. Los siguientes son ejemplos de tipos admitidos para `TProjection`:  
  
```  
source.Select(x => x.Property("Name"))  
```  
  
 `TProjection` es <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.Select(x => new { Name = x.Property("Name") })  
```  
  
 (`TProjection` es un tipo anónimo con una propiedad derivadas de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El resultado de <paramref name="projection" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany (source As DbExpression, apply As Func(Of DbExpression, DbExpression)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Método que representa la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. No se incluyen las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío. A continuación, se crea un objeto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que selecciona la columna <paramref name="apply" /> de cada fila, generando la colección total de resultados <paramref name="apply" />.</summary>
        <returns>Un nuevo DbProjectExpression que selecciona la columna apply de una nueva DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="apply" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="apply" /> no tiene un tipo colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSelector) (source As DbExpression, apply As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, 'Selector&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany (source, apply, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Tipo de resultado del método de <paramref name="selector" />.</typeparam>
        <param name="source">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que especifica el conjunto de entrada.</param>
        <param name="apply">Método que representa la lógica que se va a evaluar una vez por cada miembro del conjunto de entrada.</param>
        <param name="selector">Un método que especifica cómo se debe derivar un elemento del conjunto de resultados, dado un elemento de los conjuntos input y apply. Este método debe generar una instancia de un tipo que sea compatible con SelectMany y se pueda resolver en una expresión <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Los requisitos de compatibilidad de <c>TSelector</c> se describen en la sección Comentarios.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> que evalúa la expresión <paramref name="apply" /> definida una vez por cada elemento de un conjunto de entrada dado y genera una colección de filas con las columnas input y apply correspondientes. No se incluyen las filas para las que <paramref name="apply" /> se evalúa como un conjunto vacío. A continuación, se crea un objeto <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> que selecciona el <paramref name="selector" /> especificado en cada fila, generando la colección de resultados total.</summary>
        <returns>Un nuevo DbProjectExpression que selecciona el resultado del selector dado de una nueva DbApplyExpression con los enlaces de entrada y aplicación especificados y un <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> de CrossApply.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que sea compatible con SelectMany, `TSelector` debe derivarse de <xref:System.Data.Common.CommandTrees.DbExpression>, o debe ser un tipo anónimo con propiedades derivadas de DbExpression. Los siguientes son ejemplos de tipos admitidos para `TSelector`:  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => apply.Property("Name"))  
```  
  
 (`TSelector` es <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => new { SourceName = source.Property("Name"), RelatedName = apply.Property("Name") })  
```  
  
 (`TSelector` es un tipo anónimo con propiedades derivadas de DbExpression).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El resultado de <paramref name="selector" /> es null en la conversión a DbExpression.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="apply" /> no tiene un tipo colección. no tiene un tipo de colección.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Skip">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> que ordena el conjunto de entrada dado según las especificaciones de ordenación dadas antes de omitir el número especificado de elementos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbSortExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbSortExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbSortExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (argument As DbSortExpression, count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbSortExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Data.Common.CommandTrees.DbSortExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSkipExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que especifica el conjunto de entrada ordenado.</param>
        <param name="count">Una expresión que especifica cuántos elementos del conjunto ordenado se van a omitir.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> que omite el número especificado de elementos del conjunto de entrada ordenado dado.</summary>
        <returns>Nuevo DbSkipExpression que representa la operación de salto.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> no es <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> o <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> o tiene un tipo de resultado que no es igual ni se puede promover a un tipo entero de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause), count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Data.Common.CommandTrees.DbExpressionBinding * seq&lt;System.Data.Common.CommandTrees.DbSortClause&gt; * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSkipExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip (input, sortOrder, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="sortOrder">Una lista de especificaciones de ordenación que determinan cómo deberían ordenarse los elementos del conjunto de entrada.</param>
        <param name="count">Una expresión que especifica cuántos elementos del conjunto ordenado se van a omitir.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> que ordena el conjunto de entrada dado según las especificaciones de ordenación dadas antes de omitir el número especificado de elementos.</summary>
        <returns>Nuevo DbSkipExpression que representa la operación de salto.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="sortOrder" /> o <paramref name="count" /> es null, o <paramref name="sortOrder" /> contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> está vacío o <paramref name="count" /> no es <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> o <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> o tiene un tipo de resultado que no es igual ni se puede promover a un tipo entero de 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression Sort (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression Sort(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sort (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ Sort(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder);" />
      <MemberSignature Language="F#" Value="static member Sort : System.Data.Common.CommandTrees.DbExpressionBinding * seq&lt;System.Data.Common.CommandTrees.DbSortClause&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort (input, sortOrder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Un enlace de expresión que especifica el conjunto de entrada.</param>
        <param name="sortOrder">Una lista de especificaciones de ordenación que determinan cómo deberían ordenarse los elementos del conjunto de entrada.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> que ordena el conjunto de entrada definido según las especificaciones de ordenación determinadas.</summary>
        <returns>Nueva clase DbSortExpression que representa la operación de ordenación.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="sortOrder" /> es null, <paramref name="sortOrder" /> o contiene null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> está vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Take (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Take(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Take(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLimitExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la colección de entrada.</param>
        <param name="count">Una expresión que especifica el valor de límite.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> que restringe el número de elementos en la colección Argument al valor de Limit especificado. Los resultados enlazados no se incluyen en el resultado.</summary>
        <returns>Nuevo DbLimitExpression con valores de límite de argumento y recuento especificados que no incluye resultados iguales.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="count" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" /> no tiene un tipo de resultado de la colección, <paramref name="count" /> no tiene ningún tipo de resultado que sea igual o se pueda promover a un tipo entero de 64 bits.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, así como la clave de ordenación especificada en orden ascendente y con la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">DbSortExpression que especifica el conjunto de entrada ordenado.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación adicional, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, así como la clave de ordenación especificada en orden ascendente y con la intercalación predeterminada.</summary>
        <returns>Nueva clase DbSortExpression que representa la nueva operación global order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortKey" /> no tiene un tipo de resultado de cadena con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">DbSortExpression que especifica el conjunto de entrada ordenado.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación adicional, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, junto con la clave de ordenación especificada en orden ascendente y con la intercalación especificada.</summary>
        <returns>Nueva clase DbSortExpression que representa la nueva operación global order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene ningún tipo de resultado de cadena con comparación de orden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, así como la clave de ordenación especificada en orden descendente y con la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">DbSortExpression que especifica el conjunto de entrada ordenado.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación adicional, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, así como la clave de ordenación especificada en orden descendente y con la intercalación predeterminada.</summary>
        <returns>Nueva clase DbSortExpression que representa la nueva operación global order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene un tipo de resultado con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">DbSortExpression que especifica el conjunto de entrada ordenado.</param>
        <param name="sortKey">Un método que especifica cómo derivar la expresión de clave de ordenación adicional, dado un miembro del conjunto de entrada. Este método debe generar una expresión con un tipo de resultado con comparación de orden que proporcione la definición de la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> con un criterio de ordenación que incluye el criterio de ordenación del conjunto de entrada de orden especificado, junto con la clave de ordenación especificada en orden descendente y con la intercalación especificada.</summary>
        <returns>Nueva clase DbSortExpression que representa la nueva operación global order by.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="sortKey" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión generada por <paramref name="sortKey" /> no tiene ningún tipo de resultado de cadena con comparación de orden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClause">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación ascendente y la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberSignature Language="F#" Value="static member ToSortClause : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Expresión que define la clave de ordenación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación ascendente y la intercalación predeterminada.</summary>
        <returns>Nueva cláusula de ordenación con la clave de orden y orden de clasificación ascendente especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> no tiene un tipo de resultado de cadena con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ToSortClause : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause (key, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Expresión que define la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación ascendente y la intercalación especificada.</summary>
        <returns>Nueva cláusula de ordenación con la clave de ordenación y colación y orden de clasificación ascendente especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> no tiene un tipo de resultado de cadena con comparación de orden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClauseDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación descendente y la intercalación predeterminada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberSignature Language="F#" Value="static member ToSortClauseDescending : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Expresión que define la clave de ordenación.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación descendente y la intercalación predeterminada.</summary>
        <returns>Nueva cláusula de ordenación con la clave de orden y orden de clasificación descendente especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> no tiene un tipo de resultado de cadena con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ToSortClauseDescending : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending (key, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Expresión que define la clave de ordenación.</param>
        <param name="collation">Intercalación por la que se va a ordenar.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> con un criterio de ordenación descendente y la intercalación especificada.</summary>
        <returns>Nueva cláusula de ordenación con la clave de ordenación y colación y orden de clasificación descendente especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" /> está vacío o solo contiene caracteres de espacios en blanco.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> no tiene un tipo de resultado de cadena con comparación de orden.</exception>
      </Docs>
    </Member>
    <Member MemberName="TreatAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbTreatExpression TreatAs (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage treatType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbTreatExpression TreatAs(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage treatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TreatAs (argument As DbExpression, treatType As TypeUsage) As DbTreatExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbTreatExpression ^ TreatAs(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ treatType);" />
      <MemberSignature Language="F#" Value="static member TreatAs : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbTreatExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs (argument, treatType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbTreatExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="treatType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica la instancia.</param>
        <param name="treatType">Metadatos del tipo como se debe tratar.</param>
        <summary>Crea un nuevo <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression" />.</summary>
        <returns>Nuevo DbTreatExpression con el argumento y el tipo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbTreatExpression requiere que `argument` tiene un tipo de resultado polimórfico y que `treatType` es un tipo de la misma jerarquía de tipos que ese tipo de resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> o <paramref name="treatType" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="treatType" /> no está en la misma jerarquía de tipos que el tipo de resultado de <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="True">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression True { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression True" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property True As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ True { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.True : System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una expresión <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con el valor booleano <see langword="true" />.</summary>
        <value>Una expresión <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> con el valor booleano <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnaryMinus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnaryMinus (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ UnaryMinus(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member UnaryMinus : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Una expresión que especifica el argumento.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> que niega el valor del argumento.</summary>
        <returns>Nuevo DbArithmeticExpression que representa la operación de negación.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado numérico para <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Union (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Union(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union (left As DbExpression, right As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Union(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Union : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que define el argumento del conjunto izquierdo.</param>
        <param name="right">Una expresión que define el argumento del conjunto derecho.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> que calcula la unión de los argumentos del conjunto izquierdo y derecho con los duplicados quitados.</summary>
        <returns>Nuevo elemento DbExpression que calcula la unión, sin duplicados, de los argumentos izquierdo y derecho.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado de colección común con un tipo de elemento cuya igualdad se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnionAll (left As DbExpression, right As DbExpression) As DbUnionAllExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbUnionAllExpression ^ UnionAll(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member UnionAll : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbUnionAllExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbUnionAllExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Una expresión que define el argumento del conjunto izquierdo.</param>
        <param name="right">Una expresión que define el argumento del conjunto derecho.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbUnionAllExpression" /> que calcula la unión de los argumentos del conjunto izquierdo y derecho, y no quita los duplicados.</summary>
        <returns>Nuevo elemento DbUnionAllExpression que realiza la unión, incluidos los duplicados, de los argumentos izquierdo y derecho.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> o <paramref name="right" /> es null.</exception>
        <exception cref="T:System.ArgumentException">No existe ningún tipo de resultado de colección común con un tipo de elemento cuya igualdad se pueda comparar entre <paramref name="left" /> y <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Variable (type As TypeUsage, name As String) As DbVariableReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbVariableReferenceExpression ^ Variable(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : System.Data.Metadata.Edm.TypeUsage * string -&gt; System.Data.Common.CommandTrees.DbVariableReferenceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbVariableReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de la variable a la que se hace referencia.</param>
        <param name="name">Nombre de la variable a la que se hace referencia.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> que hace referencia a una variable con el nombre y tipo especificados.</summary>
        <returns>DbVariableReferenceExpression que representa una referencia a una variable con el nombre y el tipo especificados. El tipo de resultado de la expresión será el mismo que para <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Where (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Where(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Where(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbFilterExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Una expresión que especifica el conjunto de entrada.</param>
        <param name="predicate">Método que representa el predicado que se va a evaluar para cada miembro del conjunto de entrada.    Este método debe generar una expresión con un tipo de resultado booleano que proporcione la lógica del predicado.</param>
        <summary>Crea una nueva expresión <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> que filtra los elementos del conjunto de entrada definido utilizando el predicado especificado.</summary>
        <returns>Nuevo DbQuantifierExpression que representa la operación Any.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La expresión producida por <paramref name="predicate" /> es un valor null.</exception>
        <exception cref="T:System.ArgumentException">La expresión producida por <paramref name="predicate" /> no tiene un tipo de resultado Booleano.</exception>
      </Docs>
    </Member>
  </Members>
</Type>