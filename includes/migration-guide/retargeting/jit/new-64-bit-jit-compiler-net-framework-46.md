### <a name="new-64-bit-jit-compiler-in-the-net-framework-46"></a>Nuevo compilador JIT de 64 bits de .NET Framework 4.6

|   |   |
|---|---|
|Detalles|A partir de .NET Framework 4.6, se utiliza un nuevo compilador JIT de 64 bits para la compilación Just-In-Time. En algunos casos, se produce una excepción inesperada o se observa un comportamiento diferente que si una aplicación se ejecuta con el compilador de 32 bits o el antiguo compilador JIT de 64 bits. Este cambio no afecta el compilador JIT de 32 bits. El conocido diferencias incluyen lo siguiente:<ul><li>En determinadas condiciones, una operación de conversión unboxing puede producir una <xref:System.NullReferenceException> en versiones de lanzamiento con la optimización activada.</li><li>En algunos casos, la ejecución del código de producción en un cuerpo del método de gran tamaño puede producir una <xref:System.StackOverflowException>.</li><li>Bajo ciertas condiciones, las estructuras que se pasa a un método se tratan como tipos de referencia en lugar de como valor genera tipos de versión. Una de las manifestaciones de este problema es que los elementos individuales de una colección aparecen en un orden inesperado.</li><li>En determinadas condiciones, la comparación de los valores <xref:System.UInt16> con su conjunto de bits altos es incorrecta si se habilita la optimización.</li><li>En determinadas condiciones, especialmente al indexar los valores de matriz, la inicialización de la memoria mediante la instrucción IL <xref:System.Reflection.Emit.OpCodes.Initblk?displayProperty=nameWithType> puede inicializar la memoria con un valor incorrecto. Esto puede producir una excepción no controlada o resultados incorrectos.</li><li>En determinadas condiciones poco frecuentes, una prueba de bits condicional puede devolver el valor <xref:System.Boolean> incorrecto o producir una excepción si se habilitan las optimizaciones del compilador.</li><li>En determinadas condiciones, si se utiliza una instrucción <code>if</code> para comprobar una condición antes de entrar en un bloque <code>try</code> y en la salida del bloque <code>try</code>, y se evalúa la misma condición en el bloque <code>catch</code> o <code>finally</code>, el compilador JIT de 64 bits nuevo quita la condición <code>if</code> del bloque <code>catch</code> o <code>finally</code> cuando optimiza el código. Como resultado, el código dentro de la instrucción <code>if</code> en el bloque <code>catch</code> o <code>finally</code> se ejecuta de forma incondicional.</li></ul>|
|Sugerencia|<strong>Mitigación de los problemas conocidos</strong> si se producen los problemas mencionados anteriormente, puede aplicarlas si realiza cualquiera de las siguientes acciones:<ul><li>Actualizar a the .NET Framework 4.6.2. El nuevo compilador de 64 bits incluido con .NET Framework 4.6.2 soluciona estos problemas conocidos.</li><li>Asegurarse de que su versión Windows está actualizada ejecutando Windows Update. Las actualizaciones de servicio de .NET Framework 4.6 y 4.6.1 solucionan los problemas excepto <xref:System.NullReferenceException> en una operación de conversión unboxing.</li><li>Compilación con el compilador JIT de 64 bits más antiguo. Vea la sección <strong>Mitigación de otros problemas</strong> sección para obtener más información sobre el procedimiento.</li></ul><strong>Mitigación de otros problemas</strong> si encuentra cualquier otra diferencia de comportamiento entre el código compilado con el compilador de 64 bits más antiguo y el nuevo compilador JIT de 64 bits, o entre las versiones de lanzamiento y depuración de la aplicación que son ambos compilan con la nueva compilador JIT de 64 bits, puede hacer lo siguiente para compilar su aplicación con el antiguo compilador JIT de 64 bits:<ul><li>Según la aplicación, se puede agregar el elemento [\<useLegacyJit>](~/docs/framework/configure-apps/file-schema/runtime/uselegacyjit-element.md) al archivo de configuración de la aplicación. Lo siguiente deshabilita la compilación con el nuevo compilador JIT de 64 bits y en su lugar usa el compilador JIT de 64 bits hereado.</li></ul><pre><code class="language-xml">&lt;?xml version =&quot;1.0&quot;?&gt;&#13;&#10;&lt;configuration&gt;&#13;&#10;&lt;runtime&gt;&#13;&#10;&lt;useLegacyJit enabled=&quot;1&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;&lt;/configuration&gt;&#13;&#10;</code></pre><ul><li>Según el usuario, puede agregar un valor <code>REG_DWORD</code> con el nombre <code>useLegacyJit</code> a la clave <code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\.NETFramework</code> del registro. El valor 1 permite al compilador JIT de 64 bits hereado; un valor de 0 lo deshabilita y habilita el nuevo compilador JIT de 64 bits.</li><li>Según el equipo, puede agregar un valor <code>REG_DWORD</code> con el nombre <code>useLegacyJit</code> a la clave <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework</code> del registro. Un valor de <code>1</code> compilador JIT de habilita el 64-bit heredado; un valor de <code>0</code> lo deshabilita y habilita el nuevo compilador JIT de 64 bits.</li></ul>También puede informar del problema indicándonos el error en [Microsoft Connect](https://connect.microsoft.com/VisualStudio).|
|Ámbito|Borde|
|Versión|4.6|
|Tipo|Redestinación|

