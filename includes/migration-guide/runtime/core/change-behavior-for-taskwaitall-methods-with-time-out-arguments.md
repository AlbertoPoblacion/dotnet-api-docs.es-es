### <a name="change-in-behavior-for-taskwaitall-methods-with-time-out-arguments"></a><span data-ttu-id="d8e88-101">Cambio en el comportamiento para Task.WaitAll métodos con argumentos de tiempo de espera</span><span class="sxs-lookup"><span data-stu-id="d8e88-101">Change in behavior for Task.WaitAll methods with time-out arguments</span></span>

|   |   |
|---|---|
|<span data-ttu-id="d8e88-102">Detalles</span><span class="sxs-lookup"><span data-stu-id="d8e88-102">Details</span></span>|<span data-ttu-id="d8e88-103">Comportamiento de Task.WaitAll se realizó más coherente en .NET 4.5.In .NET Framework 4, estos métodos se comportaban de forma incoherente.</span><span class="sxs-lookup"><span data-stu-id="d8e88-103">Task.WaitAll behavior was made more consistent in .NET 4.5.In the .NET Framework 4, these methods behaved inconsistently.</span></span> <span data-ttu-id="d8e88-104">Cuando se agotaba el tiempo de espera, si una o varias tareas se completaban o cancelaban antes de la llamada al método, el método producía una excepción <xref:System.AggregateException?displayProperty=name>.</span><span class="sxs-lookup"><span data-stu-id="d8e88-104">When the time-out expired, if one or more tasks were completed or canceled before the method call, the method threw an <xref:System.AggregateException?displayProperty=name> exception.</span></span> <span data-ttu-id="d8e88-105">Cuando se agotaba el tiempo de espera, si no se completaba ni cancelaba ninguna tarea antes de la llamada al método, pero una o varias tareas entraban en estos estados después de la llamada al método, el método pasaba a ser false.</span><span class="sxs-lookup"><span data-stu-id="d8e88-105">When the time-out expired, if no tasks were completed or canceled before the method call, but one or more tasks entered these states after the method call, the method returned false.</span></span><br/><br/><span data-ttu-id="d8e88-106">En .NET Framework 4.5, estas sobrecargas de método ahora devuelven false si las tareas siguen en ejecución cuando se agotó el intervalo de tiempo de espera y producen una <xref:System.AggregateException?displayProperty=name> excepción solo si se ha cancelado una tarea de entrada (independientemente de si formaba antes o después del método llamar a) y ninguna otra tarea en ejecución.</span><span class="sxs-lookup"><span data-stu-id="d8e88-106">In the .NET Framework 4.5, these method overloads now return false if any tasks are still running when the time-out interval expired, and they throw an <xref:System.AggregateException?displayProperty=name> exception only if an input task was cancelled (regardless of whether it was before or after the method call) and no other tasks are still running.</span></span>|
|<span data-ttu-id="d8e88-107">Sugerencia</span><span class="sxs-lookup"><span data-stu-id="d8e88-107">Suggestion</span></span>|<span data-ttu-id="d8e88-108">Si un <xref:System.AggregateException?displayProperty=name> que se detectó como un medio para detectar una tarea que se canceló antes de la llamada WaitAll que se invoca, que el código en su lugar, debe hacer la misma detección a través de la propiedad IsCanceled (por ejemplo:. Any(t =&gt; t.IsCanceled)) dado que .NET 4.6 sólo se producirá en ese caso si todas las tareas de esperadas son secundarios antes de que el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d8e88-108">If an <xref:System.AggregateException?displayProperty=name> was being caught as a means of detecting a task that was cancelled prior to the WaitAll call being invoked, that code should instead do the same detection via the IsCanceled property (for example: .Any(t =&gt; t.IsCanceled)) since .NET 4.6 will only throw in that case if all awaited tasks are completed prior to the timeout.</span></span>|
|<span data-ttu-id="d8e88-109">Ámbito</span><span class="sxs-lookup"><span data-stu-id="d8e88-109">Scope</span></span>|<span data-ttu-id="d8e88-110">Secundaria</span><span class="sxs-lookup"><span data-stu-id="d8e88-110">Minor</span></span>|
|<span data-ttu-id="d8e88-111">Versión</span><span class="sxs-lookup"><span data-stu-id="d8e88-111">Version</span></span>|<span data-ttu-id="d8e88-112">4.5</span><span class="sxs-lookup"><span data-stu-id="d8e88-112">4.5</span></span>|
|<span data-ttu-id="d8e88-113">Tipo</span><span class="sxs-lookup"><span data-stu-id="d8e88-113">Type</span></span>|<span data-ttu-id="d8e88-114">Tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="d8e88-114">Runtime</span></span>|
|<span data-ttu-id="d8e88-115">API afectadas</span><span class="sxs-lookup"><span data-stu-id="d8e88-115">Affected APIs</span></span>|<ul><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)?displayProperty=nameWithType></li></ul>|

